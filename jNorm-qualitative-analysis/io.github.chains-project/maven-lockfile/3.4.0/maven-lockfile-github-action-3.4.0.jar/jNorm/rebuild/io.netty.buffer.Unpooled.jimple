public final class io.netty.buffer.Unpooled extends java.lang.Object
{
private static final io.netty.buffer.ByteBufAllocator ALLOC;
public static final java.nio.ByteOrder BIG_ENDIAN;
public static final java.nio.ByteOrder LITTLE_ENDIAN;
public static final io.netty.buffer.ByteBuf EMPTY_BUFFER;
static final boolean $assertionsDisabled;
public static io.netty.buffer.ByteBuf buffer()
{
io.netty.buffer.ByteBuf v1;
io.netty.buffer.ByteBufAllocator v0;
v0 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBufAllocator ALLOC>;
v1 = interfaceinvoke v0.<io.netty.buffer.ByteBufAllocator: io.netty.buffer.ByteBuf heapBuffer()>();
return v1;
}
public static io.netty.buffer.ByteBuf directBuffer()
{
io.netty.buffer.ByteBuf v1;
io.netty.buffer.ByteBufAllocator v0;
v0 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBufAllocator ALLOC>;
v1 = interfaceinvoke v0.<io.netty.buffer.ByteBufAllocator: io.netty.buffer.ByteBuf directBuffer()>();
return v1;
}
public static io.netty.buffer.ByteBuf buffer(int)
{
int v0;
io.netty.buffer.ByteBuf v2;
io.netty.buffer.ByteBufAllocator v1;
v0 := @parameter0: int;
v1 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBufAllocator ALLOC>;
v2 = interfaceinvoke v1.<io.netty.buffer.ByteBufAllocator: io.netty.buffer.ByteBuf heapBuffer(int)>(v0);
return v2;
}
public static io.netty.buffer.ByteBuf directBuffer(int)
{
int v0;
io.netty.buffer.ByteBuf v2;
io.netty.buffer.ByteBufAllocator v1;
v0 := @parameter0: int;
v1 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBufAllocator ALLOC>;
v2 = interfaceinvoke v1.<io.netty.buffer.ByteBufAllocator: io.netty.buffer.ByteBuf directBuffer(int)>(v0);
return v2;
}
public static io.netty.buffer.ByteBuf buffer(int, int)
{
io.netty.buffer.ByteBuf v3;
io.netty.buffer.ByteBufAllocator v2;
int v0, v1;
v0 := @parameter0: int;
v1 := @parameter1: int;
v2 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBufAllocator ALLOC>;
v3 = interfaceinvoke v2.<io.netty.buffer.ByteBufAllocator: io.netty.buffer.ByteBuf heapBuffer(int,int)>(v0, v1);
return v3;
}
public static io.netty.buffer.ByteBuf directBuffer(int, int)
{
io.netty.buffer.ByteBuf v3;
io.netty.buffer.ByteBufAllocator v2;
int v0, v1;
v0 := @parameter0: int;
v1 := @parameter1: int;
v2 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBufAllocator ALLOC>;
v3 = interfaceinvoke v2.<io.netty.buffer.ByteBufAllocator: io.netty.buffer.ByteBuf directBuffer(int,int)>(v0, v1);
return v3;
}
public static io.netty.buffer.ByteBuf wrappedBuffer(byte[])
{
byte[] v0;
io.netty.buffer.ByteBuf v2;
io.netty.buffer.ByteBufAllocator v4;
int v1, v5;
io.netty.buffer.UnpooledHeapByteBuf v3;
v0 := @parameter0: byte[];
v1 = lengthof v0;
if v1 != 0 goto label1;
v2 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v2;
label1:
v3 = new io.netty.buffer.UnpooledHeapByteBuf;
v4 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBufAllocator ALLOC>;
v5 = lengthof v0;
specialinvoke v3.<io.netty.buffer.UnpooledHeapByteBuf: void <init>(io.netty.buffer.ByteBufAllocator,byte[],int)>(v4, v0, v5);
return v3;
}
public static io.netty.buffer.ByteBuf wrappedBuffer(byte[], int, int)
{
byte[] v0;
io.netty.buffer.ByteBuf v3, v5, v6, v7;
int v1, v2, v4;
v0 := @parameter0: byte[];
v1 := @parameter1: int;
v2 := @parameter2: int;
if v2 != 0 goto label1;
v3 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v3;
label1:
if v1 != 0 goto label2;
v4 = lengthof v0;
if v2 != v4 goto label2;
v5 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf wrappedBuffer(byte[])>(v0);
return v5;
label2:
v6 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf wrappedBuffer(byte[])>(v0);
v7 = virtualinvoke v6.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf slice(int,int)>(v1, v2);
return v7;
}
public static io.netty.buffer.ByteBuf wrappedBuffer(java.nio.ByteBuffer)
{
byte[] v5;
io.netty.buffer.ByteBufAllocator v17, v19, v21, v25, v27;
java.nio.ByteBuffer v0;
io.netty.buffer.ReadOnlyByteBufferBuf v18, v24;
io.netty.buffer.ByteBuf v10, v12, v2;
int v22, v28, v6, v7, v8, v9;
boolean v1, v13, v14, v15, v23, v3, v4;
io.netty.buffer.UnpooledUnsafeDirectByteBuf v20;
java.nio.ByteOrder v11;
io.netty.buffer.ReadOnlyUnsafeDirectByteBuf v16;
io.netty.buffer.UnpooledDirectByteBuf v26;
v0 := @parameter0: java.nio.ByteBuffer;
v1 = virtualinvoke v0.<java.nio.ByteBuffer: boolean hasRemaining()>();
if v1 != 0 goto label1;
v2 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v2;
label1:
v3 = virtualinvoke v0.<java.nio.ByteBuffer: boolean isDirect()>();
if v3 != 0 goto label2;
v4 = virtualinvoke v0.<java.nio.ByteBuffer: boolean hasArray()>();
if v4 == 0 goto label2;
v5 = virtualinvoke v0.<java.nio.ByteBuffer: byte[] array()>();
v6 = virtualinvoke v0.<java.nio.ByteBuffer: int arrayOffset()>();
v7 = virtualinvoke v0.<java.nio.ByteBuffer: int position()>();
v8 = v6 + v7;
v9 = virtualinvoke v0.<java.nio.ByteBuffer: int remaining()>();
v10 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf wrappedBuffer(byte[],int,int)>(v5, v8, v9);
v11 = virtualinvoke v0.<java.nio.ByteBuffer: java.nio.ByteOrder order()>();
v12 = virtualinvoke v10.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf order(java.nio.ByteOrder)>(v11);
return v12;
label2:
v13 = staticinvoke <io.netty.util.internal.PlatformDependent: boolean hasUnsafe()>();
if v13 == 0 goto label5;
v14 = virtualinvoke v0.<java.nio.ByteBuffer: boolean isReadOnly()>();
if v14 == 0 goto label4;
v15 = virtualinvoke v0.<java.nio.ByteBuffer: boolean isDirect()>();
if v15 == 0 goto label3;
v16 = new io.netty.buffer.ReadOnlyUnsafeDirectByteBuf;
v17 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBufAllocator ALLOC>;
specialinvoke v16.<io.netty.buffer.ReadOnlyUnsafeDirectByteBuf: void <init>(io.netty.buffer.ByteBufAllocator,java.nio.ByteBuffer)>(v17, v0);
return v16;
label3:
v18 = new io.netty.buffer.ReadOnlyByteBufferBuf;
v19 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBufAllocator ALLOC>;
specialinvoke v18.<io.netty.buffer.ReadOnlyByteBufferBuf: void <init>(io.netty.buffer.ByteBufAllocator,java.nio.ByteBuffer)>(v19, v0);
return v18;
label4:
v20 = new io.netty.buffer.UnpooledUnsafeDirectByteBuf;
v21 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBufAllocator ALLOC>;
v22 = virtualinvoke v0.<java.nio.ByteBuffer: int remaining()>();
specialinvoke v20.<io.netty.buffer.UnpooledUnsafeDirectByteBuf: void <init>(io.netty.buffer.ByteBufAllocator,java.nio.ByteBuffer,int)>(v21, v0, v22);
return v20;
label5:
v23 = virtualinvoke v0.<java.nio.ByteBuffer: boolean isReadOnly()>();
if v23 == 0 goto label6;
v24 = new io.netty.buffer.ReadOnlyByteBufferBuf;
v25 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBufAllocator ALLOC>;
specialinvoke v24.<io.netty.buffer.ReadOnlyByteBufferBuf: void <init>(io.netty.buffer.ByteBufAllocator,java.nio.ByteBuffer)>(v25, v0);
return v24;
label6:
v26 = new io.netty.buffer.UnpooledDirectByteBuf;
v27 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBufAllocator ALLOC>;
v28 = virtualinvoke v0.<java.nio.ByteBuffer: int remaining()>();
specialinvoke v26.<io.netty.buffer.UnpooledDirectByteBuf: void <init>(io.netty.buffer.ByteBufAllocator,java.nio.ByteBuffer,int)>(v27, v0, v28);
return v26;
}
public static io.netty.buffer.ByteBuf wrappedBuffer(long, int, boolean)
{
io.netty.buffer.ByteBufAllocator v4;
int v1;
long v0;
io.netty.buffer.WrappedUnpooledUnsafeDirectByteBuf v3;
boolean v2;
v0 := @parameter0: long;
v1 := @parameter1: int;
v2 := @parameter2: boolean;
v3 = new io.netty.buffer.WrappedUnpooledUnsafeDirectByteBuf;
v4 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBufAllocator ALLOC>;
specialinvoke v3.<io.netty.buffer.WrappedUnpooledUnsafeDirectByteBuf: void <init>(io.netty.buffer.ByteBufAllocator,long,int,boolean)>(v4, v0, v1, v2);
return v3;
}
public static io.netty.buffer.ByteBuf wrappedBuffer(io.netty.buffer.ByteBuf)
{
io.netty.buffer.ByteBuf v0, v2, v3;
boolean v1;
v0 := @parameter0: io.netty.buffer.ByteBuf;
v1 = virtualinvoke v0.<io.netty.buffer.ByteBuf: boolean isReadable()>();
if v1 == 0 goto label1;
v2 = virtualinvoke v0.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf slice()>();
return v2;
label1:
virtualinvoke v0.<io.netty.buffer.ByteBuf: boolean release()>();
v3 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v3;
}
public static transient io.netty.buffer.ByteBuf wrappedBuffer(byte[][])
{
int v1;
byte[][] v0;
io.netty.buffer.ByteBuf v2;
v0 := @parameter0: byte[][];
v1 = lengthof v0;
v2 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf wrappedBuffer(int,byte[][])>(v1, v0);
return v2;
}
public static transient io.netty.buffer.ByteBuf wrappedBuffer(io.netty.buffer.ByteBuf[])
{
int v1;
io.netty.buffer.ByteBuf[] v0;
io.netty.buffer.ByteBuf v2;
v0 := @parameter0: io.netty.buffer.ByteBuf[];
v1 = lengthof v0;
v2 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf wrappedBuffer(int,io.netty.buffer.ByteBuf[])>(v1, v0);
return v2;
}
public static transient io.netty.buffer.ByteBuf wrappedBuffer(java.nio.ByteBuffer[])
{
int v1;
java.nio.ByteBuffer[] v0;
io.netty.buffer.ByteBuf v2;
v0 := @parameter0: java.nio.ByteBuffer[];
v1 = lengthof v0;
v2 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf wrappedBuffer(int,java.nio.ByteBuffer[])>(v1, v0);
return v2;
}
static io.netty.buffer.ByteBuf wrappedBuffer(int, io.netty.buffer.CompositeByteBuf$ByteWrapper, java.lang.Object[])
{
java.lang.Object[] v2;
io.netty.buffer.ByteBufAllocator v14;
io.netty.buffer.ByteBuf v11, v15, v7;
int v0, v3, v8, v9;
boolean v12, v5;
io.netty.buffer.CompositeByteBuf v13;
io.netty.buffer.CompositeByteBuf$ByteWrapper v1;
java.lang.Object v10, v4, v6;
v0 := @parameter0: int;
v1 := @parameter1: io.netty.buffer.CompositeByteBuf$ByteWrapper;
v2 := @parameter2: java.lang.Object[];
v3 = lengthof v2;
lookupswitch(v3)
{
case 0: goto label6;
case 1: goto label1;
default: goto label2;
};
label1:
v4 = v2[0];
v5 = interfaceinvoke v1.<io.netty.buffer.CompositeByteBuf$ByteWrapper: boolean isEmpty(java.lang.Object)>(v4);
if v5 != 0 goto label6;
v6 = v2[0];
v7 = interfaceinvoke v1.<io.netty.buffer.CompositeByteBuf$ByteWrapper: io.netty.buffer.ByteBuf wrap(java.lang.Object)>(v6);
return v7;
label2:
v8 = 0;
v9 = lengthof v2;
label3:
if v8 >= v9 goto label6;
v10 = v2[v8];
if v10 != null goto label4;
v11 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v11;
label4:
v12 = interfaceinvoke v1.<io.netty.buffer.CompositeByteBuf$ByteWrapper: boolean isEmpty(java.lang.Object)>(v10);
if v12 != 0 goto label5;
v13 = new io.netty.buffer.CompositeByteBuf;
v14 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBufAllocator ALLOC>;
specialinvoke v13.<io.netty.buffer.CompositeByteBuf: void <init>(io.netty.buffer.ByteBufAllocator,boolean,int,io.netty.buffer.CompositeByteBuf$ByteWrapper,java.lang.Object[],int)>(v14, 0, v0, v1, v2, v8);
return v13;
label5:
v8 = v8 + 1;
goto label3;
label6:
v15 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v15;
}
public static transient io.netty.buffer.ByteBuf wrappedBuffer(int, byte[][])
{
byte[][] v1;
io.netty.buffer.ByteBuf v3;
io.netty.buffer.CompositeByteBuf$ByteWrapper v2;
int v0;
v0 := @parameter0: int;
v1 := @parameter1: byte[][];
v2 = <io.netty.buffer.CompositeByteBuf: io.netty.buffer.CompositeByteBuf$ByteWrapper BYTE_ARRAY_WRAPPER>;
v3 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf wrappedBuffer(int,io.netty.buffer.CompositeByteBuf$ByteWrapper,java.lang.Object[])>(v0, v2, v1);
return v3;
}
public static transient io.netty.buffer.ByteBuf wrappedBuffer(int, io.netty.buffer.ByteBuf[])
{
io.netty.buffer.ByteBuf[] v1;
io.netty.buffer.ByteBufAllocator v13;
io.netty.buffer.CompositeByteBuf v12;
java.nio.ByteOrder v5;
io.netty.buffer.ByteBuf v10, v14, v3, v6, v7;
int v0, v2, v8, v9;
boolean v11, v4;
v0 := @parameter0: int;
v1 := @parameter1: io.netty.buffer.ByteBuf[];
v2 = lengthof v1;
lookupswitch(v2)
{
case 0: goto label6;
case 1: goto label1;
default: goto label3;
};
label1:
v3 = v1[0];
v4 = virtualinvoke v3.<io.netty.buffer.ByteBuf: boolean isReadable()>();
if v4 == 0 goto label2;
v5 = <io.netty.buffer.Unpooled: java.nio.ByteOrder BIG_ENDIAN>;
v6 = virtualinvoke v3.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf order(java.nio.ByteOrder)>(v5);
v7 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf wrappedBuffer(io.netty.buffer.ByteBuf)>(v6);
return v7;
label2:
virtualinvoke v3.<io.netty.buffer.ByteBuf: boolean release()>();
goto label6;
label3:
v8 = 0;
label4:
v9 = lengthof v1;
if v8 >= v9 goto label6;
v10 = v1[v8];
v11 = virtualinvoke v10.<io.netty.buffer.ByteBuf: boolean isReadable()>();
if v11 == 0 goto label5;
v12 = new io.netty.buffer.CompositeByteBuf;
v13 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBufAllocator ALLOC>;
specialinvoke v12.<io.netty.buffer.CompositeByteBuf: void <init>(io.netty.buffer.ByteBufAllocator,boolean,int,io.netty.buffer.ByteBuf[],int)>(v13, 0, v0, v1, v8);
return v12;
label5:
virtualinvoke v10.<io.netty.buffer.ByteBuf: boolean release()>();
v8 = v8 + 1;
goto label4;
label6:
v14 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v14;
}
public static transient io.netty.buffer.ByteBuf wrappedBuffer(int, java.nio.ByteBuffer[])
{
java.nio.ByteBuffer[] v1;
io.netty.buffer.ByteBuf v3;
io.netty.buffer.CompositeByteBuf$ByteWrapper v2;
int v0;
v0 := @parameter0: int;
v1 := @parameter1: java.nio.ByteBuffer[];
v2 = <io.netty.buffer.CompositeByteBuf: io.netty.buffer.CompositeByteBuf$ByteWrapper BYTE_BUFFER_WRAPPER>;
v3 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf wrappedBuffer(int,io.netty.buffer.CompositeByteBuf$ByteWrapper,java.lang.Object[])>(v0, v2, v1);
return v3;
}
public static io.netty.buffer.CompositeByteBuf compositeBuffer()
{
io.netty.buffer.CompositeByteBuf v0;
v0 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.CompositeByteBuf compositeBuffer(int)>(16);
return v0;
}
public static io.netty.buffer.CompositeByteBuf compositeBuffer(int)
{
int v0;
io.netty.buffer.CompositeByteBuf v1;
io.netty.buffer.ByteBufAllocator v2;
v0 := @parameter0: int;
v1 = new io.netty.buffer.CompositeByteBuf;
v2 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBufAllocator ALLOC>;
specialinvoke v1.<io.netty.buffer.CompositeByteBuf: void <init>(io.netty.buffer.ByteBufAllocator,boolean,int)>(v2, 0, v0);
return v1;
}
public static io.netty.buffer.ByteBuf copiedBuffer(byte[])
{
byte[] v0;
io.netty.buffer.ByteBuf v2, v4;
int v1;
java.lang.Object v3;
v0 := @parameter0: byte[];
v1 = lengthof v0;
if v1 != 0 goto label1;
v2 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v2;
label1:
v3 = virtualinvoke v0.<java.lang.Object: java.lang.Object clone()>();
v4 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf wrappedBuffer(byte[])>(v3);
return v4;
}
public static io.netty.buffer.ByteBuf copiedBuffer(byte[], int, int)
{
byte[] v0, v4;
io.netty.buffer.ByteBuf v3, v5;
int v1, v2;
v0 := @parameter0: byte[];
v1 := @parameter1: int;
v2 := @parameter2: int;
if v2 != 0 goto label1;
v3 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v3;
label1:
v4 = staticinvoke <io.netty.util.internal.PlatformDependent: byte[] allocateUninitializedArray(int)>(v2);
staticinvoke <java.lang.System: void arraycopy(java.lang.Object,int,java.lang.Object,int,int)>(v0, v1, v4, 0, v2);
v5 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf wrappedBuffer(byte[])>(v4);
return v5;
}
public static io.netty.buffer.ByteBuf copiedBuffer(java.nio.ByteBuffer)
{
byte[] v3;
java.nio.ByteBuffer v0, v4;
java.nio.ByteOrder v6;
io.netty.buffer.ByteBuf v2, v5, v7;
int v1;
v0 := @parameter0: java.nio.ByteBuffer;
v1 = virtualinvoke v0.<java.nio.ByteBuffer: int remaining()>();
if v1 != 0 goto label1;
v2 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v2;
label1:
v3 = staticinvoke <io.netty.util.internal.PlatformDependent: byte[] allocateUninitializedArray(int)>(v1);
v4 = virtualinvoke v0.<java.nio.ByteBuffer: java.nio.ByteBuffer duplicate()>();
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer get(byte[])>(v3);
v5 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf wrappedBuffer(byte[])>(v3);
v6 = virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteOrder order()>();
v7 = virtualinvoke v5.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf order(java.nio.ByteOrder)>(v6);
return v7;
}
public static io.netty.buffer.ByteBuf copiedBuffer(io.netty.buffer.ByteBuf)
{
io.netty.buffer.ByteBuf v0, v2, v4;
int v1, v3;
v0 := @parameter0: io.netty.buffer.ByteBuf;
v1 = virtualinvoke v0.<io.netty.buffer.ByteBuf: int readableBytes()>();
if v1 <= 0 goto label1;
v2 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf buffer(int)>(v1);
v3 = virtualinvoke v0.<io.netty.buffer.ByteBuf: int readerIndex()>();
virtualinvoke v2.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf writeBytes(io.netty.buffer.ByteBuf,int,int)>(v0, v3, v1);
return v2;
label1:
v4 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v4;
}
public static transient io.netty.buffer.ByteBuf copiedBuffer(byte[][])
{
byte[] v11, v17, v21, v3, v6;
io.netty.buffer.ByteBuf v16, v2, v24, v5, v7;
int v1, v10, v12, v13, v15, v18, v19, v20, v22, v23, v4, v8, v9;
java.lang.IllegalArgumentException v14;
byte[][] v0;
v0 := @parameter0: byte[][];
v1 = lengthof v0;
lookupswitch(v1)
{
case 0: goto label01;
case 1: goto label02;
default: goto label04;
};
label01:
v2 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v2;
label02:
v3 = v0[0];
v4 = lengthof v3;
if v4 != 0 goto label03;
v5 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v5;
label03:
v6 = v0[0];
v7 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf copiedBuffer(byte[])>(v6);
return v7;
label04:
v8 = 0;
v9 = lengthof v0;
v10 = 0;
label05:
if v10 >= v9 goto label07;
v11 = v0[v10];
v12 = 2147483647 - v8;
v13 = lengthof v11;
if v12 >= v13 goto label06;
v14 = new java.lang.IllegalArgumentException;
specialinvoke v14.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>("The total length of the specified arrays is too big.");
throw v14;
label06:
v15 = lengthof v11;
v8 = v8 + v15;
v10 = v10 + 1;
goto label05;
label07:
if v8 != 0 goto label08;
v16 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v16;
label08:
v17 = staticinvoke <io.netty.util.internal.PlatformDependent: byte[] allocateUninitializedArray(int)>(v8);
v18 = 0;
v19 = 0;
label09:
v20 = lengthof v0;
if v18 >= v20 goto label10;
v21 = v0[v18];
v22 = lengthof v21;
staticinvoke <java.lang.System: void arraycopy(java.lang.Object,int,java.lang.Object,int,int)>(v21, 0, v17, v19, v22);
v23 = lengthof v21;
v19 = v19 + v23;
v18 = v18 + 1;
goto label09;
label10:
v24 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf wrappedBuffer(byte[])>(v17);
return v24;
}
public static transient io.netty.buffer.ByteBuf copiedBuffer(io.netty.buffer.ByteBuf[])
{
byte[] v17;
io.netty.buffer.ByteBuf v16, v2, v21, v24, v25, v3, v4, v9;
int v1, v10, v11, v18, v19, v20, v22, v23, v6, v7, v8;
boolean v14;
io.netty.buffer.ByteBuf[] v0;
java.lang.IllegalArgumentException v12, v15;
java.nio.ByteOrder v13, v5;
v0 := @parameter0: io.netty.buffer.ByteBuf[];
v1 = lengthof v0;
lookupswitch(v1)
{
case 0: goto label01;
case 1: goto label02;
default: goto label03;
};
label01:
v2 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v2;
label02:
v3 = v0[0];
v4 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf copiedBuffer(io.netty.buffer.ByteBuf)>(v3);
return v4;
label03:
v5 = null;
v6 = 0;
v7 = lengthof v0;
v8 = 0;
label04:
if v8 >= v7 goto label08;
v9 = v0[v8];
v10 = virtualinvoke v9.<io.netty.buffer.ByteBuf: int readableBytes()>();
if v10 <= 0 goto label07;
v11 = 2147483647 - v6;
if v11 >= v10 goto label05;
v12 = new java.lang.IllegalArgumentException;
specialinvoke v12.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>("The total length of the specified buffers is too big.");
throw v12;
label05:
v6 = v6 + v10;
if v5 == null goto label06;
v13 = virtualinvoke v9.<io.netty.buffer.ByteBuf: java.nio.ByteOrder order()>();
v14 = virtualinvoke v5.<java.lang.Object: boolean equals(java.lang.Object)>(v13);
if v14 != 0 goto label07;
v15 = new java.lang.IllegalArgumentException;
specialinvoke v15.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>("inconsistent byte order");
throw v15;
label06:
v5 = virtualinvoke v9.<io.netty.buffer.ByteBuf: java.nio.ByteOrder order()>();
label07:
v8 = v8 + 1;
goto label04;
label08:
if v6 != 0 goto label09;
v16 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v16;
label09:
v17 = staticinvoke <io.netty.util.internal.PlatformDependent: byte[] allocateUninitializedArray(int)>(v6);
v18 = 0;
v19 = 0;
label10:
v20 = lengthof v0;
if v18 >= v20 goto label11;
v21 = v0[v18];
v22 = virtualinvoke v21.<io.netty.buffer.ByteBuf: int readableBytes()>();
v23 = virtualinvoke v21.<io.netty.buffer.ByteBuf: int readerIndex()>();
virtualinvoke v21.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf getBytes(int,byte[],int,int)>(v23, v17, v19, v22);
v19 = v19 + v22;
v18 = v18 + 1;
goto label10;
label11:
v24 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf wrappedBuffer(byte[])>(v17);
v25 = virtualinvoke v24.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf order(java.nio.ByteOrder)>(v5);
return v25;
}
public static transient io.netty.buffer.ByteBuf copiedBuffer(java.nio.ByteBuffer[])
{
byte[] v17;
java.nio.ByteBuffer v21, v22, v3, v9;
io.netty.buffer.ByteBuf v16, v2, v24, v25, v4;
int v1, v10, v11, v18, v19, v20, v23, v6, v7, v8;
boolean v14;
java.nio.ByteBuffer[] v0;
java.lang.IllegalArgumentException v12, v15;
java.nio.ByteOrder v13, v5;
v0 := @parameter0: java.nio.ByteBuffer[];
v1 = lengthof v0;
lookupswitch(v1)
{
case 0: goto label01;
case 1: goto label02;
default: goto label03;
};
label01:
v2 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v2;
label02:
v3 = v0[0];
v4 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf copiedBuffer(java.nio.ByteBuffer)>(v3);
return v4;
label03:
v5 = null;
v6 = 0;
v7 = lengthof v0;
v8 = 0;
label04:
if v8 >= v7 goto label08;
v9 = v0[v8];
v10 = virtualinvoke v9.<java.nio.ByteBuffer: int remaining()>();
if v10 <= 0 goto label07;
v11 = 2147483647 - v6;
if v11 >= v10 goto label05;
v12 = new java.lang.IllegalArgumentException;
specialinvoke v12.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>("The total length of the specified buffers is too big.");
throw v12;
label05:
v6 = v6 + v10;
if v5 == null goto label06;
v13 = virtualinvoke v9.<java.nio.ByteBuffer: java.nio.ByteOrder order()>();
v14 = virtualinvoke v5.<java.lang.Object: boolean equals(java.lang.Object)>(v13);
if v14 != 0 goto label07;
v15 = new java.lang.IllegalArgumentException;
specialinvoke v15.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>("inconsistent byte order");
throw v15;
label06:
v5 = virtualinvoke v9.<java.nio.ByteBuffer: java.nio.ByteOrder order()>();
label07:
v8 = v8 + 1;
goto label04;
label08:
if v6 != 0 goto label09;
v16 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v16;
label09:
v17 = staticinvoke <io.netty.util.internal.PlatformDependent: byte[] allocateUninitializedArray(int)>(v6);
v18 = 0;
v19 = 0;
label10:
v20 = lengthof v0;
if v18 >= v20 goto label11;
v21 = v0[v18];
v22 = virtualinvoke v21.<java.nio.ByteBuffer: java.nio.ByteBuffer duplicate()>();
v23 = virtualinvoke v22.<java.nio.ByteBuffer: int remaining()>();
virtualinvoke v22.<java.nio.ByteBuffer: java.nio.ByteBuffer get(byte[],int,int)>(v17, v19, v23);
v19 = v19 + v23;
v18 = v18 + 1;
goto label10;
label11:
v24 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf wrappedBuffer(byte[])>(v17);
v25 = virtualinvoke v24.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf order(java.nio.ByteOrder)>(v5);
return v25;
}
public static io.netty.buffer.ByteBuf copiedBuffer(java.lang.CharSequence, java.nio.charset.Charset)
{
java.lang.CharSequence v0;
java.nio.CharBuffer v10;
io.netty.buffer.ByteBuf v11, v4, v7, v9;
java.nio.charset.Charset v1, v2, v5;
boolean v3, v6, v8;
v0 := @parameter0: java.lang.CharSequence;
v1 := @parameter1: java.nio.charset.Charset;
staticinvoke <io.netty.util.internal.ObjectUtil: java.lang.Object checkNotNull(java.lang.Object,java.lang.String)>(v0, "string");
v2 = <io.netty.util.CharsetUtil: java.nio.charset.Charset UTF_8>;
v3 = virtualinvoke v2.<java.nio.charset.Charset: boolean equals(java.lang.Object)>(v1);
if v3 == 0 goto label1;
v4 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf copiedBufferUtf8(java.lang.CharSequence)>(v0);
return v4;
label1:
v5 = <io.netty.util.CharsetUtil: java.nio.charset.Charset US_ASCII>;
v6 = virtualinvoke v5.<java.nio.charset.Charset: boolean equals(java.lang.Object)>(v1);
if v6 == 0 goto label2;
v7 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf copiedBufferAscii(java.lang.CharSequence)>(v0);
return v7;
label2:
v8 = v0 instanceof java.nio.CharBuffer;
if v8 == 0 goto label3;
v9 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf copiedBuffer(java.nio.CharBuffer,java.nio.charset.Charset)>(v0, v1);
return v9;
label3:
v10 = staticinvoke <java.nio.CharBuffer: java.nio.CharBuffer wrap(java.lang.CharSequence)>(v0);
v11 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf copiedBuffer(java.nio.CharBuffer,java.nio.charset.Charset)>(v10, v1);
return v11;
}
private static io.netty.buffer.ByteBuf copiedBufferUtf8(java.lang.CharSequence)
{
java.lang.Throwable v4;
io.netty.buffer.ByteBuf v3;
java.lang.CharSequence v0;
io.netty.buffer.ByteBufAllocator v1;
int v2;
v0 := @parameter0: java.lang.CharSequence;
v1 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBufAllocator ALLOC>;
v2 = staticinvoke <io.netty.buffer.ByteBufUtil: int utf8Bytes(java.lang.CharSequence)>(v0);
v3 = interfaceinvoke v1.<io.netty.buffer.ByteBufAllocator: io.netty.buffer.ByteBuf heapBuffer(int)>(v2);
label1:
staticinvoke <io.netty.buffer.ByteBufUtil: int writeUtf8(io.netty.buffer.ByteBuf,java.lang.CharSequence)>(v3, v0);
label2:
return v3;
label3:
v4 := @caughtexception;
virtualinvoke v3.<io.netty.buffer.ByteBuf: boolean release()>();
throw v4;
catch java.lang.Throwable from label1 to label2 with label3;
}
private static io.netty.buffer.ByteBuf copiedBufferAscii(java.lang.CharSequence)
{
java.lang.Throwable v4;
io.netty.buffer.ByteBuf v3;
java.lang.CharSequence v0;
io.netty.buffer.ByteBufAllocator v1;
int v2;
v0 := @parameter0: java.lang.CharSequence;
v1 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBufAllocator ALLOC>;
v2 = interfaceinvoke v0.<java.lang.CharSequence: int length()>();
v3 = interfaceinvoke v1.<io.netty.buffer.ByteBufAllocator: io.netty.buffer.ByteBuf heapBuffer(int)>(v2);
label1:
staticinvoke <io.netty.buffer.ByteBufUtil: int writeAscii(io.netty.buffer.ByteBuf,java.lang.CharSequence)>(v3, v0);
label2:
return v3;
label3:
v4 := @caughtexception;
virtualinvoke v3.<io.netty.buffer.ByteBuf: boolean release()>();
throw v4;
catch java.lang.Throwable from label1 to label2 with label3;
}
public static io.netty.buffer.ByteBuf copiedBuffer(java.lang.CharSequence, int, int, java.nio.charset.Charset)
{
io.netty.buffer.ByteBuf v12, v14, v17, v4;
java.nio.charset.Charset v3;
int v1, v10, v11, v15, v2, v8, v9;
boolean v5, v6;
java.lang.CharSequence v0;
java.nio.CharBuffer v13, v16;
char[] v7;
v0 := @parameter0: java.lang.CharSequence;
v1 := @parameter1: int;
v2 := @parameter2: int;
v3 := @parameter3: java.nio.charset.Charset;
staticinvoke <io.netty.util.internal.ObjectUtil: java.lang.Object checkNotNull(java.lang.Object,java.lang.String)>(v0, "string");
if v2 != 0 goto label1;
v4 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v4;
label1:
v5 = v0 instanceof java.nio.CharBuffer;
if v5 == 0 goto label3;
v6 = virtualinvoke v0.<java.nio.CharBuffer: boolean hasArray()>();
if v6 == 0 goto label2;
v7 = virtualinvoke v0.<java.nio.CharBuffer: char[] array()>();
v8 = virtualinvoke v0.<java.nio.CharBuffer: int arrayOffset()>();
v9 = virtualinvoke v0.<java.nio.CharBuffer: int position()>();
v10 = v8 + v9;
v11 = v10 + v1;
v12 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf copiedBuffer(char[],int,int,java.nio.charset.Charset)>(v7, v11, v2, v3);
return v12;
label2:
v13 = virtualinvoke v0.<java.nio.CharBuffer: java.nio.CharBuffer slice()>();
virtualinvoke v13.<java.nio.CharBuffer: java.nio.CharBuffer limit(int)>(v2);
virtualinvoke v13.<java.nio.CharBuffer: java.nio.CharBuffer position(int)>(v1);
v14 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf copiedBuffer(java.nio.CharBuffer,java.nio.charset.Charset)>(v13, v3);
return v14;
label3:
v15 = v1 + v2;
v16 = staticinvoke <java.nio.CharBuffer: java.nio.CharBuffer wrap(java.lang.CharSequence,int,int)>(v0, v1, v15);
v17 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf copiedBuffer(java.nio.CharBuffer,java.nio.charset.Charset)>(v16, v3);
return v17;
}
public static io.netty.buffer.ByteBuf copiedBuffer(char[], java.nio.charset.Charset)
{
io.netty.buffer.ByteBuf v3;
java.nio.charset.Charset v1;
int v2;
char[] v0;
v0 := @parameter0: char[];
v1 := @parameter1: java.nio.charset.Charset;
staticinvoke <io.netty.util.internal.ObjectUtil: java.lang.Object checkNotNull(java.lang.Object,java.lang.String)>(v0, "array");
v2 = lengthof v0;
v3 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf copiedBuffer(char[],int,int,java.nio.charset.Charset)>(v0, 0, v2, v1);
return v3;
}
public static io.netty.buffer.ByteBuf copiedBuffer(char[], int, int, java.nio.charset.Charset)
{
io.netty.buffer.ByteBuf v4, v6;
java.nio.charset.Charset v3;
java.nio.CharBuffer v5;
int v1, v2;
char[] v0;
v0 := @parameter0: char[];
v1 := @parameter1: int;
v2 := @parameter2: int;
v3 := @parameter3: java.nio.charset.Charset;
staticinvoke <io.netty.util.internal.ObjectUtil: java.lang.Object checkNotNull(java.lang.Object,java.lang.String)>(v0, "array");
if v2 != 0 goto label1;
v4 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v4;
label1:
v5 = staticinvoke <java.nio.CharBuffer: java.nio.CharBuffer wrap(char[],int,int)>(v0, v1, v2);
v6 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf copiedBuffer(java.nio.CharBuffer,java.nio.charset.Charset)>(v5, v3);
return v6;
}
private static io.netty.buffer.ByteBuf copiedBuffer(java.nio.CharBuffer, java.nio.charset.Charset)
{
io.netty.buffer.ByteBuf v3;
java.nio.charset.Charset v1;
java.nio.CharBuffer v0;
io.netty.buffer.ByteBufAllocator v2;
v0 := @parameter0: java.nio.CharBuffer;
v1 := @parameter1: java.nio.charset.Charset;
v2 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBufAllocator ALLOC>;
v3 = staticinvoke <io.netty.buffer.ByteBufUtil: io.netty.buffer.ByteBuf encodeString0(io.netty.buffer.ByteBufAllocator,boolean,java.nio.CharBuffer,java.nio.charset.Charset,int)>(v2, 1, v0, v1, 0);
return v3;
}
public static io.netty.buffer.ByteBuf unmodifiableBuffer(io.netty.buffer.ByteBuf)
{
io.netty.buffer.ReadOnlyByteBuf v3, v4;
java.nio.ByteOrder v1, v2, v5, v7;
io.netty.buffer.ByteBuf v0, v6, v8;
v0 := @parameter0: io.netty.buffer.ByteBuf;
v1 = virtualinvoke v0.<io.netty.buffer.ByteBuf: java.nio.ByteOrder order()>();
v2 = <io.netty.buffer.Unpooled: java.nio.ByteOrder BIG_ENDIAN>;
if v1 != v2 goto label1;
v3 = new io.netty.buffer.ReadOnlyByteBuf;
specialinvoke v3.<io.netty.buffer.ReadOnlyByteBuf: void <init>(io.netty.buffer.ByteBuf)>(v0);
return v3;
label1:
v4 = new io.netty.buffer.ReadOnlyByteBuf;
v5 = <io.netty.buffer.Unpooled: java.nio.ByteOrder BIG_ENDIAN>;
v6 = virtualinvoke v0.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf order(java.nio.ByteOrder)>(v5);
specialinvoke v4.<io.netty.buffer.ReadOnlyByteBuf: void <init>(io.netty.buffer.ByteBuf)>(v6);
v7 = <io.netty.buffer.Unpooled: java.nio.ByteOrder LITTLE_ENDIAN>;
v8 = virtualinvoke v4.<io.netty.buffer.ReadOnlyByteBuf: io.netty.buffer.ByteBuf order(java.nio.ByteOrder)>(v7);
return v8;
}
public static io.netty.buffer.ByteBuf copyInt(int)
{
int v0;
io.netty.buffer.ByteBuf v1;
v0 := @parameter0: int;
v1 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf buffer(int)>(4);
virtualinvoke v1.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf writeInt(int)>(v0);
return v1;
}
public static transient io.netty.buffer.ByteBuf copyInt(int[])
{
io.netty.buffer.ByteBuf v2, v5;
int[] v0;
int v1, v3, v4, v6, v7, v8;
v0 := @parameter0: int[];
if v0 == null goto label1;
v1 = lengthof v0;
if v1 != 0 goto label2;
label1:
v2 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v2;
label2:
v3 = lengthof v0;
v4 = v3 * 4;
v5 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf buffer(int)>(v4);
v6 = lengthof v0;
v7 = 0;
label3:
if v7 >= v6 goto label4;
v8 = v0[v7];
virtualinvoke v5.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf writeInt(int)>(v8);
v7 = v7 + 1;
goto label3;
label4:
return v5;
}
public static io.netty.buffer.ByteBuf copyShort(int)
{
int v0;
io.netty.buffer.ByteBuf v1;
v0 := @parameter0: int;
v1 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf buffer(int)>(2);
virtualinvoke v1.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf writeShort(int)>(v0);
return v1;
}
public static transient io.netty.buffer.ByteBuf copyShort(short[])
{
short v8;
io.netty.buffer.ByteBuf v2, v5;
int v1, v3, v4, v6, v7;
short[] v0;
v0 := @parameter0: short[];
if v0 == null goto label1;
v1 = lengthof v0;
if v1 != 0 goto label2;
label1:
v2 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v2;
label2:
v3 = lengthof v0;
v4 = v3 * 2;
v5 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf buffer(int)>(v4);
v6 = lengthof v0;
v7 = 0;
label3:
if v7 >= v6 goto label4;
v8 = v0[v7];
virtualinvoke v5.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf writeShort(int)>(v8);
v7 = v7 + 1;
goto label3;
label4:
return v5;
}
public static transient io.netty.buffer.ByteBuf copyShort(int[])
{
io.netty.buffer.ByteBuf v2, v5;
int[] v0;
int v1, v3, v4, v6, v7, v8;
v0 := @parameter0: int[];
if v0 == null goto label1;
v1 = lengthof v0;
if v1 != 0 goto label2;
label1:
v2 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v2;
label2:
v3 = lengthof v0;
v4 = v3 * 2;
v5 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf buffer(int)>(v4);
v6 = lengthof v0;
v7 = 0;
label3:
if v7 >= v6 goto label4;
v8 = v0[v7];
virtualinvoke v5.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf writeShort(int)>(v8);
v7 = v7 + 1;
goto label3;
label4:
return v5;
}
public static io.netty.buffer.ByteBuf copyMedium(int)
{
int v0;
io.netty.buffer.ByteBuf v1;
v0 := @parameter0: int;
v1 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf buffer(int)>(3);
virtualinvoke v1.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf writeMedium(int)>(v0);
return v1;
}
public static transient io.netty.buffer.ByteBuf copyMedium(int[])
{
io.netty.buffer.ByteBuf v2, v5;
int[] v0;
int v1, v3, v4, v6, v7, v8;
v0 := @parameter0: int[];
if v0 == null goto label1;
v1 = lengthof v0;
if v1 != 0 goto label2;
label1:
v2 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v2;
label2:
v3 = lengthof v0;
v4 = v3 * 3;
v5 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf buffer(int)>(v4);
v6 = lengthof v0;
v7 = 0;
label3:
if v7 >= v6 goto label4;
v8 = v0[v7];
virtualinvoke v5.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf writeMedium(int)>(v8);
v7 = v7 + 1;
goto label3;
label4:
return v5;
}
public static io.netty.buffer.ByteBuf copyLong(long)
{
long v0;
io.netty.buffer.ByteBuf v1;
v0 := @parameter0: long;
v1 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf buffer(int)>(8);
virtualinvoke v1.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf writeLong(long)>(v0);
return v1;
}
public static transient io.netty.buffer.ByteBuf copyLong(long[])
{
long v8;
long[] v0;
io.netty.buffer.ByteBuf v2, v5;
int v1, v3, v4, v6, v7;
v0 := @parameter0: long[];
if v0 == null goto label1;
v1 = lengthof v0;
if v1 != 0 goto label2;
label1:
v2 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v2;
label2:
v3 = lengthof v0;
v4 = v3 * 8;
v5 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf buffer(int)>(v4);
v6 = lengthof v0;
v7 = 0;
label3:
if v7 >= v6 goto label4;
v8 = v0[v7];
virtualinvoke v5.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf writeLong(long)>(v8);
v7 = v7 + 1;
goto label3;
label4:
return v5;
}
public static io.netty.buffer.ByteBuf copyBoolean(boolean)
{
io.netty.buffer.ByteBuf v1;
boolean v0;
v0 := @parameter0: boolean;
v1 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf buffer(int)>(1);
virtualinvoke v1.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf writeBoolean(boolean)>(v0);
return v1;
}
public static transient io.netty.buffer.ByteBuf copyBoolean(boolean[])
{
boolean[] v0;
io.netty.buffer.ByteBuf v2, v4;
int v1, v3, v5, v6;
boolean v7;
v0 := @parameter0: boolean[];
if v0 == null goto label1;
v1 = lengthof v0;
if v1 != 0 goto label2;
label1:
v2 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v2;
label2:
v3 = lengthof v0;
v4 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf buffer(int)>(v3);
v5 = lengthof v0;
v6 = 0;
label3:
if v6 >= v5 goto label4;
v7 = v0[v6];
virtualinvoke v4.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf writeBoolean(boolean)>(v7);
v6 = v6 + 1;
goto label3;
label4:
return v4;
}
public static io.netty.buffer.ByteBuf copyFloat(float)
{
float v0;
io.netty.buffer.ByteBuf v1;
v0 := @parameter0: float;
v1 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf buffer(int)>(4);
virtualinvoke v1.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf writeFloat(float)>(v0);
return v1;
}
public static transient io.netty.buffer.ByteBuf copyFloat(float[])
{
float[] v0;
io.netty.buffer.ByteBuf v2, v5;
int v1, v3, v4, v6, v7;
float v8;
v0 := @parameter0: float[];
if v0 == null goto label1;
v1 = lengthof v0;
if v1 != 0 goto label2;
label1:
v2 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v2;
label2:
v3 = lengthof v0;
v4 = v3 * 4;
v5 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf buffer(int)>(v4);
v6 = lengthof v0;
v7 = 0;
label3:
if v7 >= v6 goto label4;
v8 = v0[v7];
virtualinvoke v5.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf writeFloat(float)>(v8);
v7 = v7 + 1;
goto label3;
label4:
return v5;
}
public static io.netty.buffer.ByteBuf copyDouble(double)
{
io.netty.buffer.ByteBuf v1;
double v0;
v0 := @parameter0: double;
v1 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf buffer(int)>(8);
virtualinvoke v1.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf writeDouble(double)>(v0);
return v1;
}
public static transient io.netty.buffer.ByteBuf copyDouble(double[])
{
double[] v0;
io.netty.buffer.ByteBuf v2, v5;
int v1, v3, v4, v6, v7;
double v8;
v0 := @parameter0: double[];
if v0 == null goto label1;
v1 = lengthof v0;
if v1 != 0 goto label2;
label1:
v2 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v2;
label2:
v3 = lengthof v0;
v4 = v3 * 8;
v5 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf buffer(int)>(v4);
v6 = lengthof v0;
v7 = 0;
label3:
if v7 >= v6 goto label4;
v8 = v0[v7];
virtualinvoke v5.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf writeDouble(double)>(v8);
v7 = v7 + 1;
goto label3;
label4:
return v5;
}
public static io.netty.buffer.ByteBuf unreleasableBuffer(io.netty.buffer.ByteBuf)
{
io.netty.buffer.ByteBuf v0;
io.netty.buffer.UnreleasableByteBuf v1;
v0 := @parameter0: io.netty.buffer.ByteBuf;
v1 = new io.netty.buffer.UnreleasableByteBuf;
specialinvoke v1.<io.netty.buffer.UnreleasableByteBuf: void <init>(io.netty.buffer.ByteBuf)>(v0);
return v1;
}
public static transient io.netty.buffer.ByteBuf unmodifiableBuffer(io.netty.buffer.ByteBuf[])
{
io.netty.buffer.ByteBuf[] v0;
io.netty.buffer.ByteBuf v1;
v0 := @parameter0: io.netty.buffer.ByteBuf[];
v1 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf wrappedUnmodifiableBuffer(boolean,io.netty.buffer.ByteBuf[])>(1, v0);
return v1;
}
public static transient io.netty.buffer.ByteBuf wrappedUnmodifiableBuffer(io.netty.buffer.ByteBuf[])
{
io.netty.buffer.ByteBuf[] v0;
io.netty.buffer.ByteBuf v1;
v0 := @parameter0: io.netty.buffer.ByteBuf[];
v1 = staticinvoke <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf wrappedUnmodifiableBuffer(boolean,io.netty.buffer.ByteBuf[])>(0, v0);
return v1;
}
private static transient io.netty.buffer.ByteBuf wrappedUnmodifiableBuffer(boolean, io.netty.buffer.ByteBuf[])
{
io.netty.buffer.ByteBuf[] v1;
java.lang.Object[] v7;
io.netty.buffer.ByteBufAllocator v9;
io.netty.buffer.FixedCompositeByteBuf v8;
io.netty.buffer.ByteBuf v3, v4, v5;
int v2, v6;
boolean v0;
v0 := @parameter0: boolean;
v1 := @parameter1: io.netty.buffer.ByteBuf[];
v2 = lengthof v1;
lookupswitch(v2)
{
case 0: goto label1;
case 1: goto label2;
default: goto label3;
};
label1:
v3 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
return v3;
label2:
v4 = v1[0];
v5 = virtualinvoke v4.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf asReadOnly()>();
return v5;
label3:
if v0 == 0 goto label4;
v6 = lengthof v1;
v7 = staticinvoke <java.util.Arrays: java.lang.Object[] copyOf(java.lang.Object[],int,java.lang.Class)>(v1, v6, class "[Lio/netty/buffer/ByteBuf;");
label4:
v8 = new io.netty.buffer.FixedCompositeByteBuf;
v9 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBufAllocator ALLOC>;
specialinvoke v8.<io.netty.buffer.FixedCompositeByteBuf: void <init>(io.netty.buffer.ByteBufAllocator,io.netty.buffer.ByteBuf[])>(v9, v7);
return v8;
}
private void <init>()
{
io.netty.buffer.Unpooled v0;
v0 := @this: io.netty.buffer.Unpooled;
specialinvoke v0.<java.lang.Object: void <init>()>();
return;
}
static void <clinit>()
{
io.netty.buffer.UnpooledByteBufAllocator v3;
io.netty.buffer.ByteBufAllocator v6;
java.lang.AssertionError v11;
java.nio.ByteOrder v4, v5;
io.netty.buffer.ByteBuf v7, v9;
java.lang.Class v0;
boolean v1, v10, v2, v8;
v0 = class "Lio/netty/buffer/Unpooled;";
v1 = virtualinvoke v0.<java.lang.Class: boolean desiredAssertionStatus()>();
if v1 != 0 goto label1;
v2 = 1;
goto label2;
label1:
v2 = 0;
label2:
<io.netty.buffer.Unpooled: boolean $assertionsDisabled> = v2;
v3 = <io.netty.buffer.UnpooledByteBufAllocator: io.netty.buffer.UnpooledByteBufAllocator DEFAULT>;
<io.netty.buffer.Unpooled: io.netty.buffer.ByteBufAllocator ALLOC> = v3;
v4 = <java.nio.ByteOrder: java.nio.ByteOrder BIG_ENDIAN>;
<io.netty.buffer.Unpooled: java.nio.ByteOrder BIG_ENDIAN> = v4;
v5 = <java.nio.ByteOrder: java.nio.ByteOrder LITTLE_ENDIAN>;
<io.netty.buffer.Unpooled: java.nio.ByteOrder LITTLE_ENDIAN> = v5;
v6 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBufAllocator ALLOC>;
v7 = interfaceinvoke v6.<io.netty.buffer.ByteBufAllocator: io.netty.buffer.ByteBuf buffer(int,int)>(0, 0);
<io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER> = v7;
v8 = <io.netty.buffer.Unpooled: boolean $assertionsDisabled>;
if v8 != 0 goto label3;
v9 = <io.netty.buffer.Unpooled: io.netty.buffer.ByteBuf EMPTY_BUFFER>;
v10 = v9 instanceof io.netty.buffer.EmptyByteBuf;
if v10 != 0 goto label3;
v11 = new java.lang.AssertionError;
specialinvoke v11.<java.lang.AssertionError: void <init>(java.lang.Object)>("EMPTY_BUFFER must be an EmptyByteBuf.");
throw v11;
label3:
return;
}
}