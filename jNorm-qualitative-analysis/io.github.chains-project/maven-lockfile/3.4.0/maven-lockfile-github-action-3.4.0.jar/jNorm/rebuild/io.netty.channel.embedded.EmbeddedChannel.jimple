public class io.netty.channel.embedded.EmbeddedChannel extends io.netty.channel.AbstractChannel
{
private static final java.net.SocketAddress LOCAL_ADDRESS;
private static final java.net.SocketAddress REMOTE_ADDRESS;
private static final io.netty.channel.ChannelHandler[] EMPTY_HANDLERS;
private static final io.netty.util.internal.logging.InternalLogger logger;
private static final io.netty.channel.ChannelMetadata METADATA_NO_DISCONNECT;
private static final io.netty.channel.ChannelMetadata METADATA_DISCONNECT;
private final io.netty.channel.embedded.EmbeddedEventLoop loop;
private final io.netty.channel.ChannelFutureListener recordExceptionListener;
private final io.netty.channel.ChannelMetadata metadata;
private final io.netty.channel.ChannelConfig config;
private java.util.Queue inboundMessages;
private java.util.Queue outboundMessages;
private java.lang.Throwable lastException;
private io.netty.channel.embedded.EmbeddedChannel$State state;
static final boolean $assertionsDisabled;
public void <init>()
{
io.netty.channel.ChannelHandler[] v1;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = <io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelHandler[] EMPTY_HANDLERS>;
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void <init>(io.netty.channel.ChannelHandler[])>(v1);
return;
}
public void <init>(io.netty.channel.ChannelId)
{
io.netty.channel.ChannelId v1;
io.netty.channel.ChannelHandler[] v2;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: io.netty.channel.ChannelId;
v2 = <io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelHandler[] EMPTY_HANDLERS>;
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void <init>(io.netty.channel.ChannelId,io.netty.channel.ChannelHandler[])>(v1, v2);
return;
}
public transient void <init>(io.netty.channel.ChannelHandler[])
{
io.netty.channel.ChannelId v2;
io.netty.channel.ChannelHandler[] v1;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: io.netty.channel.ChannelHandler[];
v2 = <io.netty.channel.embedded.EmbeddedChannelId: io.netty.channel.ChannelId INSTANCE>;
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void <init>(io.netty.channel.ChannelId,io.netty.channel.ChannelHandler[])>(v2, v1);
return;
}
public transient void <init>(boolean, io.netty.channel.ChannelHandler[])
{
io.netty.channel.embedded.EmbeddedChannel v0;
io.netty.channel.ChannelId v3;
io.netty.channel.ChannelHandler[] v2;
boolean v1;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: boolean;
v2 := @parameter1: io.netty.channel.ChannelHandler[];
v3 = <io.netty.channel.embedded.EmbeddedChannelId: io.netty.channel.ChannelId INSTANCE>;
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void <init>(io.netty.channel.ChannelId,boolean,io.netty.channel.ChannelHandler[])>(v3, v1, v2);
return;
}
public transient void <init>(boolean, boolean, io.netty.channel.ChannelHandler[])
{
io.netty.channel.embedded.EmbeddedChannel v0;
io.netty.channel.ChannelId v4;
io.netty.channel.ChannelHandler[] v3;
boolean v1, v2;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: boolean;
v2 := @parameter1: boolean;
v3 := @parameter2: io.netty.channel.ChannelHandler[];
v4 = <io.netty.channel.embedded.EmbeddedChannelId: io.netty.channel.ChannelId INSTANCE>;
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void <init>(io.netty.channel.ChannelId,boolean,boolean,io.netty.channel.ChannelHandler[])>(v4, v1, v2, v3);
return;
}
public transient void <init>(io.netty.channel.ChannelId, io.netty.channel.ChannelHandler[])
{
io.netty.channel.ChannelId v1;
io.netty.channel.ChannelHandler[] v2;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: io.netty.channel.ChannelId;
v2 := @parameter1: io.netty.channel.ChannelHandler[];
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void <init>(io.netty.channel.ChannelId,boolean,io.netty.channel.ChannelHandler[])>(v1, 0, v2);
return;
}
public transient void <init>(io.netty.channel.ChannelId, boolean, io.netty.channel.ChannelHandler[])
{
io.netty.channel.embedded.EmbeddedChannel v0;
io.netty.channel.ChannelId v1;
io.netty.channel.ChannelHandler[] v3;
boolean v2;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: io.netty.channel.ChannelId;
v2 := @parameter1: boolean;
v3 := @parameter2: io.netty.channel.ChannelHandler[];
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void <init>(io.netty.channel.ChannelId,boolean,boolean,io.netty.channel.ChannelHandler[])>(v1, 1, v2, v3);
return;
}
public transient void <init>(io.netty.channel.ChannelId, boolean, boolean, io.netty.channel.ChannelHandler[])
{
io.netty.channel.embedded.EmbeddedChannel v0;
io.netty.channel.ChannelId v1;
io.netty.channel.ChannelHandler[] v4;
boolean v2, v3;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: io.netty.channel.ChannelId;
v2 := @parameter1: boolean;
v3 := @parameter2: boolean;
v4 := @parameter3: io.netty.channel.ChannelHandler[];
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void <init>(io.netty.channel.Channel,io.netty.channel.ChannelId,boolean,boolean,io.netty.channel.ChannelHandler[])>(null, v1, v2, v3, v4);
return;
}
public transient void <init>(io.netty.channel.Channel, io.netty.channel.ChannelId, boolean, boolean, io.netty.channel.ChannelHandler[])
{
io.netty.channel.DefaultChannelConfig v9;
io.netty.channel.embedded.EmbeddedChannel v0;
io.netty.channel.ChannelId v2;
io.netty.channel.embedded.EmbeddedChannel$1 v7;
io.netty.channel.embedded.EmbeddedEventLoop v6;
io.netty.channel.ChannelHandler[] v5;
io.netty.channel.Channel v1;
io.netty.channel.ChannelMetadata v8;
boolean v3, v4;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: io.netty.channel.Channel;
v2 := @parameter1: io.netty.channel.ChannelId;
v3 := @parameter2: boolean;
v4 := @parameter3: boolean;
v5 := @parameter4: io.netty.channel.ChannelHandler[];
specialinvoke v0.<io.netty.channel.AbstractChannel: void <init>(io.netty.channel.Channel,io.netty.channel.ChannelId)>(v1, v2);
v6 = new io.netty.channel.embedded.EmbeddedEventLoop;
specialinvoke v6.<io.netty.channel.embedded.EmbeddedEventLoop: void <init>()>();
v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.embedded.EmbeddedEventLoop loop> = v6;
v7 = new io.netty.channel.embedded.EmbeddedChannel$1;
specialinvoke v7.<io.netty.channel.embedded.EmbeddedChannel$1: void <init>(io.netty.channel.embedded.EmbeddedChannel)>(v0);
v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelFutureListener recordExceptionListener> = v7;
v8 = staticinvoke <io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelMetadata metadata(boolean)>(v4);
v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelMetadata metadata> = v8;
v9 = new io.netty.channel.DefaultChannelConfig;
specialinvoke v9.<io.netty.channel.DefaultChannelConfig: void <init>(io.netty.channel.Channel)>(v0);
v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelConfig config> = v9;
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void setup(boolean,io.netty.channel.ChannelHandler[])>(v3, v5);
return;
}
public transient void <init>(io.netty.channel.ChannelId, boolean, io.netty.channel.ChannelConfig, io.netty.channel.ChannelHandler[])
{
io.netty.channel.embedded.EmbeddedChannel v0;
io.netty.channel.ChannelId v1;
io.netty.channel.embedded.EmbeddedChannel$1 v6;
io.netty.channel.embedded.EmbeddedEventLoop v5;
io.netty.channel.ChannelHandler[] v4;
io.netty.channel.ChannelConfig v3;
java.lang.Object v8;
io.netty.channel.ChannelMetadata v7;
boolean v2;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: io.netty.channel.ChannelId;
v2 := @parameter1: boolean;
v3 := @parameter2: io.netty.channel.ChannelConfig;
v4 := @parameter3: io.netty.channel.ChannelHandler[];
specialinvoke v0.<io.netty.channel.AbstractChannel: void <init>(io.netty.channel.Channel,io.netty.channel.ChannelId)>(null, v1);
v5 = new io.netty.channel.embedded.EmbeddedEventLoop;
specialinvoke v5.<io.netty.channel.embedded.EmbeddedEventLoop: void <init>()>();
v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.embedded.EmbeddedEventLoop loop> = v5;
v6 = new io.netty.channel.embedded.EmbeddedChannel$1;
specialinvoke v6.<io.netty.channel.embedded.EmbeddedChannel$1: void <init>(io.netty.channel.embedded.EmbeddedChannel)>(v0);
v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelFutureListener recordExceptionListener> = v6;
v7 = staticinvoke <io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelMetadata metadata(boolean)>(v2);
v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelMetadata metadata> = v7;
v8 = staticinvoke <io.netty.util.internal.ObjectUtil: java.lang.Object checkNotNull(java.lang.Object,java.lang.String)>(v3, "config");
v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelConfig config> = v8;
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void setup(boolean,io.netty.channel.ChannelHandler[])>(1, v4);
return;
}
private static io.netty.channel.ChannelMetadata metadata(boolean)
{
io.netty.channel.ChannelMetadata v1;
boolean v0;
v0 := @parameter0: boolean;
if v0 == 0 goto label1;
v1 = <io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelMetadata METADATA_DISCONNECT>;
goto label2;
label1:
v1 = <io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelMetadata METADATA_NO_DISCONNECT>;
label2:
return v1;
}
private transient void setup(boolean, io.netty.channel.ChannelHandler[])
{
io.netty.channel.embedded.EmbeddedChannel v0;
io.netty.channel.embedded.EmbeddedChannel$2 v5;
io.netty.channel.ChannelPipeline v3;
java.lang.AssertionError v10;
io.netty.channel.embedded.EmbeddedEventLoop v6;
io.netty.channel.ChannelHandler[] v2, v4;
io.netty.channel.ChannelFuture v7;
boolean v1, v8, v9;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: boolean;
v2 := @parameter1: io.netty.channel.ChannelHandler[];
staticinvoke <io.netty.util.internal.ObjectUtil: java.lang.Object checkNotNull(java.lang.Object,java.lang.String)>(v2, "handlers");
v3 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelPipeline pipeline()>();
v4 = newarray (io.netty.channel.ChannelHandler)[1];
v5 = new io.netty.channel.embedded.EmbeddedChannel$2;
specialinvoke v5.<io.netty.channel.embedded.EmbeddedChannel$2: void <init>(io.netty.channel.embedded.EmbeddedChannel,io.netty.channel.ChannelHandler[])>(v0, v2);
v4[0] = v5;
interfaceinvoke v3.<io.netty.channel.ChannelPipeline: io.netty.channel.ChannelPipeline addLast(io.netty.channel.ChannelHandler[])>(v4);
if v1 == 0 goto label1;
v6 = v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.embedded.EmbeddedEventLoop loop>;
v7 = virtualinvoke v6.<io.netty.channel.embedded.EmbeddedEventLoop: io.netty.channel.ChannelFuture register(io.netty.channel.Channel)>(v0);
v8 = <io.netty.channel.embedded.EmbeddedChannel: boolean $assertionsDisabled>;
if v8 != 0 goto label1;
v9 = interfaceinvoke v7.<io.netty.channel.ChannelFuture: boolean isDone()>();
if v9 != 0 goto label1;
v10 = new java.lang.AssertionError;
specialinvoke v10.<java.lang.AssertionError: void <init>()>();
throw v10;
label1:
return;
}
public void register() throws java.lang.Exception
{
java.lang.Throwable v6;
io.netty.channel.embedded.EmbeddedChannel v0;
java.lang.AssertionError v5;
io.netty.channel.embedded.EmbeddedEventLoop v1;
boolean v3, v4;
io.netty.channel.ChannelFuture v2;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.embedded.EmbeddedEventLoop loop>;
v2 = virtualinvoke v1.<io.netty.channel.embedded.EmbeddedEventLoop: io.netty.channel.ChannelFuture register(io.netty.channel.Channel)>(v0);
v3 = <io.netty.channel.embedded.EmbeddedChannel: boolean $assertionsDisabled>;
if v3 != 0 goto label1;
v4 = interfaceinvoke v2.<io.netty.channel.ChannelFuture: boolean isDone()>();
if v4 != 0 goto label1;
v5 = new java.lang.AssertionError;
specialinvoke v5.<java.lang.AssertionError: void <init>()>();
throw v5;
label1:
v6 = interfaceinvoke v2.<io.netty.channel.ChannelFuture: java.lang.Throwable cause()>();
if v6 == null goto label2;
staticinvoke <io.netty.util.internal.PlatformDependent: void throwException(java.lang.Throwable)>(v6);
label2:
return;
}
protected final io.netty.channel.DefaultChannelPipeline newChannelPipeline()
{
io.netty.channel.embedded.EmbeddedChannel$EmbeddedChannelPipeline v1;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = new io.netty.channel.embedded.EmbeddedChannel$EmbeddedChannelPipeline;
specialinvoke v1.<io.netty.channel.embedded.EmbeddedChannel$EmbeddedChannelPipeline: void <init>(io.netty.channel.embedded.EmbeddedChannel,io.netty.channel.embedded.EmbeddedChannel)>(v0, v0);
return v1;
}
public io.netty.channel.ChannelMetadata metadata()
{
io.netty.channel.ChannelMetadata v1;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelMetadata metadata>;
return v1;
}
public io.netty.channel.ChannelConfig config()
{
io.netty.channel.ChannelConfig v1;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelConfig config>;
return v1;
}
public boolean isOpen()
{
io.netty.channel.embedded.EmbeddedChannel v0;
io.netty.channel.embedded.EmbeddedChannel$State v1, v2;
boolean v3;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.embedded.EmbeddedChannel$State state>;
v2 = <io.netty.channel.embedded.EmbeddedChannel$State: io.netty.channel.embedded.EmbeddedChannel$State CLOSED>;
if v1 == v2 goto label1;
v3 = 1;
goto label2;
label1:
v3 = 0;
label2:
return v3;
}
public boolean isActive()
{
io.netty.channel.embedded.EmbeddedChannel v0;
io.netty.channel.embedded.EmbeddedChannel$State v1, v2;
boolean v3;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.embedded.EmbeddedChannel$State state>;
v2 = <io.netty.channel.embedded.EmbeddedChannel$State: io.netty.channel.embedded.EmbeddedChannel$State ACTIVE>;
if v1 != v2 goto label1;
v3 = 1;
goto label2;
label1:
v3 = 0;
label2:
return v3;
}
public java.util.Queue inboundMessages()
{
io.netty.channel.embedded.EmbeddedChannel v0;
java.util.Queue v1, v3;
java.util.ArrayDeque v2;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue inboundMessages>;
if v1 != null goto label1;
v2 = new java.util.ArrayDeque;
specialinvoke v2.<java.util.ArrayDeque: void <init>()>();
v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue inboundMessages> = v2;
label1:
v3 = v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue inboundMessages>;
return v3;
}
public java.util.Queue lastInboundBuffer()
{
java.util.Queue v1;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue inboundMessages()>();
return v1;
}
public java.util.Queue outboundMessages()
{
io.netty.channel.embedded.EmbeddedChannel v0;
java.util.Queue v1, v3;
java.util.ArrayDeque v2;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue outboundMessages>;
if v1 != null goto label1;
v2 = new java.util.ArrayDeque;
specialinvoke v2.<java.util.ArrayDeque: void <init>()>();
v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue outboundMessages> = v2;
label1:
v3 = v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue outboundMessages>;
return v3;
}
public java.util.Queue lastOutboundBuffer()
{
java.util.Queue v1;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue outboundMessages()>();
return v1;
}
public java.lang.Object readInbound()
{
java.lang.Object v2;
java.util.Queue v1;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue inboundMessages>;
v2 = staticinvoke <io.netty.channel.embedded.EmbeddedChannel: java.lang.Object poll(java.util.Queue)>(v1);
if v2 == null goto label1;
staticinvoke <io.netty.util.ReferenceCountUtil: java.lang.Object touch(java.lang.Object,java.lang.Object)>(v2, "Caller of readInbound() will handle the message from this point");
label1:
return v2;
}
public java.lang.Object readOutbound()
{
java.lang.Object v2;
java.util.Queue v1;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue outboundMessages>;
v2 = staticinvoke <io.netty.channel.embedded.EmbeddedChannel: java.lang.Object poll(java.util.Queue)>(v1);
if v2 == null goto label1;
staticinvoke <io.netty.util.ReferenceCountUtil: java.lang.Object touch(java.lang.Object,java.lang.Object)>(v2, "Caller of readOutbound() will handle the message from this point.");
label1:
return v2;
}
public transient boolean writeInbound(java.lang.Object[])
{
java.lang.Object[] v1;
io.netty.channel.embedded.EmbeddedChannel v0;
io.netty.channel.ChannelPipeline v5;
io.netty.channel.ChannelPromise v9;
int v2, v6, v7;
java.lang.Object v8;
java.util.Queue v10, v3;
boolean v11, v4;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: java.lang.Object[];
virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void ensureOpen()>();
v2 = lengthof v1;
if v2 != 0 goto label1;
v3 = v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue inboundMessages>;
v4 = staticinvoke <io.netty.channel.embedded.EmbeddedChannel: boolean isNotEmpty(java.util.Queue)>(v3);
return v4;
label1:
v5 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelPipeline pipeline()>();
v6 = lengthof v1;
v7 = 0;
label2:
if v7 >= v6 goto label3;
v8 = v1[v7];
interfaceinvoke v5.<io.netty.channel.ChannelPipeline: io.netty.channel.ChannelPipeline fireChannelRead(java.lang.Object)>(v8);
v7 = v7 + 1;
goto label2;
label3:
v9 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelPromise voidPromise()>();
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelFuture flushInbound(boolean,io.netty.channel.ChannelPromise)>(0, v9);
v10 = v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue inboundMessages>;
v11 = staticinvoke <io.netty.channel.embedded.EmbeddedChannel: boolean isNotEmpty(java.util.Queue)>(v10);
return v11;
}
public io.netty.channel.ChannelFuture writeOneInbound(java.lang.Object)
{
io.netty.channel.ChannelPromise v2;
io.netty.channel.embedded.EmbeddedChannel v0;
java.lang.Object v1;
io.netty.channel.ChannelFuture v3;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: java.lang.Object;
v2 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelPromise newPromise()>();
v3 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelFuture writeOneInbound(java.lang.Object,io.netty.channel.ChannelPromise)>(v1, v2);
return v3;
}
public io.netty.channel.ChannelFuture writeOneInbound(java.lang.Object, io.netty.channel.ChannelPromise)
{
io.netty.channel.ChannelPromise v2;
io.netty.channel.embedded.EmbeddedChannel v0;
java.lang.Object v1;
io.netty.channel.ChannelPipeline v4;
boolean v3;
io.netty.channel.ChannelFuture v5;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: java.lang.Object;
v2 := @parameter1: io.netty.channel.ChannelPromise;
v3 = specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: boolean checkOpen(boolean)>(1);
if v3 == 0 goto label1;
v4 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelPipeline pipeline()>();
interfaceinvoke v4.<io.netty.channel.ChannelPipeline: io.netty.channel.ChannelPipeline fireChannelRead(java.lang.Object)>(v1);
label1:
v5 = specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelFuture checkException(io.netty.channel.ChannelPromise)>(v2);
return v5;
}
public io.netty.channel.embedded.EmbeddedChannel flushInbound()
{
io.netty.channel.ChannelPromise v1;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelPromise voidPromise()>();
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelFuture flushInbound(boolean,io.netty.channel.ChannelPromise)>(1, v1);
return v0;
}
private io.netty.channel.ChannelFuture flushInbound(boolean, io.netty.channel.ChannelPromise)
{
io.netty.channel.ChannelPromise v2;
io.netty.channel.embedded.EmbeddedChannel v0;
io.netty.channel.ChannelPipeline v4;
boolean v1, v3;
io.netty.channel.ChannelFuture v5;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: boolean;
v2 := @parameter1: io.netty.channel.ChannelPromise;
v3 = specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: boolean checkOpen(boolean)>(v1);
if v3 == 0 goto label1;
v4 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelPipeline pipeline()>();
interfaceinvoke v4.<io.netty.channel.ChannelPipeline: io.netty.channel.ChannelPipeline fireChannelReadComplete()>();
virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void runPendingTasks()>();
label1:
v5 = specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelFuture checkException(io.netty.channel.ChannelPromise)>(v2);
return v5;
}
public transient boolean writeOutbound(java.lang.Object[])
{
java.lang.Throwable v18;
java.lang.Object[] v1;
io.netty.util.internal.RecyclableArrayList v6;
io.netty.channel.ChannelFutureListener v15;
int v11, v12, v2, v5, v7, v8;
boolean v14, v17, v4;
io.netty.channel.embedded.EmbeddedChannel v0;
io.netty.channel.ChannelFuture v10;
java.lang.Object v13, v9;
java.util.Queue v16, v3;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: java.lang.Object[];
virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void ensureOpen()>();
v2 = lengthof v1;
if v2 != 0 goto label01;
v3 = v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue outboundMessages>;
v4 = staticinvoke <io.netty.channel.embedded.EmbeddedChannel: boolean isNotEmpty(java.util.Queue)>(v3);
return v4;
label01:
v5 = lengthof v1;
v6 = staticinvoke <io.netty.util.internal.RecyclableArrayList: io.netty.util.internal.RecyclableArrayList newInstance(int)>(v5);
label02:
v7 = lengthof v1;
v8 = 0;
label03:
if v8 >= v7 goto label04;
v9 = v1[v8];
if v9 == null goto label04;
v10 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelFuture write(java.lang.Object)>(v9);
virtualinvoke v6.<io.netty.util.internal.RecyclableArrayList: boolean add(java.lang.Object)>(v10);
v8 = v8 + 1;
goto label03;
label04:
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void flushOutbound0()>();
v11 = virtualinvoke v6.<io.netty.util.internal.RecyclableArrayList: int size()>();
v12 = 0;
label05:
if v12 >= v11 goto label08;
v13 = virtualinvoke v6.<io.netty.util.internal.RecyclableArrayList: java.lang.Object get(int)>(v12);
v14 = interfaceinvoke v13.<io.netty.channel.ChannelFuture: boolean isDone()>();
if v14 == 0 goto label06;
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void recordException(io.netty.channel.ChannelFuture)>(v13);
goto label07;
label06:
v15 = v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelFutureListener recordExceptionListener>;
interfaceinvoke v13.<io.netty.channel.ChannelFuture: io.netty.channel.ChannelFuture addListener(io.netty.util.concurrent.GenericFutureListener)>(v15);
label07:
v12 = v12 + 1;
goto label05;
label08:
virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void checkException()>();
v16 = v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue outboundMessages>;
v17 = staticinvoke <io.netty.channel.embedded.EmbeddedChannel: boolean isNotEmpty(java.util.Queue)>(v16);
label09:
virtualinvoke v6.<io.netty.util.internal.RecyclableArrayList: boolean recycle()>();
return v17;
label10:
v18 := @caughtexception;
virtualinvoke v6.<io.netty.util.internal.RecyclableArrayList: boolean recycle()>();
throw v18;
catch java.lang.Throwable from label02 to label09 with label10;
}
public io.netty.channel.ChannelFuture writeOneOutbound(java.lang.Object)
{
io.netty.channel.ChannelPromise v2;
io.netty.channel.embedded.EmbeddedChannel v0;
java.lang.Object v1;
io.netty.channel.ChannelFuture v3;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: java.lang.Object;
v2 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelPromise newPromise()>();
v3 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelFuture writeOneOutbound(java.lang.Object,io.netty.channel.ChannelPromise)>(v1, v2);
return v3;
}
public io.netty.channel.ChannelFuture writeOneOutbound(java.lang.Object, io.netty.channel.ChannelPromise)
{
io.netty.channel.ChannelPromise v2;
io.netty.channel.embedded.EmbeddedChannel v0;
java.lang.Object v1;
boolean v3;
io.netty.channel.ChannelFuture v4, v5;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: java.lang.Object;
v2 := @parameter1: io.netty.channel.ChannelPromise;
v3 = specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: boolean checkOpen(boolean)>(1);
if v3 == 0 goto label1;
v4 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelFuture write(java.lang.Object,io.netty.channel.ChannelPromise)>(v1, v2);
return v4;
label1:
v5 = specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelFuture checkException(io.netty.channel.ChannelPromise)>(v2);
return v5;
}
public io.netty.channel.embedded.EmbeddedChannel flushOutbound()
{
io.netty.channel.ChannelPromise v2;
boolean v1;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: boolean checkOpen(boolean)>(1);
if v1 == 0 goto label1;
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void flushOutbound0()>();
label1:
v2 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelPromise voidPromise()>();
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelFuture checkException(io.netty.channel.ChannelPromise)>(v2);
return v0;
}
private void flushOutbound0()
{
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void runPendingTasks()>();
virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.Channel flush()>();
return;
}
public boolean finish()
{
boolean v1;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: boolean finish(boolean)>(0);
return v1;
}
public boolean finishAndReleaseAll()
{
boolean v1;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: boolean finish(boolean)>(1);
return v1;
}
private boolean finish(boolean)
{
java.lang.Throwable v10;
io.netty.channel.embedded.EmbeddedChannel v0;
java.util.Queue v11, v12, v2, v4, v8, v9;
boolean v1, v3, v5, v6, v7;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: boolean;
virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelFuture close()>();
label1:
virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void checkException()>();
v2 = v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue inboundMessages>;
v3 = staticinvoke <io.netty.channel.embedded.EmbeddedChannel: boolean isNotEmpty(java.util.Queue)>(v2);
if v3 != 0 goto label2;
v4 = v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue outboundMessages>;
v5 = staticinvoke <io.netty.channel.embedded.EmbeddedChannel: boolean isNotEmpty(java.util.Queue)>(v4);
if v5 == 0 goto label3;
label2:
v6 = 1;
goto label4;
label3:
v6 = 0;
label4:
v7 = v6;
label5:
if v1 == 0 goto label6;
v8 = v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue inboundMessages>;
staticinvoke <io.netty.channel.embedded.EmbeddedChannel: boolean releaseAll(java.util.Queue)>(v8);
v9 = v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue outboundMessages>;
staticinvoke <io.netty.channel.embedded.EmbeddedChannel: boolean releaseAll(java.util.Queue)>(v9);
label6:
return v7;
label7:
v10 := @caughtexception;
if v1 == 0 goto label8;
v11 = v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue inboundMessages>;
staticinvoke <io.netty.channel.embedded.EmbeddedChannel: boolean releaseAll(java.util.Queue)>(v11);
v12 = v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue outboundMessages>;
staticinvoke <io.netty.channel.embedded.EmbeddedChannel: boolean releaseAll(java.util.Queue)>(v12);
label8:
throw v10;
catch java.lang.Throwable from label1 to label5 with label7;
}
public boolean releaseInbound()
{
java.util.Queue v1;
boolean v2;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue inboundMessages>;
v2 = staticinvoke <io.netty.channel.embedded.EmbeddedChannel: boolean releaseAll(java.util.Queue)>(v1);
return v2;
}
public boolean releaseOutbound()
{
java.util.Queue v1;
boolean v2;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue outboundMessages>;
v2 = staticinvoke <io.netty.channel.embedded.EmbeddedChannel: boolean releaseAll(java.util.Queue)>(v1);
return v2;
}
private static boolean releaseAll(java.util.Queue)
{
java.lang.Object v2;
java.util.Queue v0;
boolean v1;
v0 := @parameter0: java.util.Queue;
v1 = staticinvoke <io.netty.channel.embedded.EmbeddedChannel: boolean isNotEmpty(java.util.Queue)>(v0);
if v1 == 0 goto label3;
label1:
v2 = interfaceinvoke v0.<java.util.Queue: java.lang.Object poll()>();
if v2 == null goto label2;
staticinvoke <io.netty.util.ReferenceCountUtil: boolean release(java.lang.Object)>(v2);
goto label1;
label2:
return 1;
label3:
return 0;
}
private void finishPendingTasks(boolean)
{
io.netty.channel.embedded.EmbeddedEventLoop v2;
boolean v1;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: boolean;
virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void runPendingTasks()>();
if v1 == 0 goto label1;
v2 = specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.embedded.EmbeddedEventLoop embeddedEventLoop()>();
virtualinvoke v2.<io.netty.channel.embedded.EmbeddedEventLoop: void cancelScheduledTasks()>();
label1:
return;
}
public final io.netty.channel.ChannelFuture close()
{
io.netty.channel.ChannelPromise v1;
io.netty.channel.ChannelFuture v2;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelPromise newPromise()>();
v2 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)>(v1);
return v2;
}
public final io.netty.channel.ChannelFuture disconnect()
{
io.netty.channel.ChannelPromise v1;
io.netty.channel.ChannelFuture v2;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelPromise newPromise()>();
v2 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)>(v1);
return v2;
}
public final io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)
{
io.netty.channel.ChannelPromise v1;
io.netty.channel.ChannelFuture v2;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: io.netty.channel.ChannelPromise;
virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void runPendingTasks()>();
v2 = specialinvoke v0.<io.netty.channel.AbstractChannel: io.netty.channel.ChannelFuture close(io.netty.channel.ChannelPromise)>(v1);
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void finishPendingTasks(boolean)>(1);
return v2;
}
public final io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)
{
io.netty.channel.ChannelPromise v1;
io.netty.channel.embedded.EmbeddedChannel v0;
io.netty.channel.ChannelMetadata v3;
boolean v4, v5;
io.netty.channel.ChannelFuture v2;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: io.netty.channel.ChannelPromise;
v2 = specialinvoke v0.<io.netty.channel.AbstractChannel: io.netty.channel.ChannelFuture disconnect(io.netty.channel.ChannelPromise)>(v1);
v3 = v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelMetadata metadata>;
v4 = virtualinvoke v3.<io.netty.channel.ChannelMetadata: boolean hasDisconnect()>();
if v4 != 0 goto label1;
v5 = 1;
goto label2;
label1:
v5 = 0;
label2:
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void finishPendingTasks(boolean)>(v5);
return v2;
}
private static boolean isNotEmpty(java.util.Queue)
{
java.util.Queue v0;
boolean v1, v2;
v0 := @parameter0: java.util.Queue;
if v0 == null goto label1;
v1 = interfaceinvoke v0.<java.util.Queue: boolean isEmpty()>();
if v1 != 0 goto label1;
v2 = 1;
goto label2;
label1:
v2 = 0;
label2:
return v2;
}
private static java.lang.Object poll(java.util.Queue)
{
java.lang.Object v1;
java.util.Queue v0;
v0 := @parameter0: java.util.Queue;
if v0 == null goto label1;
v1 = interfaceinvoke v0.<java.util.Queue: java.lang.Object poll()>();
goto label2;
label1:
v1 = null;
label2:
return v1;
}
public void runPendingTasks()
{
io.netty.channel.embedded.EmbeddedChannel v0;
io.netty.channel.embedded.EmbeddedEventLoop v1, v3;
java.lang.Exception v2, v4;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
label1:
v1 = specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.embedded.EmbeddedEventLoop embeddedEventLoop()>();
virtualinvoke v1.<io.netty.channel.embedded.EmbeddedEventLoop: void runTasks()>();
label2:
goto label4;
label3:
v2 := @caughtexception;
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void recordException(java.lang.Throwable)>(v2);
label4:
v3 = specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.embedded.EmbeddedEventLoop embeddedEventLoop()>();
virtualinvoke v3.<io.netty.channel.embedded.EmbeddedEventLoop: long runScheduledTasks()>();
label5:
goto label7;
label6:
v4 := @caughtexception;
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void recordException(java.lang.Throwable)>(v4);
label7:
return;
catch java.lang.Exception from label1 to label2 with label3;
catch java.lang.Exception from label4 to label5 with label6;
}
public boolean hasPendingTasks()
{
byte v5;
io.netty.channel.embedded.EmbeddedChannel v0;
long v4;
io.netty.channel.embedded.EmbeddedEventLoop v1, v3;
boolean v2, v6;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.embedded.EmbeddedEventLoop embeddedEventLoop()>();
v2 = virtualinvoke v1.<io.netty.channel.embedded.EmbeddedEventLoop: boolean hasPendingNormalTasks()>();
if v2 != 0 goto label1;
v3 = specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.embedded.EmbeddedEventLoop embeddedEventLoop()>();
v4 = virtualinvoke v3.<io.netty.channel.embedded.EmbeddedEventLoop: long nextScheduledTask()>();
v5 = v4 cmp 0L;
if v5 != 0 goto label2;
label1:
v6 = 1;
goto label3;
label2:
v6 = 0;
label3:
return v6;
}
public long runScheduledPendingTasks()
{
io.netty.channel.embedded.EmbeddedChannel v0;
long v2, v5;
io.netty.channel.embedded.EmbeddedEventLoop v1, v4;
java.lang.Exception v3;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
label1:
v1 = specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.embedded.EmbeddedEventLoop embeddedEventLoop()>();
v2 = virtualinvoke v1.<io.netty.channel.embedded.EmbeddedEventLoop: long runScheduledTasks()>();
label2:
return v2;
label3:
v3 := @caughtexception;
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void recordException(java.lang.Throwable)>(v3);
v4 = specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.embedded.EmbeddedEventLoop embeddedEventLoop()>();
v5 = virtualinvoke v4.<io.netty.channel.embedded.EmbeddedEventLoop: long nextScheduledTask()>();
return v5;
catch java.lang.Exception from label1 to label2 with label3;
}
private void recordException(io.netty.channel.ChannelFuture)
{
java.lang.Throwable v3;
io.netty.channel.embedded.EmbeddedChannel v0;
boolean v2;
io.netty.channel.ChannelFuture v1;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: io.netty.channel.ChannelFuture;
v2 = interfaceinvoke v1.<io.netty.channel.ChannelFuture: boolean isSuccess()>();
if v2 != 0 goto label1;
v3 = interfaceinvoke v1.<io.netty.channel.ChannelFuture: java.lang.Throwable cause()>();
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void recordException(java.lang.Throwable)>(v3);
label1:
return;
}
private void recordException(java.lang.Throwable)
{
java.lang.Throwable v1, v2;
io.netty.channel.embedded.EmbeddedChannel v0;
io.netty.util.internal.logging.InternalLogger v3;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: java.lang.Throwable;
v2 = v0.<io.netty.channel.embedded.EmbeddedChannel: java.lang.Throwable lastException>;
if v2 != null goto label1;
v0.<io.netty.channel.embedded.EmbeddedChannel: java.lang.Throwable lastException> = v1;
goto label2;
label1:
v3 = <io.netty.channel.embedded.EmbeddedChannel: io.netty.util.internal.logging.InternalLogger logger>;
interfaceinvoke v3.<io.netty.util.internal.logging.InternalLogger: void warn(java.lang.String,java.lang.Throwable)>("More than one exception was raised. Will report only the first one and log others.", v1);
label2:
return;
}
public void advanceTimeBy(long, java.util.concurrent.TimeUnit)
{
java.util.concurrent.TimeUnit v2;
io.netty.channel.embedded.EmbeddedChannel v0;
long v1, v4;
io.netty.channel.embedded.EmbeddedEventLoop v3;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: long;
v2 := @parameter1: java.util.concurrent.TimeUnit;
v3 = specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.embedded.EmbeddedEventLoop embeddedEventLoop()>();
v4 = virtualinvoke v2.<java.util.concurrent.TimeUnit: long toNanos(long)>(v1);
virtualinvoke v3.<io.netty.channel.embedded.EmbeddedEventLoop: void advanceTimeBy(long)>(v4);
return;
}
public void freezeTime()
{
io.netty.channel.embedded.EmbeddedEventLoop v1;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.embedded.EmbeddedEventLoop embeddedEventLoop()>();
virtualinvoke v1.<io.netty.channel.embedded.EmbeddedEventLoop: void freezeTime()>();
return;
}
public void unfreezeTime()
{
io.netty.channel.embedded.EmbeddedEventLoop v1;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.embedded.EmbeddedEventLoop embeddedEventLoop()>();
virtualinvoke v1.<io.netty.channel.embedded.EmbeddedEventLoop: void unfreezeTime()>();
return;
}
private io.netty.channel.ChannelFuture checkException(io.netty.channel.ChannelPromise)
{
java.lang.Throwable v2;
io.netty.channel.ChannelPromise v1, v4, v5;
io.netty.channel.embedded.EmbeddedChannel v0;
boolean v3;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: io.netty.channel.ChannelPromise;
v2 = v0.<io.netty.channel.embedded.EmbeddedChannel: java.lang.Throwable lastException>;
if v2 == null goto label2;
v0.<io.netty.channel.embedded.EmbeddedChannel: java.lang.Throwable lastException> = null;
v3 = interfaceinvoke v1.<io.netty.channel.ChannelPromise: boolean isVoid()>();
if v3 == 0 goto label1;
staticinvoke <io.netty.util.internal.PlatformDependent: void throwException(java.lang.Throwable)>(v2);
label1:
v4 = interfaceinvoke v1.<io.netty.channel.ChannelPromise: io.netty.channel.ChannelPromise setFailure(java.lang.Throwable)>(v2);
return v4;
label2:
v5 = interfaceinvoke v1.<io.netty.channel.ChannelPromise: io.netty.channel.ChannelPromise setSuccess()>();
return v5;
}
public void checkException()
{
io.netty.channel.ChannelPromise v1;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelPromise voidPromise()>();
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelFuture checkException(io.netty.channel.ChannelPromise)>(v1);
return;
}
private boolean checkOpen(boolean)
{
java.nio.channels.ClosedChannelException v3;
io.netty.channel.embedded.EmbeddedChannel v0;
boolean v1, v2;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: boolean;
v2 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: boolean isOpen()>();
if v2 != 0 goto label2;
if v1 == 0 goto label1;
v3 = new java.nio.channels.ClosedChannelException;
specialinvoke v3.<java.nio.channels.ClosedChannelException: void <init>()>();
specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void recordException(java.lang.Throwable)>(v3);
label1:
return 0;
label2:
return 1;
}
private io.netty.channel.embedded.EmbeddedEventLoop embeddedEventLoop()
{
io.netty.channel.embedded.EmbeddedChannel v0;
io.netty.channel.EventLoop v2;
io.netty.channel.embedded.EmbeddedEventLoop v3;
boolean v1;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: boolean isRegistered()>();
if v1 == 0 goto label1;
v2 = specialinvoke v0.<io.netty.channel.AbstractChannel: io.netty.channel.EventLoop eventLoop()>();
return v2;
label1:
v3 = v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.embedded.EmbeddedEventLoop loop>;
return v3;
}
protected final void ensureOpen()
{
boolean v1;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = specialinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: boolean checkOpen(boolean)>(1);
if v1 != 0 goto label1;
virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void checkException()>();
label1:
return;
}
protected boolean isCompatible(io.netty.channel.EventLoop)
{
io.netty.channel.EventLoop v1;
boolean v2;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: io.netty.channel.EventLoop;
v2 = v1 instanceof io.netty.channel.embedded.EmbeddedEventLoop;
return v2;
}
protected java.net.SocketAddress localAddress0()
{
java.net.SocketAddress v2;
boolean v1;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: boolean isActive()>();
if v1 == 0 goto label1;
v2 = <io.netty.channel.embedded.EmbeddedChannel: java.net.SocketAddress LOCAL_ADDRESS>;
goto label2;
label1:
v2 = null;
label2:
return v2;
}
protected java.net.SocketAddress remoteAddress0()
{
java.net.SocketAddress v2;
boolean v1;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: boolean isActive()>();
if v1 == 0 goto label1;
v2 = <io.netty.channel.embedded.EmbeddedChannel: java.net.SocketAddress REMOTE_ADDRESS>;
goto label2;
label1:
v2 = null;
label2:
return v2;
}
protected void doRegister() throws java.lang.Exception
{
io.netty.channel.embedded.EmbeddedChannel v0;
io.netty.channel.embedded.EmbeddedChannel$State v1;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = <io.netty.channel.embedded.EmbeddedChannel$State: io.netty.channel.embedded.EmbeddedChannel$State ACTIVE>;
v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.embedded.EmbeddedChannel$State state> = v1;
return;
}
protected void doBind(java.net.SocketAddress) throws java.lang.Exception
{
java.net.SocketAddress v1;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: java.net.SocketAddress;
return;
}
protected void doDisconnect() throws java.lang.Exception
{
io.netty.channel.ChannelMetadata v1;
boolean v2;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelMetadata metadata>;
v2 = virtualinvoke v1.<io.netty.channel.ChannelMetadata: boolean hasDisconnect()>();
if v2 != 0 goto label1;
virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void doClose()>();
label1:
return;
}
protected void doClose() throws java.lang.Exception
{
io.netty.channel.embedded.EmbeddedChannel v0;
io.netty.channel.embedded.EmbeddedChannel$State v1;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = <io.netty.channel.embedded.EmbeddedChannel$State: io.netty.channel.embedded.EmbeddedChannel$State CLOSED>;
v0.<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.embedded.EmbeddedChannel$State state> = v1;
return;
}
protected void doBeginRead() throws java.lang.Exception
{
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
return;
}
protected io.netty.channel.AbstractChannel$AbstractUnsafe newUnsafe()
{
io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe v1;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = new io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe;
specialinvoke v1.<io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe: void <init>(io.netty.channel.embedded.EmbeddedChannel)>(v0);
return v1;
}
public io.netty.channel.Channel$Unsafe unsafe()
{
io.netty.channel.Channel$Unsafe v1, v2;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 = specialinvoke v0.<io.netty.channel.AbstractChannel: io.netty.channel.Channel$Unsafe unsafe()>();
v2 = v1.<io.netty.channel.embedded.EmbeddedChannel$EmbeddedUnsafe: io.netty.channel.Channel$Unsafe wrapped>;
return v2;
}
protected void doWrite(io.netty.channel.ChannelOutboundBuffer) throws java.lang.Exception
{
io.netty.channel.ChannelOutboundBuffer v1;
java.lang.Object v2;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: io.netty.channel.ChannelOutboundBuffer;
label1:
v2 = virtualinvoke v1.<io.netty.channel.ChannelOutboundBuffer: java.lang.Object current()>();
if v2 == null goto label2;
staticinvoke <io.netty.util.ReferenceCountUtil: java.lang.Object retain(java.lang.Object)>(v2);
virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: void handleOutboundMessage(java.lang.Object)>(v2);
virtualinvoke v1.<io.netty.channel.ChannelOutboundBuffer: boolean remove()>();
goto label1;
label2:
return;
}
protected void handleOutboundMessage(java.lang.Object)
{
java.lang.Object v1;
java.util.Queue v2;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: java.lang.Object;
v2 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue outboundMessages()>();
interfaceinvoke v2.<java.util.Queue: boolean add(java.lang.Object)>(v1);
return;
}
protected void handleInboundMessage(java.lang.Object)
{
java.lang.Object v1;
java.util.Queue v2;
io.netty.channel.embedded.EmbeddedChannel v0;
v0 := @this: io.netty.channel.embedded.EmbeddedChannel;
v1 := @parameter0: java.lang.Object;
v2 = virtualinvoke v0.<io.netty.channel.embedded.EmbeddedChannel: java.util.Queue inboundMessages()>();
interfaceinvoke v2.<java.util.Queue: boolean add(java.lang.Object)>(v1);
return;
}
static void <clinit>()
{
io.netty.channel.ChannelHandler[] v5;
io.netty.channel.embedded.EmbeddedSocketAddress v3, v4;
io.netty.util.internal.logging.InternalLogger v6;
java.lang.Class v0;
io.netty.channel.ChannelMetadata v7, v8;
boolean v1, v2;
v0 = class "Lio/netty/channel/embedded/EmbeddedChannel;";
v1 = virtualinvoke v0.<java.lang.Class: boolean desiredAssertionStatus()>();
if v1 != 0 goto label1;
v2 = 1;
goto label2;
label1:
v2 = 0;
label2:
<io.netty.channel.embedded.EmbeddedChannel: boolean $assertionsDisabled> = v2;
v3 = new io.netty.channel.embedded.EmbeddedSocketAddress;
specialinvoke v3.<io.netty.channel.embedded.EmbeddedSocketAddress: void <init>()>();
<io.netty.channel.embedded.EmbeddedChannel: java.net.SocketAddress LOCAL_ADDRESS> = v3;
v4 = new io.netty.channel.embedded.EmbeddedSocketAddress;
specialinvoke v4.<io.netty.channel.embedded.EmbeddedSocketAddress: void <init>()>();
<io.netty.channel.embedded.EmbeddedChannel: java.net.SocketAddress REMOTE_ADDRESS> = v4;
v5 = newarray (io.netty.channel.ChannelHandler)[0];
<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelHandler[] EMPTY_HANDLERS> = v5;
v6 = staticinvoke <io.netty.util.internal.logging.InternalLoggerFactory: io.netty.util.internal.logging.InternalLogger getInstance(java.lang.Class)>(class "Lio/netty/channel/embedded/EmbeddedChannel;");
<io.netty.channel.embedded.EmbeddedChannel: io.netty.util.internal.logging.InternalLogger logger> = v6;
v7 = new io.netty.channel.ChannelMetadata;
specialinvoke v7.<io.netty.channel.ChannelMetadata: void <init>(boolean)>(0);
<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelMetadata METADATA_NO_DISCONNECT> = v7;
v8 = new io.netty.channel.ChannelMetadata;
specialinvoke v8.<io.netty.channel.ChannelMetadata: void <init>(boolean)>(1);
<io.netty.channel.embedded.EmbeddedChannel: io.netty.channel.ChannelMetadata METADATA_DISCONNECT> = v8;
return;
}
}