public final class io.netty.handler.ssl.OpenSslSessionStats extends java.lang.Object
{
private final io.netty.handler.ssl.ReferenceCountedOpenSslContext context;
void <init>(io.netty.handler.ssl.ReferenceCountedOpenSslContext)
{
io.netty.handler.ssl.OpenSslSessionStats v0;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v1;
v0 := @this: io.netty.handler.ssl.OpenSslSessionStats;
v1 := @parameter0: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
specialinvoke v0.<java.lang.Object: void <init>()>();
v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context> = v1;
return;
}
public long number()
{
java.lang.Throwable v7;
long v5, v6;
io.netty.handler.ssl.OpenSslSessionStats v0;
java.util.concurrent.locks.Lock v3;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v1, v4;
java.util.concurrent.locks.ReadWriteLock v2;
v0 := @this: io.netty.handler.ssl.OpenSslSessionStats;
v1 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v2 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.concurrent.locks.ReadWriteLock ctxLock>;
v3 = interfaceinvoke v2.<java.util.concurrent.locks.ReadWriteLock: java.util.concurrent.locks.Lock readLock()>();
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void lock()>();
label1:
v4 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v5 = v4.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v6 = staticinvoke <io.netty.internal.tcnative.SSLContext: long sessionNumber(long)>(v5);
label2:
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
return v6;
label3:
v7 := @caughtexception;
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
throw v7;
catch java.lang.Throwable from label1 to label2 with label3;
}
public long connect()
{
java.lang.Throwable v7;
long v5, v6;
io.netty.handler.ssl.OpenSslSessionStats v0;
java.util.concurrent.locks.Lock v3;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v1, v4;
java.util.concurrent.locks.ReadWriteLock v2;
v0 := @this: io.netty.handler.ssl.OpenSslSessionStats;
v1 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v2 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.concurrent.locks.ReadWriteLock ctxLock>;
v3 = interfaceinvoke v2.<java.util.concurrent.locks.ReadWriteLock: java.util.concurrent.locks.Lock readLock()>();
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void lock()>();
label1:
v4 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v5 = v4.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v6 = staticinvoke <io.netty.internal.tcnative.SSLContext: long sessionConnect(long)>(v5);
label2:
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
return v6;
label3:
v7 := @caughtexception;
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
throw v7;
catch java.lang.Throwable from label1 to label2 with label3;
}
public long connectGood()
{
java.lang.Throwable v7;
long v5, v6;
io.netty.handler.ssl.OpenSslSessionStats v0;
java.util.concurrent.locks.Lock v3;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v1, v4;
java.util.concurrent.locks.ReadWriteLock v2;
v0 := @this: io.netty.handler.ssl.OpenSslSessionStats;
v1 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v2 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.concurrent.locks.ReadWriteLock ctxLock>;
v3 = interfaceinvoke v2.<java.util.concurrent.locks.ReadWriteLock: java.util.concurrent.locks.Lock readLock()>();
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void lock()>();
label1:
v4 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v5 = v4.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v6 = staticinvoke <io.netty.internal.tcnative.SSLContext: long sessionConnectGood(long)>(v5);
label2:
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
return v6;
label3:
v7 := @caughtexception;
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
throw v7;
catch java.lang.Throwable from label1 to label2 with label3;
}
public long connectRenegotiate()
{
java.lang.Throwable v7;
long v5, v6;
io.netty.handler.ssl.OpenSslSessionStats v0;
java.util.concurrent.locks.Lock v3;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v1, v4;
java.util.concurrent.locks.ReadWriteLock v2;
v0 := @this: io.netty.handler.ssl.OpenSslSessionStats;
v1 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v2 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.concurrent.locks.ReadWriteLock ctxLock>;
v3 = interfaceinvoke v2.<java.util.concurrent.locks.ReadWriteLock: java.util.concurrent.locks.Lock readLock()>();
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void lock()>();
label1:
v4 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v5 = v4.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v6 = staticinvoke <io.netty.internal.tcnative.SSLContext: long sessionConnectRenegotiate(long)>(v5);
label2:
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
return v6;
label3:
v7 := @caughtexception;
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
throw v7;
catch java.lang.Throwable from label1 to label2 with label3;
}
public long accept()
{
java.lang.Throwable v7;
long v5, v6;
io.netty.handler.ssl.OpenSslSessionStats v0;
java.util.concurrent.locks.Lock v3;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v1, v4;
java.util.concurrent.locks.ReadWriteLock v2;
v0 := @this: io.netty.handler.ssl.OpenSslSessionStats;
v1 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v2 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.concurrent.locks.ReadWriteLock ctxLock>;
v3 = interfaceinvoke v2.<java.util.concurrent.locks.ReadWriteLock: java.util.concurrent.locks.Lock readLock()>();
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void lock()>();
label1:
v4 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v5 = v4.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v6 = staticinvoke <io.netty.internal.tcnative.SSLContext: long sessionAccept(long)>(v5);
label2:
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
return v6;
label3:
v7 := @caughtexception;
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
throw v7;
catch java.lang.Throwable from label1 to label2 with label3;
}
public long acceptGood()
{
java.lang.Throwable v7;
long v5, v6;
io.netty.handler.ssl.OpenSslSessionStats v0;
java.util.concurrent.locks.Lock v3;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v1, v4;
java.util.concurrent.locks.ReadWriteLock v2;
v0 := @this: io.netty.handler.ssl.OpenSslSessionStats;
v1 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v2 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.concurrent.locks.ReadWriteLock ctxLock>;
v3 = interfaceinvoke v2.<java.util.concurrent.locks.ReadWriteLock: java.util.concurrent.locks.Lock readLock()>();
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void lock()>();
label1:
v4 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v5 = v4.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v6 = staticinvoke <io.netty.internal.tcnative.SSLContext: long sessionAcceptGood(long)>(v5);
label2:
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
return v6;
label3:
v7 := @caughtexception;
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
throw v7;
catch java.lang.Throwable from label1 to label2 with label3;
}
public long acceptRenegotiate()
{
java.lang.Throwable v7;
long v5, v6;
io.netty.handler.ssl.OpenSslSessionStats v0;
java.util.concurrent.locks.Lock v3;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v1, v4;
java.util.concurrent.locks.ReadWriteLock v2;
v0 := @this: io.netty.handler.ssl.OpenSslSessionStats;
v1 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v2 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.concurrent.locks.ReadWriteLock ctxLock>;
v3 = interfaceinvoke v2.<java.util.concurrent.locks.ReadWriteLock: java.util.concurrent.locks.Lock readLock()>();
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void lock()>();
label1:
v4 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v5 = v4.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v6 = staticinvoke <io.netty.internal.tcnative.SSLContext: long sessionAcceptRenegotiate(long)>(v5);
label2:
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
return v6;
label3:
v7 := @caughtexception;
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
throw v7;
catch java.lang.Throwable from label1 to label2 with label3;
}
public long hits()
{
java.lang.Throwable v7;
long v5, v6;
io.netty.handler.ssl.OpenSslSessionStats v0;
java.util.concurrent.locks.Lock v3;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v1, v4;
java.util.concurrent.locks.ReadWriteLock v2;
v0 := @this: io.netty.handler.ssl.OpenSslSessionStats;
v1 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v2 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.concurrent.locks.ReadWriteLock ctxLock>;
v3 = interfaceinvoke v2.<java.util.concurrent.locks.ReadWriteLock: java.util.concurrent.locks.Lock readLock()>();
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void lock()>();
label1:
v4 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v5 = v4.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v6 = staticinvoke <io.netty.internal.tcnative.SSLContext: long sessionHits(long)>(v5);
label2:
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
return v6;
label3:
v7 := @caughtexception;
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
throw v7;
catch java.lang.Throwable from label1 to label2 with label3;
}
public long cbHits()
{
java.lang.Throwable v7;
long v5, v6;
io.netty.handler.ssl.OpenSslSessionStats v0;
java.util.concurrent.locks.Lock v3;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v1, v4;
java.util.concurrent.locks.ReadWriteLock v2;
v0 := @this: io.netty.handler.ssl.OpenSslSessionStats;
v1 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v2 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.concurrent.locks.ReadWriteLock ctxLock>;
v3 = interfaceinvoke v2.<java.util.concurrent.locks.ReadWriteLock: java.util.concurrent.locks.Lock readLock()>();
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void lock()>();
label1:
v4 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v5 = v4.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v6 = staticinvoke <io.netty.internal.tcnative.SSLContext: long sessionCbHits(long)>(v5);
label2:
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
return v6;
label3:
v7 := @caughtexception;
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
throw v7;
catch java.lang.Throwable from label1 to label2 with label3;
}
public long misses()
{
java.lang.Throwable v7;
long v5, v6;
io.netty.handler.ssl.OpenSslSessionStats v0;
java.util.concurrent.locks.Lock v3;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v1, v4;
java.util.concurrent.locks.ReadWriteLock v2;
v0 := @this: io.netty.handler.ssl.OpenSslSessionStats;
v1 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v2 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.concurrent.locks.ReadWriteLock ctxLock>;
v3 = interfaceinvoke v2.<java.util.concurrent.locks.ReadWriteLock: java.util.concurrent.locks.Lock readLock()>();
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void lock()>();
label1:
v4 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v5 = v4.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v6 = staticinvoke <io.netty.internal.tcnative.SSLContext: long sessionMisses(long)>(v5);
label2:
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
return v6;
label3:
v7 := @caughtexception;
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
throw v7;
catch java.lang.Throwable from label1 to label2 with label3;
}
public long timeouts()
{
java.lang.Throwable v7;
long v5, v6;
io.netty.handler.ssl.OpenSslSessionStats v0;
java.util.concurrent.locks.Lock v3;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v1, v4;
java.util.concurrent.locks.ReadWriteLock v2;
v0 := @this: io.netty.handler.ssl.OpenSslSessionStats;
v1 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v2 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.concurrent.locks.ReadWriteLock ctxLock>;
v3 = interfaceinvoke v2.<java.util.concurrent.locks.ReadWriteLock: java.util.concurrent.locks.Lock readLock()>();
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void lock()>();
label1:
v4 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v5 = v4.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v6 = staticinvoke <io.netty.internal.tcnative.SSLContext: long sessionTimeouts(long)>(v5);
label2:
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
return v6;
label3:
v7 := @caughtexception;
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
throw v7;
catch java.lang.Throwable from label1 to label2 with label3;
}
public long cacheFull()
{
java.lang.Throwable v7;
long v5, v6;
io.netty.handler.ssl.OpenSslSessionStats v0;
java.util.concurrent.locks.Lock v3;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v1, v4;
java.util.concurrent.locks.ReadWriteLock v2;
v0 := @this: io.netty.handler.ssl.OpenSslSessionStats;
v1 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v2 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.concurrent.locks.ReadWriteLock ctxLock>;
v3 = interfaceinvoke v2.<java.util.concurrent.locks.ReadWriteLock: java.util.concurrent.locks.Lock readLock()>();
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void lock()>();
label1:
v4 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v5 = v4.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v6 = staticinvoke <io.netty.internal.tcnative.SSLContext: long sessionCacheFull(long)>(v5);
label2:
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
return v6;
label3:
v7 := @caughtexception;
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
throw v7;
catch java.lang.Throwable from label1 to label2 with label3;
}
public long ticketKeyFail()
{
java.lang.Throwable v7;
long v5, v6;
io.netty.handler.ssl.OpenSslSessionStats v0;
java.util.concurrent.locks.Lock v3;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v1, v4;
java.util.concurrent.locks.ReadWriteLock v2;
v0 := @this: io.netty.handler.ssl.OpenSslSessionStats;
v1 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v2 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.concurrent.locks.ReadWriteLock ctxLock>;
v3 = interfaceinvoke v2.<java.util.concurrent.locks.ReadWriteLock: java.util.concurrent.locks.Lock readLock()>();
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void lock()>();
label1:
v4 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v5 = v4.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v6 = staticinvoke <io.netty.internal.tcnative.SSLContext: long sessionTicketKeyFail(long)>(v5);
label2:
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
return v6;
label3:
v7 := @caughtexception;
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
throw v7;
catch java.lang.Throwable from label1 to label2 with label3;
}
public long ticketKeyNew()
{
java.lang.Throwable v7;
long v5, v6;
io.netty.handler.ssl.OpenSslSessionStats v0;
java.util.concurrent.locks.Lock v3;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v1, v4;
java.util.concurrent.locks.ReadWriteLock v2;
v0 := @this: io.netty.handler.ssl.OpenSslSessionStats;
v1 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v2 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.concurrent.locks.ReadWriteLock ctxLock>;
v3 = interfaceinvoke v2.<java.util.concurrent.locks.ReadWriteLock: java.util.concurrent.locks.Lock readLock()>();
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void lock()>();
label1:
v4 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v5 = v4.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v6 = staticinvoke <io.netty.internal.tcnative.SSLContext: long sessionTicketKeyNew(long)>(v5);
label2:
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
return v6;
label3:
v7 := @caughtexception;
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
throw v7;
catch java.lang.Throwable from label1 to label2 with label3;
}
public long ticketKeyRenew()
{
java.lang.Throwable v7;
long v5, v6;
io.netty.handler.ssl.OpenSslSessionStats v0;
java.util.concurrent.locks.Lock v3;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v1, v4;
java.util.concurrent.locks.ReadWriteLock v2;
v0 := @this: io.netty.handler.ssl.OpenSslSessionStats;
v1 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v2 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.concurrent.locks.ReadWriteLock ctxLock>;
v3 = interfaceinvoke v2.<java.util.concurrent.locks.ReadWriteLock: java.util.concurrent.locks.Lock readLock()>();
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void lock()>();
label1:
v4 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v5 = v4.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v6 = staticinvoke <io.netty.internal.tcnative.SSLContext: long sessionTicketKeyRenew(long)>(v5);
label2:
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
return v6;
label3:
v7 := @caughtexception;
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
throw v7;
catch java.lang.Throwable from label1 to label2 with label3;
}
public long ticketKeyResume()
{
java.lang.Throwable v7;
long v5, v6;
io.netty.handler.ssl.OpenSslSessionStats v0;
java.util.concurrent.locks.Lock v3;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v1, v4;
java.util.concurrent.locks.ReadWriteLock v2;
v0 := @this: io.netty.handler.ssl.OpenSslSessionStats;
v1 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v2 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.concurrent.locks.ReadWriteLock ctxLock>;
v3 = interfaceinvoke v2.<java.util.concurrent.locks.ReadWriteLock: java.util.concurrent.locks.Lock readLock()>();
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void lock()>();
label1:
v4 = v0.<io.netty.handler.ssl.OpenSslSessionStats: io.netty.handler.ssl.ReferenceCountedOpenSslContext context>;
v5 = v4.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v6 = staticinvoke <io.netty.internal.tcnative.SSLContext: long sessionTicketKeyResume(long)>(v5);
label2:
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
return v6;
label3:
v7 := @caughtexception;
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
throw v7;
catch java.lang.Throwable from label1 to label2 with label3;
}
}