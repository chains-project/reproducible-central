public class io.netty.handler.ssl.ReferenceCountedOpenSslEngine extends javax.net.ssl.SSLEngine implements io.netty.util.ReferenceCounted, io.netty.handler.ssl.ApplicationProtocolAccessor
{
private static final io.netty.util.internal.logging.InternalLogger logger;
private static final io.netty.util.ResourceLeakDetector leakDetector;
private static final int OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV2;
private static final int OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV3;
private static final int OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1;
private static final int OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1_1;
private static final int OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1_2;
private static final int OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1_3;
private static final int[] OPENSSL_OP_NO_PROTOCOLS;
static final int MAX_PLAINTEXT_LENGTH;
static final int MAX_RECORD_SIZE;
private static final javax.net.ssl.SSLEngineResult NEED_UNWRAP_OK;
private static final javax.net.ssl.SSLEngineResult NEED_UNWRAP_CLOSED;
private static final javax.net.ssl.SSLEngineResult NEED_WRAP_OK;
private static final javax.net.ssl.SSLEngineResult NEED_WRAP_CLOSED;
private static final javax.net.ssl.SSLEngineResult CLOSED_NOT_HANDSHAKING;
private long ssl;
private long networkBIO;
private io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState handshakeState;
private boolean receivedShutdown;
private volatile boolean destroyed;
private volatile java.lang.String applicationProtocol;
private volatile boolean needTask;
private java.lang.String[] explicitlyEnabledProtocols;
private boolean sessionSet;
private final io.netty.util.ResourceLeakTracker leak;
private final io.netty.util.AbstractReferenceCounted refCnt;
private volatile io.netty.handler.ssl.ClientAuth clientAuth;
private volatile long lastAccessed;
private java.lang.String endPointIdentificationAlgorithm;
private java.lang.Object algorithmConstraints;
private java.util.List sniHostNames;
private volatile java.util.Collection matchers;
private boolean isInboundDone;
private boolean outboundClosed;
final boolean jdkCompatibilityMode;
private final boolean clientMode;
final io.netty.buffer.ByteBufAllocator alloc;
private final io.netty.handler.ssl.OpenSslEngineMap engineMap;
private final io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator apn;
private final io.netty.handler.ssl.ReferenceCountedOpenSslContext parentContext;
private final io.netty.handler.ssl.OpenSslSession session;
private final java.nio.ByteBuffer[] singleSrcBuffer;
private final java.nio.ByteBuffer[] singleDstBuffer;
private final boolean enableOcsp;
private int maxWrapOverhead;
private int maxWrapBufferSize;
private java.lang.Throwable pendingException;
static final boolean $assertionsDisabled;
void <init>(io.netty.handler.ssl.ReferenceCountedOpenSslContext, io.netty.buffer.ByteBufAllocator, java.lang.String, int, boolean, boolean)
{
io.netty.handler.ssl.ClientAuth v38, v9;
io.netty.handler.ssl.ApplicationProtocolNegotiator v15;
java.util.concurrent.locks.ReadWriteLock v27;
java.lang.Throwable v33, v69, v70;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine$DefaultOpenSslSession v19, v21;
long v29, v32, v34, v36, v46, v48, v51, v52, v53, v57, v63, v67;
java.lang.String v3;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState v7;
io.netty.handler.ssl.OpenSslSession v25;
java.util.concurrent.locks.Lock v28;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v1, v71;
io.netty.buffer.ByteBufAllocator v2;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
boolean v13, v16, v24, v30, v31, v37, v42, v43, v45, v5, v50, v6, v60, v61, v62, v65, v66;
java.nio.ByteBuffer[] v10, v11;
io.netty.handler.ssl.OpenSslEngineMap v12;
io.netty.util.ResourceLeakDetector v72;
java.util.List v47, v49;
io.netty.handler.ssl.OpenSslSessionContext v20, v22, v23;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine$1 v8;
java.security.cert.Certificate[] v26;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine$2 v18;
java.lang.String[] v39, v40, v41;
int v17, v35, v4, v44, v54, v55, v56, v58, v59, v64, v68;
io.netty.util.ResourceLeakTracker v73;
java.lang.Object v14;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v2 := @parameter1: io.netty.buffer.ByteBufAllocator;
v3 := @parameter2: java.lang.String;
v4 := @parameter3: int;
v5 := @parameter4: boolean;
v6 := @parameter5: boolean;
specialinvoke v0.<javax.net.ssl.SSLEngine: void <init>(java.lang.String,int)>(v3, v4);
v7 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState NOT_STARTED>;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState handshakeState> = v7;
v8 = new io.netty.handler.ssl.ReferenceCountedOpenSslEngine$1;
specialinvoke v8.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine$1: void <init>(io.netty.handler.ssl.ReferenceCountedOpenSslEngine)>(v0);
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.util.AbstractReferenceCounted refCnt> = v8;
v9 = <io.netty.handler.ssl.ClientAuth: io.netty.handler.ssl.ClientAuth NONE>;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ClientAuth clientAuth> = v9;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long lastAccessed> = -1L;
v10 = newarray (java.nio.ByteBuffer)[1];
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.nio.ByteBuffer[] singleSrcBuffer> = v10;
v11 = newarray (java.nio.ByteBuffer)[1];
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.nio.ByteBuffer[] singleDstBuffer> = v11;
staticinvoke <io.netty.handler.ssl.OpenSsl: void ensureAvailability()>();
v12 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.handler.ssl.OpenSslEngineMap engineMap>;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.OpenSslEngineMap engineMap> = v12;
v13 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: boolean enableOcsp>;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean enableOcsp> = v13;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean jdkCompatibilityMode> = v5;
v14 = staticinvoke <io.netty.util.internal.ObjectUtil: java.lang.Object checkNotNull(java.lang.Object,java.lang.String)>(v2, "alloc");
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.buffer.ByteBufAllocator alloc> = v14;
v15 = virtualinvoke v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.handler.ssl.ApplicationProtocolNegotiator applicationProtocolNegotiator()>();
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator apn> = v15;
v16 = virtualinvoke v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: boolean isClient()>();
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean clientMode> = v16;
v17 = staticinvoke <io.netty.util.internal.PlatformDependent: int javaVersion()>();
if v17 < 7 goto label01;
v18 = new io.netty.handler.ssl.ReferenceCountedOpenSslEngine$2;
v19 = new io.netty.handler.ssl.ReferenceCountedOpenSslEngine$DefaultOpenSslSession;
v20 = virtualinvoke v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.handler.ssl.OpenSslSessionContext sessionContext()>();
specialinvoke v19.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine$DefaultOpenSslSession: void <init>(io.netty.handler.ssl.ReferenceCountedOpenSslEngine,io.netty.handler.ssl.OpenSslSessionContext)>(v0, v20);
specialinvoke v18.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine$2: void <init>(io.netty.handler.ssl.ReferenceCountedOpenSslEngine,io.netty.handler.ssl.OpenSslSession)>(v0, v19);
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.OpenSslSession session> = v18;
goto label02;
label01:
v21 = new io.netty.handler.ssl.ReferenceCountedOpenSslEngine$DefaultOpenSslSession;
v22 = virtualinvoke v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.handler.ssl.OpenSslSessionContext sessionContext()>();
specialinvoke v21.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine$DefaultOpenSslSession: void <init>(io.netty.handler.ssl.ReferenceCountedOpenSslEngine,io.netty.handler.ssl.OpenSslSessionContext)>(v0, v22);
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.OpenSslSession session> = v21;
label02:
v23 = virtualinvoke v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.handler.ssl.OpenSslSessionContext sessionContext()>();
v24 = virtualinvoke v23.<io.netty.handler.ssl.OpenSslSessionContext: boolean useKeyManager()>();
if v24 != 0 goto label03;
v25 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.OpenSslSession session>;
v26 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.security.cert.Certificate[] keyCertChain>;
interfaceinvoke v25.<io.netty.handler.ssl.OpenSslSession: void setLocalCertificate(java.security.cert.Certificate[])>(v26);
label03:
v27 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.concurrent.locks.ReadWriteLock ctxLock>;
v28 = interfaceinvoke v27.<java.util.concurrent.locks.ReadWriteLock: java.util.concurrent.locks.Lock readLock()>();
interfaceinvoke v28.<java.util.concurrent.locks.Lock: void lock()>();
label04:
v29 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v30 = virtualinvoke v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: boolean isClient()>();
if v30 != 0 goto label05;
v31 = 1;
goto label06;
label05:
v31 = 0;
label06:
v32 = staticinvoke <io.netty.internal.tcnative.SSL: long newSSL(long,boolean)>(v29, v31);
label07:
interfaceinvoke v28.<java.util.concurrent.locks.Lock: void unlock()>();
goto label09;
label08:
v33 := @caughtexception;
interfaceinvoke v28.<java.util.concurrent.locks.Lock: void unlock()>();
throw v33;
label09:
entermonitor v0;
label10:
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl> = v32;
label11:
v34 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v35 = virtualinvoke v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: int getBioNonApplicationBufferSize()>();
v36 = staticinvoke <io.netty.internal.tcnative.SSL: long bioNewByteBuffer(long,int)>(v34, v35);
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO> = v36;
v37 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean clientMode>;
if v37 == 0 goto label12;
v38 = <io.netty.handler.ssl.ClientAuth: io.netty.handler.ssl.ClientAuth NONE>;
goto label13;
label12:
v38 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.handler.ssl.ClientAuth clientAuth>;
label13:
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void setClientAuth(io.netty.handler.ssl.ClientAuth)>(v38);
v39 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.lang.String[] protocols>;
if v39 == null goto label14;
v40 = v1.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.lang.String[] protocols>;
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void setEnabledProtocols0(java.lang.String[],boolean)>(v40, 1);
goto label15;
label14:
v41 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.String[] getEnabledProtocols()>();
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.String[] explicitlyEnabledProtocols> = v41;
label15:
v42 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean clientMode>;
if v42 == 0 goto label17;
v43 = staticinvoke <io.netty.handler.ssl.SslUtils: boolean isValidHostNameForSNI(java.lang.String)>(v3);
if v43 == 0 goto label17;
v44 = staticinvoke <io.netty.util.internal.PlatformDependent: int javaVersion()>();
if v44 < 8 goto label16;
v45 = staticinvoke <io.netty.handler.ssl.Java8SslUtils: boolean isValidHostNameForSNI(java.lang.String)>(v3);
if v45 == 0 goto label17;
v46 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
staticinvoke <io.netty.internal.tcnative.SSL: void setTlsExtHostName(long,java.lang.String)>(v46, v3);
v47 = staticinvoke <java.util.Collections: java.util.List singletonList(java.lang.Object)>(v3);
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.util.List sniHostNames> = v47;
goto label17;
label16:
v48 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
staticinvoke <io.netty.internal.tcnative.SSL: void setTlsExtHostName(long,java.lang.String)>(v48, v3);
v49 = staticinvoke <java.util.Collections: java.util.List singletonList(java.lang.Object)>(v3);
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.util.List sniHostNames> = v49;
label17:
v50 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean enableOcsp>;
if v50 == 0 goto label18;
v51 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
staticinvoke <io.netty.internal.tcnative.SSL: void enableOcsp(long)>(v51);
label18:
if v5 != 0 goto label19;
v52 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v53 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v54 = staticinvoke <io.netty.internal.tcnative.SSL: int getMode(long)>(v53);
v55 = <io.netty.internal.tcnative.SSL: int SSL_MODE_ENABLE_PARTIAL_WRITE>;
v56 = v54 | v55;
staticinvoke <io.netty.internal.tcnative.SSL: int setMode(long,int)>(v52, v56);
label19:
v57 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v58 = staticinvoke <io.netty.internal.tcnative.SSL: int getOptions(long)>(v57);
v59 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_TLSv1_3>;
v60 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isProtocolEnabled(int,int,java.lang.String)>(v58, v59, "TLSv1.3");
if v60 == 0 goto label22;
v61 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean clientMode>;
if v61 == 0 goto label20;
v62 = <io.netty.handler.ssl.ReferenceCountedOpenSslContext: boolean CLIENT_ENABLE_SESSION_TICKET_TLSV13>;
goto label21;
label20:
v62 = <io.netty.handler.ssl.ReferenceCountedOpenSslContext: boolean SERVER_ENABLE_SESSION_TICKET_TLSV13>;
label21:
if v62 == 0 goto label22;
v63 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v64 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_TICKET>;
staticinvoke <io.netty.internal.tcnative.SSL: void clearOptions(long,int)>(v63, v64);
label22:
v65 = staticinvoke <io.netty.handler.ssl.OpenSsl: boolean isBoringSSL()>();
if v65 == 0 goto label23;
v66 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean clientMode>;
if v66 == 0 goto label23;
v67 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v68 = <io.netty.internal.tcnative.SSL: int SSL_RENEGOTIATE_ONCE>;
staticinvoke <io.netty.internal.tcnative.SSL: void setRenegotiateMode(long,int)>(v67, v68);
label23:
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void calculateMaxWrapOverhead()>();
label24:
goto label26;
label25:
v69 := @caughtexception;
virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void shutdown()>();
staticinvoke <io.netty.util.internal.PlatformDependent: void throwException(java.lang.Throwable)>(v69);
label26:
exitmonitor v0;
label27:
goto label29;
label28:
v70 := @caughtexception;
exitmonitor v0;
throw v70;
label29:
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslContext parentContext> = v1;
v71 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslContext parentContext>;
virtualinvoke v71.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.util.ReferenceCounted retain()>();
if v6 == 0 goto label30;
v72 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.util.ResourceLeakDetector leakDetector>;
v73 = virtualinvoke v72.<io.netty.util.ResourceLeakDetector: io.netty.util.ResourceLeakTracker track(java.lang.Object)>(v0);
goto label31;
label30:
v73 = null;
label31:
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.util.ResourceLeakTracker leak> = v73;
return;
catch java.lang.Throwable from label04 to label07 with label08;
catch java.lang.Throwable from label11 to label24 with label25;
catch java.lang.Throwable from label10 to label27 with label28;
}
final synchronized java.lang.String[] authMethods()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.lang.String[] v2, v4;
long v3;
boolean v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v1 == 0 goto label1;
v2 = <io.netty.util.internal.EmptyArrays: java.lang.String[] EMPTY_STRINGS>;
return v2;
label1:
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v4 = staticinvoke <io.netty.internal.tcnative.SSL: java.lang.String[] authenticationMethods(long)>(v3);
return v4;
}
final boolean setKeyMaterial(io.netty.handler.ssl.OpenSslKeyMaterial) throws java.lang.Exception
{
java.lang.Throwable v6;
io.netty.handler.ssl.OpenSslSession v7;
long v3, v4, v5;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
io.netty.handler.ssl.OpenSslKeyMaterial v1;
java.security.cert.X509Certificate[] v8;
boolean v2;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: io.netty.handler.ssl.OpenSslKeyMaterial;
entermonitor v0;
label1:
v2 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v2 == 0 goto label3;
exitmonitor v0;
label2:
return 0;
label3:
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v4 = interfaceinvoke v1.<io.netty.handler.ssl.OpenSslKeyMaterial: long certificateChainAddress()>();
v5 = interfaceinvoke v1.<io.netty.handler.ssl.OpenSslKeyMaterial: long privateKeyAddress()>();
staticinvoke <io.netty.internal.tcnative.SSL: void setKeyMaterial(long,long,long)>(v3, v4, v5);
exitmonitor v0;
label4:
goto label6;
label5:
v6 := @caughtexception;
exitmonitor v0;
throw v6;
label6:
v7 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.OpenSslSession session>;
v8 = interfaceinvoke v1.<io.netty.handler.ssl.OpenSslKeyMaterial: java.security.cert.X509Certificate[] certificateChain()>();
interfaceinvoke v7.<io.netty.handler.ssl.OpenSslSession: void setLocalCertificate(java.security.cert.Certificate[])>(v8);
return 1;
catch java.lang.Throwable from label1 to label2 with label5;
catch java.lang.Throwable from label3 to label4 with label5;
}
final synchronized javax.crypto.spec.SecretKeySpec masterKey()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
byte[] v4;
javax.crypto.spec.SecretKeySpec v2;
long v3;
boolean v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v1 == 0 goto label1;
return null;
label1:
v2 = new javax.crypto.spec.SecretKeySpec;
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v4 = staticinvoke <io.netty.internal.tcnative.SSL: byte[] getMasterKey(long)>(v3);
specialinvoke v2.<javax.crypto.spec.SecretKeySpec: void <init>(byte[],java.lang.String)>(v4, "AES");
return v2;
}
synchronized boolean isSessionReused()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
long v2;
boolean v1, v3;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v1 == 0 goto label1;
return 0;
label1:
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v3 = staticinvoke <io.netty.internal.tcnative.SSL: boolean isSessionReused(long)>(v2);
return v3;
}
public void setOcspResponse(byte[])
{
java.lang.Throwable v8;
byte[] v1;
java.lang.IllegalStateException v3, v5;
long v7;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
boolean v2, v4, v6;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: byte[];
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean enableOcsp>;
if v2 != 0 goto label1;
v3 = new java.lang.IllegalStateException;
specialinvoke v3.<java.lang.IllegalStateException: void <init>(java.lang.String)>("OCSP stapling is not enabled");
throw v3;
label1:
v4 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean clientMode>;
if v4 == 0 goto label2;
v5 = new java.lang.IllegalStateException;
specialinvoke v5.<java.lang.IllegalStateException: void <init>(java.lang.String)>("Not a server SSLEngine");
throw v5;
label2:
entermonitor v0;
label3:
v6 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v6 != 0 goto label4;
v7 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
staticinvoke <io.netty.internal.tcnative.SSL: void setOcspResponse(long,byte[])>(v7, v1);
label4:
exitmonitor v0;
label5:
goto label7;
label6:
v8 := @caughtexception;
exitmonitor v0;
throw v8;
label7:
return;
catch java.lang.Throwable from label3 to label5 with label6;
}
public byte[] getOcspResponse()
{
java.lang.Throwable v9;
byte[] v6, v8;
java.lang.IllegalStateException v2, v4;
long v7;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
boolean v1, v3, v5;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean enableOcsp>;
if v1 != 0 goto label1;
v2 = new java.lang.IllegalStateException;
specialinvoke v2.<java.lang.IllegalStateException: void <init>(java.lang.String)>("OCSP stapling is not enabled");
throw v2;
label1:
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean clientMode>;
if v3 != 0 goto label2;
v4 = new java.lang.IllegalStateException;
specialinvoke v4.<java.lang.IllegalStateException: void <init>(java.lang.String)>("Not a client SSLEngine");
throw v4;
label2:
entermonitor v0;
label3:
v5 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v5 == 0 goto label5;
v6 = <io.netty.util.internal.EmptyArrays: byte[] EMPTY_BYTES>;
exitmonitor v0;
label4:
return v6;
label5:
v7 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v8 = staticinvoke <io.netty.internal.tcnative.SSL: byte[] getOcspResponse(long)>(v7);
exitmonitor v0;
label6:
return v8;
label7:
v9 := @caughtexception;
exitmonitor v0;
throw v9;
catch java.lang.Throwable from label3 to label4 with label7;
catch java.lang.Throwable from label5 to label6 with label7;
}
public final int refCnt()
{
int v2;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
io.netty.util.AbstractReferenceCounted v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.util.AbstractReferenceCounted refCnt>;
v2 = virtualinvoke v1.<io.netty.util.AbstractReferenceCounted: int refCnt()>();
return v2;
}
public final io.netty.util.ReferenceCounted retain()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
io.netty.util.AbstractReferenceCounted v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.util.AbstractReferenceCounted refCnt>;
virtualinvoke v1.<io.netty.util.AbstractReferenceCounted: io.netty.util.ReferenceCounted retain()>();
return v0;
}
public final io.netty.util.ReferenceCounted retain(int)
{
int v1;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
io.netty.util.AbstractReferenceCounted v2;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: int;
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.util.AbstractReferenceCounted refCnt>;
virtualinvoke v2.<io.netty.util.AbstractReferenceCounted: io.netty.util.ReferenceCounted retain(int)>(v1);
return v0;
}
public final io.netty.util.ReferenceCounted touch()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
io.netty.util.AbstractReferenceCounted v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.util.AbstractReferenceCounted refCnt>;
virtualinvoke v1.<io.netty.util.AbstractReferenceCounted: io.netty.util.ReferenceCounted touch()>();
return v0;
}
public final io.netty.util.ReferenceCounted touch(java.lang.Object)
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
io.netty.util.AbstractReferenceCounted v2;
java.lang.Object v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: java.lang.Object;
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.util.AbstractReferenceCounted refCnt>;
virtualinvoke v2.<io.netty.util.AbstractReferenceCounted: io.netty.util.ReferenceCounted touch(java.lang.Object)>(v1);
return v0;
}
public final boolean release()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
io.netty.util.AbstractReferenceCounted v1;
boolean v2;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.util.AbstractReferenceCounted refCnt>;
v2 = virtualinvoke v1.<io.netty.util.AbstractReferenceCounted: boolean release()>();
return v2;
}
public final boolean release(int)
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
int v1;
io.netty.util.AbstractReferenceCounted v2;
boolean v3;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: int;
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.util.AbstractReferenceCounted refCnt>;
v3 = virtualinvoke v2.<io.netty.util.AbstractReferenceCounted: boolean release(int)>(v1);
return v3;
}
public java.lang.String getApplicationProtocol()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.lang.String v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.String applicationProtocol>;
return v1;
}
public java.lang.String getHandshakeApplicationProtocol()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.lang.String v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.String applicationProtocol>;
return v1;
}
public final synchronized javax.net.ssl.SSLSession getHandshakeSession()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
int[] v1;
io.netty.handler.ssl.OpenSslSession v5;
int v3, v4;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState v2;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$3: int[] $SwitchMap$io$netty$handler$ssl$ReferenceCountedOpenSslEngine$HandshakeState>;
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState handshakeState>;
v3 = virtualinvoke v2.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState: int ordinal()>();
v4 = v1[v3];
lookupswitch(v4)
{
case 1: goto label1;
case 2: goto label1;
default: goto label2;
};
label1:
return null;
label2:
v5 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.OpenSslSession session>;
return v5;
}
public final synchronized long sslPointer()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
long v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
return v1;
}
public final synchronized void shutdown()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
io.netty.handler.ssl.OpenSslEngineMap v2, v3;
long v4, v5;
boolean v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean destroyed>;
if v1 != 0 goto label2;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean destroyed> = 1;
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.OpenSslEngineMap engineMap>;
if v2 == null goto label1;
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.OpenSslEngineMap engineMap>;
v4 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
interfaceinvoke v3.<io.netty.handler.ssl.OpenSslEngineMap: io.netty.handler.ssl.ReferenceCountedOpenSslEngine remove(long)>(v4);
label1:
v5 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
staticinvoke <io.netty.internal.tcnative.SSL: void freeSSL(long)>(v5);
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO> = 0L;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl> = 0L;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean outboundClosed> = 1;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isInboundDone> = 1;
label2:
staticinvoke <io.netty.internal.tcnative.SSL: void clearError()>();
return;
}
private int writePlaintextData(java.nio.ByteBuffer, int)
{
java.lang.Throwable v17;
io.netty.buffer.ByteBufAllocator v11;
long v14, v15, v6, v7, v8;
java.nio.ByteBuffer v1;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
io.netty.buffer.ByteBuf v12;
int v10, v13, v16, v2, v3, v4, v9;
boolean v5;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: java.nio.ByteBuffer;
v2 := @parameter1: int;
v3 = virtualinvoke v1.<java.nio.ByteBuffer: int position()>();
v4 = virtualinvoke v1.<java.nio.ByteBuffer: int limit()>();
v5 = virtualinvoke v1.<java.nio.ByteBuffer: boolean isDirect()>();
if v5 == 0 goto label1;
v6 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v7 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long bufferAddress(java.nio.ByteBuffer)>(v1);
v8 = v7 + v3;
v9 = staticinvoke <io.netty.internal.tcnative.SSL: int writeToSSL(long,long,int)>(v6, v8, v2);
if v9 <= 0 goto label6;
v10 = v3 + v9;
virtualinvoke v1.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v10);
goto label6;
label1:
v11 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.buffer.ByteBufAllocator alloc>;
v12 = interfaceinvoke v11.<io.netty.buffer.ByteBufAllocator: io.netty.buffer.ByteBuf directBuffer(int)>(v2);
label2:
v13 = v3 + v2;
virtualinvoke v1.<java.nio.ByteBuffer: java.nio.ByteBuffer limit(int)>(v13);
virtualinvoke v12.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf setBytes(int,java.nio.ByteBuffer)>(0, v1);
virtualinvoke v1.<java.nio.ByteBuffer: java.nio.ByteBuffer limit(int)>(v4);
v14 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v15 = staticinvoke <io.netty.handler.ssl.OpenSsl: long memoryAddress(io.netty.buffer.ByteBuf)>(v12);
v9 = staticinvoke <io.netty.internal.tcnative.SSL: int writeToSSL(long,long,int)>(v14, v15, v2);
if v9 <= 0 goto label3;
v16 = v3 + v9;
virtualinvoke v1.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v16);
goto label4;
label3:
virtualinvoke v1.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v3);
label4:
virtualinvoke v12.<io.netty.buffer.ByteBuf: boolean release()>();
goto label6;
label5:
v17 := @caughtexception;
virtualinvoke v12.<io.netty.buffer.ByteBuf: boolean release()>();
throw v17;
label6:
return v9;
catch java.lang.Throwable from label2 to label4 with label5;
}
synchronized void bioSetFd(int)
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
int v1;
long v3;
boolean v2;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: int;
v2 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v2 != 0 goto label1;
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioSetFd(long,int)>(v3, v1);
label1:
return;
}
private io.netty.buffer.ByteBuf writeEncryptedData(java.nio.ByteBuffer, int) throws javax.net.ssl.SSLException
{
java.lang.Throwable v14;
io.netty.buffer.ByteBufAllocator v8;
long v12, v13, v5, v6, v7;
java.nio.ByteBuffer v1;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
io.netty.buffer.ByteBuf v9;
int v10, v11, v2, v3;
boolean v4;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: java.nio.ByteBuffer;
v2 := @parameter1: int;
v3 = virtualinvoke v1.<java.nio.ByteBuffer: int position()>();
v4 = virtualinvoke v1.<java.nio.ByteBuffer: boolean isDirect()>();
if v4 == 0 goto label1;
v5 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v6 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long bufferAddress(java.nio.ByteBuffer)>(v1);
v7 = v6 + v3;
staticinvoke <io.netty.internal.tcnative.SSL: void bioSetByteBuffer(long,long,int,boolean)>(v5, v7, v2, 0);
goto label5;
label1:
v8 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.buffer.ByteBufAllocator alloc>;
v9 = interfaceinvoke v8.<io.netty.buffer.ByteBufAllocator: io.netty.buffer.ByteBuf directBuffer(int)>(v2);
label2:
v10 = virtualinvoke v1.<java.nio.ByteBuffer: int limit()>();
v11 = v3 + v2;
virtualinvoke v1.<java.nio.ByteBuffer: java.nio.ByteBuffer limit(int)>(v11);
virtualinvoke v9.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf writeBytes(java.nio.ByteBuffer)>(v1);
virtualinvoke v1.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v3);
virtualinvoke v1.<java.nio.ByteBuffer: java.nio.ByteBuffer limit(int)>(v10);
v12 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v13 = staticinvoke <io.netty.handler.ssl.OpenSsl: long memoryAddress(io.netty.buffer.ByteBuf)>(v9);
staticinvoke <io.netty.internal.tcnative.SSL: void bioSetByteBuffer(long,long,int,boolean)>(v12, v13, v2, 0);
label3:
return v9;
label4:
v14 := @caughtexception;
virtualinvoke v9.<io.netty.buffer.ByteBuf: boolean release()>();
staticinvoke <io.netty.util.internal.PlatformDependent: void throwException(java.lang.Throwable)>(v14);
label5:
return null;
catch java.lang.Throwable from label2 to label3 with label4;
}
private int readPlaintextData(java.nio.ByteBuffer) throws javax.net.ssl.SSLException
{
java.lang.Throwable v21;
io.netty.buffer.ByteBufAllocator v15;
long v17, v18, v4, v5, v6;
java.nio.ByteBuffer v1;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
io.netty.buffer.ByteBuf v16;
int v10, v11, v12, v13, v14, v19, v2, v20, v7, v8, v9;
boolean v3;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: java.nio.ByteBuffer;
v2 = virtualinvoke v1.<java.nio.ByteBuffer: int position()>();
v3 = virtualinvoke v1.<java.nio.ByteBuffer: boolean isDirect()>();
if v3 == 0 goto label1;
v4 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v5 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long bufferAddress(java.nio.ByteBuffer)>(v1);
v6 = v5 + v2;
v7 = virtualinvoke v1.<java.nio.ByteBuffer: int limit()>();
v8 = v7 - v2;
v9 = staticinvoke <io.netty.internal.tcnative.SSL: int readFromSSL(long,long,int)>(v4, v6, v8);
if v9 <= 0 goto label5;
v10 = v2 + v9;
virtualinvoke v1.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v10);
goto label5;
label1:
v11 = virtualinvoke v1.<java.nio.ByteBuffer: int limit()>();
v12 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int maxEncryptedPacketLength0()>();
v13 = v11 - v2;
v14 = staticinvoke <java.lang.Math: int min(int,int)>(v12, v13);
v15 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.buffer.ByteBufAllocator alloc>;
v16 = interfaceinvoke v15.<io.netty.buffer.ByteBufAllocator: io.netty.buffer.ByteBuf directBuffer(int)>(v14);
label2:
v17 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v18 = staticinvoke <io.netty.handler.ssl.OpenSsl: long memoryAddress(io.netty.buffer.ByteBuf)>(v16);
v9 = staticinvoke <io.netty.internal.tcnative.SSL: int readFromSSL(long,long,int)>(v17, v18, v14);
if v9 <= 0 goto label3;
v19 = v2 + v9;
virtualinvoke v1.<java.nio.ByteBuffer: java.nio.ByteBuffer limit(int)>(v19);
v20 = virtualinvoke v16.<io.netty.buffer.ByteBuf: int readerIndex()>();
virtualinvoke v16.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf getBytes(int,java.nio.ByteBuffer)>(v20, v1);
virtualinvoke v1.<java.nio.ByteBuffer: java.nio.ByteBuffer limit(int)>(v11);
label3:
virtualinvoke v16.<io.netty.buffer.ByteBuf: boolean release()>();
goto label5;
label4:
v21 := @caughtexception;
virtualinvoke v16.<io.netty.buffer.ByteBuf: boolean release()>();
throw v21;
label5:
return v9;
catch java.lang.Throwable from label2 to label3 with label4;
}
final synchronized int maxWrapOverhead()
{
int v1;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int maxWrapOverhead>;
return v1;
}
final synchronized int maxEncryptedPacketLength()
{
int v1;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int maxEncryptedPacketLength0()>();
return v1;
}
final int maxEncryptedPacketLength0()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
int v1, v2, v3;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int maxWrapOverhead>;
v2 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int MAX_PLAINTEXT_LENGTH>;
v3 = v1 + v2;
return v3;
}
final int calculateMaxLengthForWrap(int, int)
{
long v5, v6, v7;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
int v1, v2, v3, v4;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: int;
v2 := @parameter1: int;
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int maxWrapBufferSize>;
v4 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int maxWrapOverhead>;
v5 = v4 * v2;
v6 = v1 + v5;
v7 = staticinvoke <java.lang.Math: long min(long,long)>(v3, v6);
return v7;
}
final synchronized int sslPending()
{
int v1;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int sslPending0()>();
return v1;
}
private void calculateMaxWrapOverhead()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
int v2, v4, v5;
long v1;
boolean v3;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v2 = staticinvoke <io.netty.internal.tcnative.SSL: int getMaxWrapOverhead(long)>(v1);
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int maxWrapOverhead> = v2;
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean jdkCompatibilityMode>;
if v3 == 0 goto label1;
v4 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int maxEncryptedPacketLength0()>();
goto label2;
label1:
v5 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int maxEncryptedPacketLength0()>();
v4 = v5 << 4;
label2:
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int maxWrapBufferSize> = v4;
return;
}
private int sslPending0()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
int v3;
long v4;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState v1, v2;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState handshakeState>;
v2 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState FINISHED>;
if v1 == v2 goto label1;
v3 = 0;
goto label2;
label1:
v4 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v3 = staticinvoke <io.netty.internal.tcnative.SSL: int sslPending(long)>(v4);
label2:
return v3;
}
private boolean isBytesAvailableEnoughForWrap(int, int, int)
{
long v5, v6;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
byte v7;
int v1, v2, v3, v4;
boolean v8;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: int;
v2 := @parameter1: int;
v3 := @parameter2: int;
v4 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int maxWrapOverhead>;
v5 = v4 * v3;
v6 = v1 - v5;
v7 = v6 cmp v2;
if v7 < 0 goto label1;
v8 = 1;
goto label2;
label1:
v8 = 0;
label2:
return v8;
}
public final javax.net.ssl.SSLEngineResult wrap(java.nio.ByteBuffer[], int, int, java.nio.ByteBuffer) throws javax.net.ssl.SSLException
{
javax.net.ssl.SSLEngineResult$Status v192, v234, v325, v36;
java.nio.ReadOnlyBufferException v12;
io.netty.buffer.ByteBufAllocator v25;
javax.net.ssl.SSLEngineResult$HandshakeStatus v109, v123, v135, v136, v139, v151, v193, v235, v270, v272, v275, v287, v300, v313, v340, v37, v49, v62, v76, v88, v97;
int v100, v101, v103, v104, v107, v112, v113, v115, v116, v119, v122, v126, v127, v129, v130, v133, v138, v142, v143, v145, v146, v149, v156, v157, v159, v160, v163, v169, v17, v170, v172, v173, v176, v178, v181, v182, v186, v187, v188, v189, v195, v196, v198, v199, v2, v202, v204, v210, v211, v213, v214, v217, v22, v223, v225, v226, v227, v228, v229, v230, v231, v232, v237, v238, v24, v240, v241, v244, v246, v248, v249, v251, v254, v255, v257, v258, v26, v261, v264, v265, v268, v269, v271, v274, v278, v279, v281, v282, v285, v29, v290, v291, v293, v294, v297, v299, v3, v303, v304, v306, v307, v31, v310, v312, v316, v317, v319, v320, v323, v328, v329, v33, v331, v332, v335, v337, v338, v339, v343, v344, v346, v347, v350, v355, v356, v358, v359, v362, v366, v367, v369, v370, v373, v39, v40, v42, v43, v46, v5, v52, v53, v55, v56, v59, v6, v65, v66, v68, v69, v7, v72, v75, v79, v80, v82, v83, v86, v9;
java.lang.AssertionError v105, v117, v131, v147, v161, v174, v200, v206, v215, v242, v259, v283, v295, v308, v321, v333, v348, v360, v371, v44, v57, v70, v84;
java.lang.String v10, v106, v118, v132, v148, v162, v175, v185, v201, v216, v243, v260, v284, v296, v309, v322, v334, v349, v361, v372, v45, v58, v71, v85;
boolean v102, v11, v114, v128, v13, v14, v144, v15, v152, v158, v165, v171, v179, v19, v190, v197, v205, v212, v224, v239, v250, v256, v266, v280, v292, v305, v318, v32, v330, v34, v345, v357, v368, v41, v54, v61, v67, v81;
io.netty.buffer.ByteBuf v18;
java.lang.IndexOutOfBoundsException v8;
long v111, v121, v125, v137, v141, v155, v166, v168, v194, v20, v207, v209, v21, v23, v236, v247, v253, v263, v267, v27, v273, v277, v28, v289, v30, v302, v315, v327, v342, v354, v365, v38, v48, v51, v64, v74, v78, v95, v99;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState v180, v89, v90, v91, v92, v93, v94;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.nio.ByteBuffer[] v1;
javax.net.ssl.SSLException v221, v352;
java.lang.Throwable v219, v220, v364, v375, v96;
javax.net.ssl.SSLEngineResult v110, v124, v140, v153, v154, v16, v167, v191, v208, v233, v252, v276, v288, v301, v314, v326, v341, v35, v353, v50, v63, v77, v98;
java.nio.ByteBuffer v108, v120, v134, v150, v164, v177, v183, v203, v218, v222, v245, v262, v286, v298, v311, v324, v336, v351, v363, v374, v4, v47, v60, v73, v87;
java.lang.IllegalArgumentException v184;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: java.nio.ByteBuffer[];
v2 := @parameter1: int;
v3 := @parameter2: int;
v4 := @parameter3: java.nio.ByteBuffer;
staticinvoke <io.netty.util.internal.ObjectUtil: java.lang.Object checkNotNullWithIAE(java.lang.Object,java.lang.String)>(v1, "srcs");
staticinvoke <io.netty.util.internal.ObjectUtil: java.lang.Object checkNotNullWithIAE(java.lang.Object,java.lang.String)>(v4, "dst");
v5 = lengthof v1;
if v2 >= v5 goto label001;
v6 = v2 + v3;
v7 = lengthof v1;
if v6 <= v7 goto label002;
label001:
v8 = new java.lang.IndexOutOfBoundsException;
v9 = lengthof v1;
v10 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (int,int,int)>(v2, v3, v9) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("offset: \u0001, length: \u0001 (expected: offset <= offset + length <= srcs.length (\u0001))");
specialinvoke v8.<java.lang.IndexOutOfBoundsException: void <init>(java.lang.String)>(v10);
throw v8;
label002:
v11 = virtualinvoke v4.<java.nio.ByteBuffer: boolean isReadOnly()>();
if v11 == 0 goto label003;
v12 = new java.nio.ReadOnlyBufferException;
specialinvoke v12.<java.nio.ReadOnlyBufferException: void <init>()>();
throw v12;
label003:
entermonitor v0;
label004:
v13 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isOutboundDone()>();
if v13 == 0 goto label009;
v14 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isInboundDone()>();
if v14 != 0 goto label005;
v15 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v15 == 0 goto label006;
label005:
v16 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult CLOSED_NOT_HANDSHAKING>;
goto label007;
label006:
v16 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult NEED_UNWRAP_CLOSED>;
label007:
exitmonitor v0;
label008:
return v16;
label009:
v17 = 0;
v18 = null;
label010:
v19 = virtualinvoke v4.<java.nio.ByteBuffer: boolean isDirect()>();
if v19 == 0 goto label011;
v20 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v21 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long bufferAddress(java.nio.ByteBuffer)>(v4);
v22 = virtualinvoke v4.<java.nio.ByteBuffer: int position()>();
v23 = v21 + v22;
v24 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
staticinvoke <io.netty.internal.tcnative.SSL: void bioSetByteBuffer(long,long,int,boolean)>(v20, v23, v24, 1);
goto label012;
label011:
v25 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.buffer.ByteBufAllocator alloc>;
v26 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
v18 = interfaceinvoke v25.<io.netty.buffer.ByteBufAllocator: io.netty.buffer.ByteBuf directBuffer(int)>(v26);
v27 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v28 = staticinvoke <io.netty.handler.ssl.OpenSsl: long memoryAddress(io.netty.buffer.ByteBuf)>(v18);
v29 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int writableBytes()>();
staticinvoke <io.netty.internal.tcnative.SSL: void bioSetByteBuffer(long,long,int,boolean)>(v27, v28, v29, 1);
label012:
v30 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v31 = staticinvoke <io.netty.internal.tcnative.SSL: int bioLengthByteBuffer(long)>(v30);
v32 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean outboundClosed>;
if v32 == 0 goto label036;
v33 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
v34 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isBytesAvailableEnoughForWrap(int,int,int)>(v33, 2, 1);
if v34 != 0 goto label018;
v35 = new javax.net.ssl.SSLEngineResult;
v36 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status BUFFER_OVERFLOW>;
v37 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult$HandshakeStatus getHandshakeStatus()>();
specialinvoke v35.<javax.net.ssl.SSLEngineResult: void <init>(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v36, v37, 0, 0);
label013:
v38 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v38);
if v18 != null goto label014;
v39 = virtualinvoke v4.<java.nio.ByteBuffer: int position()>();
v40 = v39 + 0;
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v40);
goto label016;
label014:
v41 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v41 != 0 goto label015;
v42 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readableBytes()>();
v43 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v42 <= v43 goto label015;
v44 = new java.lang.AssertionError;
v45 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.ByteBuffer,io.netty.buffer.ByteBuf)>(v4, v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The destination buffer \u0001 didn\'t have enough remaining space to hold the encrypted content in \u0001");
specialinvoke v44.<java.lang.AssertionError: void <init>(java.lang.Object)>(v45);
throw v44;
label015:
v46 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readerIndex()>();
v47 = virtualinvoke v18.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer internalNioBuffer(int,int)>(v46, 0);
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer put(java.nio.ByteBuffer)>(v47);
virtualinvoke v18.<io.netty.buffer.ByteBuf: boolean release()>();
label016:
exitmonitor v0;
label017:
return v35;
label018:
v48 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v17 = staticinvoke <io.netty.internal.tcnative.SSL: int bioFlushByteBuffer(long)>(v48);
if v17 > 0 goto label024;
v49 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NOT_HANDSHAKING>;
v50 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResultMayFinishHandshake(javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v49, 0, 0);
label019:
v51 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v51);
if v18 != null goto label020;
v52 = virtualinvoke v4.<java.nio.ByteBuffer: int position()>();
v53 = v52 + v17;
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v53);
goto label022;
label020:
v54 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v54 != 0 goto label021;
v55 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readableBytes()>();
v56 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v55 <= v56 goto label021;
v57 = new java.lang.AssertionError;
v58 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.ByteBuffer,io.netty.buffer.ByteBuf)>(v4, v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The destination buffer \u0001 didn\'t have enough remaining space to hold the encrypted content in \u0001");
specialinvoke v57.<java.lang.AssertionError: void <init>(java.lang.Object)>(v58);
throw v57;
label021:
v59 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readerIndex()>();
v60 = virtualinvoke v18.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer internalNioBuffer(int,int)>(v59, v17);
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer put(java.nio.ByteBuffer)>(v60);
virtualinvoke v18.<io.netty.buffer.ByteBuf: boolean release()>();
label022:
exitmonitor v0;
label023:
return v50;
label024:
v61 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean doSSLShutdown()>();
if v61 != 0 goto label030;
v62 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NOT_HANDSHAKING>;
v63 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResultMayFinishHandshake(javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v62, 0, v17);
label025:
v64 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v64);
if v18 != null goto label026;
v65 = virtualinvoke v4.<java.nio.ByteBuffer: int position()>();
v66 = v65 + v17;
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v66);
goto label028;
label026:
v67 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v67 != 0 goto label027;
v68 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readableBytes()>();
v69 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v68 <= v69 goto label027;
v70 = new java.lang.AssertionError;
v71 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.ByteBuffer,io.netty.buffer.ByteBuf)>(v4, v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The destination buffer \u0001 didn\'t have enough remaining space to hold the encrypted content in \u0001");
specialinvoke v70.<java.lang.AssertionError: void <init>(java.lang.Object)>(v71);
throw v70;
label027:
v72 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readerIndex()>();
v73 = virtualinvoke v18.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer internalNioBuffer(int,int)>(v72, v17);
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer put(java.nio.ByteBuffer)>(v73);
virtualinvoke v18.<io.netty.buffer.ByteBuf: boolean release()>();
label028:
exitmonitor v0;
label029:
return v63;
label030:
v74 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v75 = staticinvoke <io.netty.internal.tcnative.SSL: int bioLengthByteBuffer(long)>(v74);
v17 = v31 - v75;
v76 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_WRAP>;
v77 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResultMayFinishHandshake(javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v76, 0, v17);
label031:
v78 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v78);
if v18 != null goto label032;
v79 = virtualinvoke v4.<java.nio.ByteBuffer: int position()>();
v80 = v79 + v17;
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v80);
goto label034;
label032:
v81 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v81 != 0 goto label033;
v82 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readableBytes()>();
v83 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v82 <= v83 goto label033;
v84 = new java.lang.AssertionError;
v85 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.ByteBuffer,io.netty.buffer.ByteBuf)>(v4, v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The destination buffer \u0001 didn\'t have enough remaining space to hold the encrypted content in \u0001");
specialinvoke v84.<java.lang.AssertionError: void <init>(java.lang.Object)>(v85);
throw v84;
label033:
v86 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readerIndex()>();
v87 = virtualinvoke v18.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer internalNioBuffer(int,int)>(v86, v17);
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer put(java.nio.ByteBuffer)>(v87);
virtualinvoke v18.<io.netty.buffer.ByteBuf: boolean release()>();
label034:
exitmonitor v0;
label035:
return v77;
label036:
v88 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NOT_HANDSHAKING>;
v89 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState handshakeState>;
v90 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState handshakeState>;
v91 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState FINISHED>;
if v90 == v91 goto label078;
v92 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState handshakeState>;
v93 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState STARTED_EXPLICITLY>;
if v92 == v93 goto label037;
v94 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState STARTED_IMPLICITLY>;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState handshakeState> = v94;
label037:
v95 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v17 = staticinvoke <io.netty.internal.tcnative.SSL: int bioFlushByteBuffer(long)>(v95);
v96 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.Throwable pendingException>;
if v96 == null goto label049;
if v17 <= 0 goto label043;
v97 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_WRAP>;
v98 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResult(javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v97, 0, v17);
label038:
v99 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v99);
if v18 != null goto label039;
v100 = virtualinvoke v4.<java.nio.ByteBuffer: int position()>();
v101 = v100 + v17;
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v101);
goto label041;
label039:
v102 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v102 != 0 goto label040;
v103 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readableBytes()>();
v104 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v103 <= v104 goto label040;
v105 = new java.lang.AssertionError;
v106 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.ByteBuffer,io.netty.buffer.ByteBuf)>(v4, v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The destination buffer \u0001 didn\'t have enough remaining space to hold the encrypted content in \u0001");
specialinvoke v105.<java.lang.AssertionError: void <init>(java.lang.Object)>(v106);
throw v105;
label040:
v107 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readerIndex()>();
v108 = virtualinvoke v18.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer internalNioBuffer(int,int)>(v107, v17);
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer put(java.nio.ByteBuffer)>(v108);
virtualinvoke v18.<io.netty.buffer.ByteBuf: boolean release()>();
label041:
exitmonitor v0;
label042:
return v98;
label043:
v109 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult$HandshakeStatus handshakeException()>();
v110 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResult(javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v109, 0, 0);
label044:
v111 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v111);
if v18 != null goto label045;
v112 = virtualinvoke v4.<java.nio.ByteBuffer: int position()>();
v113 = v112 + v17;
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v113);
goto label047;
label045:
v114 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v114 != 0 goto label046;
v115 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readableBytes()>();
v116 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v115 <= v116 goto label046;
v117 = new java.lang.AssertionError;
v118 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.ByteBuffer,io.netty.buffer.ByteBuf)>(v4, v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The destination buffer \u0001 didn\'t have enough remaining space to hold the encrypted content in \u0001");
specialinvoke v117.<java.lang.AssertionError: void <init>(java.lang.Object)>(v118);
throw v117;
label046:
v119 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readerIndex()>();
v120 = virtualinvoke v18.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer internalNioBuffer(int,int)>(v119, v17);
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer put(java.nio.ByteBuffer)>(v120);
virtualinvoke v18.<io.netty.buffer.ByteBuf: boolean release()>();
label047:
exitmonitor v0;
label048:
return v110;
label049:
v88 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult$HandshakeStatus handshake()>();
v121 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v122 = staticinvoke <io.netty.internal.tcnative.SSL: int bioLengthByteBuffer(long)>(v121);
v17 = v31 - v122;
v123 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_TASK>;
if v88 != v123 goto label055;
v124 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResult(javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v88, 0, v17);
label050:
v125 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v125);
if v18 != null goto label051;
v126 = virtualinvoke v4.<java.nio.ByteBuffer: int position()>();
v127 = v126 + v17;
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v127);
goto label053;
label051:
v128 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v128 != 0 goto label052;
v129 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readableBytes()>();
v130 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v129 <= v130 goto label052;
v131 = new java.lang.AssertionError;
v132 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.ByteBuffer,io.netty.buffer.ByteBuf)>(v4, v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The destination buffer \u0001 didn\'t have enough remaining space to hold the encrypted content in \u0001");
specialinvoke v131.<java.lang.AssertionError: void <init>(java.lang.Object)>(v132);
throw v131;
label052:
v133 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readerIndex()>();
v134 = virtualinvoke v18.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer internalNioBuffer(int,int)>(v133, v17);
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer put(java.nio.ByteBuffer)>(v134);
virtualinvoke v18.<io.netty.buffer.ByteBuf: boolean release()>();
label053:
exitmonitor v0;
label054:
return v124;
label055:
if v17 <= 0 goto label064;
v135 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus FINISHED>;
if v88 == v135 goto label057;
if v17 != v31 goto label056;
v136 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_WRAP>;
goto label058;
label056:
v137 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v138 = staticinvoke <io.netty.internal.tcnative.SSL: int bioLengthNonApplication(long)>(v137);
v136 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult$HandshakeStatus getHandshakeStatus(int)>(v138);
goto label058;
label057:
v136 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus FINISHED>;
label058:
v139 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult$HandshakeStatus mayFinishHandshake(javax.net.ssl.SSLEngineResult$HandshakeStatus)>(v136);
v140 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResult(javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v139, 0, v17);
label059:
v141 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v141);
if v18 != null goto label060;
v142 = virtualinvoke v4.<java.nio.ByteBuffer: int position()>();
v143 = v142 + v17;
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v143);
goto label062;
label060:
v144 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v144 != 0 goto label061;
v145 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readableBytes()>();
v146 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v145 <= v146 goto label061;
v147 = new java.lang.AssertionError;
v148 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.ByteBuffer,io.netty.buffer.ByteBuf)>(v4, v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The destination buffer \u0001 didn\'t have enough remaining space to hold the encrypted content in \u0001");
specialinvoke v147.<java.lang.AssertionError: void <init>(java.lang.Object)>(v148);
throw v147;
label061:
v149 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readerIndex()>();
v150 = virtualinvoke v18.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer internalNioBuffer(int,int)>(v149, v17);
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer put(java.nio.ByteBuffer)>(v150);
virtualinvoke v18.<io.netty.buffer.ByteBuf: boolean release()>();
label062:
exitmonitor v0;
label063:
return v140;
label064:
v151 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_UNWRAP>;
if v88 != v151 goto label072;
v152 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isOutboundDone()>();
if v152 == 0 goto label065;
v153 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult NEED_UNWRAP_CLOSED>;
goto label066;
label065:
v153 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult NEED_UNWRAP_OK>;
label066:
v154 = v153;
label067:
v155 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v155);
if v18 != null goto label068;
v156 = virtualinvoke v4.<java.nio.ByteBuffer: int position()>();
v157 = v156 + v17;
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v157);
goto label070;
label068:
v158 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v158 != 0 goto label069;
v159 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readableBytes()>();
v160 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v159 <= v160 goto label069;
v161 = new java.lang.AssertionError;
v162 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.ByteBuffer,io.netty.buffer.ByteBuf)>(v4, v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The destination buffer \u0001 didn\'t have enough remaining space to hold the encrypted content in \u0001");
specialinvoke v161.<java.lang.AssertionError: void <init>(java.lang.Object)>(v162);
throw v161;
label069:
v163 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readerIndex()>();
v164 = virtualinvoke v18.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer internalNioBuffer(int,int)>(v163, v17);
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer put(java.nio.ByteBuffer)>(v164);
virtualinvoke v18.<io.netty.buffer.ByteBuf: boolean release()>();
label070:
exitmonitor v0;
label071:
return v154;
label072:
v165 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean outboundClosed>;
if v165 == 0 goto label078;
v166 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v17 = staticinvoke <io.netty.internal.tcnative.SSL: int bioFlushByteBuffer(long)>(v166);
v167 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResultMayFinishHandshake(javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v88, 0, v17);
label073:
v168 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v168);
if v18 != null goto label074;
v169 = virtualinvoke v4.<java.nio.ByteBuffer: int position()>();
v170 = v169 + v17;
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v170);
goto label076;
label074:
v171 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v171 != 0 goto label075;
v172 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readableBytes()>();
v173 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v172 <= v173 goto label075;
v174 = new java.lang.AssertionError;
v175 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.ByteBuffer,io.netty.buffer.ByteBuf)>(v4, v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The destination buffer \u0001 didn\'t have enough remaining space to hold the encrypted content in \u0001");
specialinvoke v174.<java.lang.AssertionError: void <init>(java.lang.Object)>(v175);
throw v174;
label075:
v176 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readerIndex()>();
v177 = virtualinvoke v18.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer internalNioBuffer(int,int)>(v176, v17);
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer put(java.nio.ByteBuffer)>(v177);
virtualinvoke v18.<io.netty.buffer.ByteBuf: boolean release()>();
label076:
exitmonitor v0;
label077:
return v167;
label078:
v178 = v2 + v3;
v179 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean jdkCompatibilityMode>;
if v179 != 0 goto label079;
v180 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState FINISHED>;
if v89 == v180 goto label090;
label079:
v181 = 0;
v182 = v2;
label080:
if v182 >= v178 goto label084;
v183 = v1[v182];
if v183 != null goto label081;
v184 = new java.lang.IllegalArgumentException;
v185 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (int)>(v182) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("srcs[\u0001] is null");
specialinvoke v184.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(v185);
throw v184;
label081:
v186 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int MAX_PLAINTEXT_LENGTH>;
if v181 == v186 goto label083;
v187 = virtualinvoke v183.<java.nio.ByteBuffer: int remaining()>();
v181 = v181 + v187;
v188 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int MAX_PLAINTEXT_LENGTH>;
if v181 > v188 goto label082;
if v181 >= 0 goto label083;
label082:
v181 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int MAX_PLAINTEXT_LENGTH>;
label083:
v182 = v182 + 1;
goto label080;
label084:
v189 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
v190 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isBytesAvailableEnoughForWrap(int,int,int)>(v189, v181, 1);
if v190 != 0 goto label090;
v191 = new javax.net.ssl.SSLEngineResult;
v192 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status BUFFER_OVERFLOW>;
v193 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult$HandshakeStatus getHandshakeStatus()>();
specialinvoke v191.<javax.net.ssl.SSLEngineResult: void <init>(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v192, v193, 0, 0);
label085:
v194 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v194);
if v18 != null goto label086;
v195 = virtualinvoke v4.<java.nio.ByteBuffer: int position()>();
v196 = v195 + v17;
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v196);
goto label088;
label086:
v197 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v197 != 0 goto label087;
v198 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readableBytes()>();
v199 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v198 <= v199 goto label087;
v200 = new java.lang.AssertionError;
v201 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.ByteBuffer,io.netty.buffer.ByteBuf)>(v4, v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The destination buffer \u0001 didn\'t have enough remaining space to hold the encrypted content in \u0001");
specialinvoke v200.<java.lang.AssertionError: void <init>(java.lang.Object)>(v201);
throw v200;
label087:
v202 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readerIndex()>();
v203 = virtualinvoke v18.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer internalNioBuffer(int,int)>(v202, v17);
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer put(java.nio.ByteBuffer)>(v203);
virtualinvoke v18.<io.netty.buffer.ByteBuf: boolean release()>();
label088:
exitmonitor v0;
label089:
return v191;
label090:
v204 = 0;
v205 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v205 != 0 goto label091;
if v17 == 0 goto label091;
v206 = new java.lang.AssertionError;
specialinvoke v206.<java.lang.AssertionError: void <init>()>();
throw v206;
label091:
v207 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v17 = staticinvoke <io.netty.internal.tcnative.SSL: int bioFlushByteBuffer(long)>(v207);
if v17 <= 0 goto label097;
v208 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResultMayFinishHandshake(javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v88, 0, v17);
label092:
v209 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v209);
if v18 != null goto label093;
v210 = virtualinvoke v4.<java.nio.ByteBuffer: int position()>();
v211 = v210 + v17;
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v211);
goto label095;
label093:
v212 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v212 != 0 goto label094;
v213 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readableBytes()>();
v214 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v213 <= v214 goto label094;
v215 = new java.lang.AssertionError;
v216 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.ByteBuffer,io.netty.buffer.ByteBuf)>(v4, v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The destination buffer \u0001 didn\'t have enough remaining space to hold the encrypted content in \u0001");
specialinvoke v215.<java.lang.AssertionError: void <init>(java.lang.Object)>(v216);
throw v215;
label094:
v217 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readerIndex()>();
v218 = virtualinvoke v18.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer internalNioBuffer(int,int)>(v217, v17);
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer put(java.nio.ByteBuffer)>(v218);
virtualinvoke v18.<io.netty.buffer.ByteBuf: boolean release()>();
label095:
exitmonitor v0;
label096:
return v208;
label097:
v219 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.Throwable pendingException>;
if v219 == null goto label098;
v220 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.Throwable pendingException>;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.Throwable pendingException> = null;
virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void shutdown()>();
v221 = new javax.net.ssl.SSLException;
specialinvoke v221.<javax.net.ssl.SSLException: void <init>(java.lang.Throwable)>(v220);
throw v221;
label098:
if v2 >= v178 goto label155;
v222 = v1[v2];
v223 = virtualinvoke v222.<java.nio.ByteBuffer: int remaining()>();
if v223 == 0 goto label154;
v224 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean jdkCompatibilityMode>;
if v224 == 0 goto label099;
v225 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int MAX_PLAINTEXT_LENGTH>;
v226 = v225 - v204;
v227 = staticinvoke <java.lang.Math: int min(int,int)>(v223, v226);
v228 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int writePlaintextData(java.nio.ByteBuffer,int)>(v222, v227);
goto label106;
label099:
v229 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
v230 = v229 - v17;
v231 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int maxWrapOverhead>;
v232 = v230 - v231;
if v232 > 0 goto label105;
v233 = new javax.net.ssl.SSLEngineResult;
v234 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status BUFFER_OVERFLOW>;
v235 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult$HandshakeStatus getHandshakeStatus()>();
specialinvoke v233.<javax.net.ssl.SSLEngineResult: void <init>(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v234, v235, v204, v17);
label100:
v236 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v236);
if v18 != null goto label101;
v237 = virtualinvoke v4.<java.nio.ByteBuffer: int position()>();
v238 = v237 + v17;
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v238);
goto label103;
label101:
v239 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v239 != 0 goto label102;
v240 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readableBytes()>();
v241 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v240 <= v241 goto label102;
v242 = new java.lang.AssertionError;
v243 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.ByteBuffer,io.netty.buffer.ByteBuf)>(v4, v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The destination buffer \u0001 didn\'t have enough remaining space to hold the encrypted content in \u0001");
specialinvoke v242.<java.lang.AssertionError: void <init>(java.lang.Object)>(v243);
throw v242;
label102:
v244 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readerIndex()>();
v245 = virtualinvoke v18.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer internalNioBuffer(int,int)>(v244, v17);
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer put(java.nio.ByteBuffer)>(v245);
virtualinvoke v18.<io.netty.buffer.ByteBuf: boolean release()>();
label103:
exitmonitor v0;
label104:
return v233;
label105:
v246 = staticinvoke <java.lang.Math: int min(int,int)>(v223, v232);
v228 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int writePlaintextData(java.nio.ByteBuffer,int)>(v222, v246);
label106:
v247 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v248 = staticinvoke <io.netty.internal.tcnative.SSL: int bioLengthByteBuffer(long)>(v247);
v249 = v31 - v248;
v17 = v17 + v249;
v31 = v248;
if v228 <= 0 goto label113;
v204 = v204 + v228;
v250 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean jdkCompatibilityMode>;
if v250 != 0 goto label107;
v251 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v17 != v251 goto label154;
label107:
v252 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResultMayFinishHandshake(javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v88, v204, v17);
label108:
v253 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v253);
if v18 != null goto label109;
v254 = virtualinvoke v4.<java.nio.ByteBuffer: int position()>();
v255 = v254 + v17;
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v255);
goto label111;
label109:
v256 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v256 != 0 goto label110;
v257 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readableBytes()>();
v258 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v257 <= v258 goto label110;
v259 = new java.lang.AssertionError;
v260 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.ByteBuffer,io.netty.buffer.ByteBuf)>(v4, v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The destination buffer \u0001 didn\'t have enough remaining space to hold the encrypted content in \u0001");
specialinvoke v259.<java.lang.AssertionError: void <init>(java.lang.Object)>(v260);
throw v259;
label110:
v261 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readerIndex()>();
v262 = virtualinvoke v18.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer internalNioBuffer(int,int)>(v261, v17);
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer put(java.nio.ByteBuffer)>(v262);
virtualinvoke v18.<io.netty.buffer.ByteBuf: boolean release()>();
label111:
exitmonitor v0;
label112:
return v252;
label113:
v263 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v264 = staticinvoke <io.netty.internal.tcnative.SSL: int getError(long,int)>(v263, v228);
v265 = <io.netty.internal.tcnative.SSL: int SSL_ERROR_ZERO_RETURN>;
if v264 != v265 goto label128;
v266 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean receivedShutdown>;
if v266 != 0 goto label122;
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void closeAll()>();
v267 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v268 = staticinvoke <io.netty.internal.tcnative.SSL: int bioLengthByteBuffer(long)>(v267);
v269 = v248 - v268;
v17 = v17 + v269;
v270 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus FINISHED>;
if v88 == v270 goto label115;
v271 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v17 != v271 goto label114;
v272 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_WRAP>;
goto label116;
label114:
v273 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v274 = staticinvoke <io.netty.internal.tcnative.SSL: int bioLengthNonApplication(long)>(v273);
v272 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult$HandshakeStatus getHandshakeStatus(int)>(v274);
goto label116;
label115:
v272 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus FINISHED>;
label116:
v275 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult$HandshakeStatus mayFinishHandshake(javax.net.ssl.SSLEngineResult$HandshakeStatus)>(v272);
v276 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResult(javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v275, v204, v17);
label117:
v277 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v277);
if v18 != null goto label118;
v278 = virtualinvoke v4.<java.nio.ByteBuffer: int position()>();
v279 = v278 + v17;
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v279);
goto label120;
label118:
v280 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v280 != 0 goto label119;
v281 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readableBytes()>();
v282 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v281 <= v282 goto label119;
v283 = new java.lang.AssertionError;
v284 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.ByteBuffer,io.netty.buffer.ByteBuf)>(v4, v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The destination buffer \u0001 didn\'t have enough remaining space to hold the encrypted content in \u0001");
specialinvoke v283.<java.lang.AssertionError: void <init>(java.lang.Object)>(v284);
throw v283;
label119:
v285 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readerIndex()>();
v286 = virtualinvoke v18.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer internalNioBuffer(int,int)>(v285, v17);
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer put(java.nio.ByteBuffer)>(v286);
virtualinvoke v18.<io.netty.buffer.ByteBuf: boolean release()>();
label120:
exitmonitor v0;
label121:
return v276;
label122:
v287 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NOT_HANDSHAKING>;
v288 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResult(javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v287, v204, v17);
label123:
v289 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v289);
if v18 != null goto label124;
v290 = virtualinvoke v4.<java.nio.ByteBuffer: int position()>();
v291 = v290 + v17;
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v291);
goto label126;
label124:
v292 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v292 != 0 goto label125;
v293 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readableBytes()>();
v294 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v293 <= v294 goto label125;
v295 = new java.lang.AssertionError;
v296 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.ByteBuffer,io.netty.buffer.ByteBuf)>(v4, v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The destination buffer \u0001 didn\'t have enough remaining space to hold the encrypted content in \u0001");
specialinvoke v295.<java.lang.AssertionError: void <init>(java.lang.Object)>(v296);
throw v295;
label125:
v297 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readerIndex()>();
v298 = virtualinvoke v18.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer internalNioBuffer(int,int)>(v297, v17);
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer put(java.nio.ByteBuffer)>(v298);
virtualinvoke v18.<io.netty.buffer.ByteBuf: boolean release()>();
label126:
exitmonitor v0;
label127:
return v288;
label128:
v299 = <io.netty.internal.tcnative.SSL: int SSL_ERROR_WANT_READ>;
if v264 != v299 goto label134;
v300 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_UNWRAP>;
v301 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResult(javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v300, v204, v17);
label129:
v302 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v302);
if v18 != null goto label130;
v303 = virtualinvoke v4.<java.nio.ByteBuffer: int position()>();
v304 = v303 + v17;
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v304);
goto label132;
label130:
v305 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v305 != 0 goto label131;
v306 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readableBytes()>();
v307 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v306 <= v307 goto label131;
v308 = new java.lang.AssertionError;
v309 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.ByteBuffer,io.netty.buffer.ByteBuf)>(v4, v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The destination buffer \u0001 didn\'t have enough remaining space to hold the encrypted content in \u0001");
specialinvoke v308.<java.lang.AssertionError: void <init>(java.lang.Object)>(v309);
throw v308;
label131:
v310 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readerIndex()>();
v311 = virtualinvoke v18.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer internalNioBuffer(int,int)>(v310, v17);
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer put(java.nio.ByteBuffer)>(v311);
virtualinvoke v18.<io.netty.buffer.ByteBuf: boolean release()>();
label132:
exitmonitor v0;
label133:
return v301;
label134:
v312 = <io.netty.internal.tcnative.SSL: int SSL_ERROR_WANT_WRITE>;
if v264 != v312 goto label146;
if v17 <= 0 goto label140;
v313 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_WRAP>;
v314 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResult(javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v313, v204, v17);
label135:
v315 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v315);
if v18 != null goto label136;
v316 = virtualinvoke v4.<java.nio.ByteBuffer: int position()>();
v317 = v316 + v17;
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v317);
goto label138;
label136:
v318 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v318 != 0 goto label137;
v319 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readableBytes()>();
v320 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v319 <= v320 goto label137;
v321 = new java.lang.AssertionError;
v322 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.ByteBuffer,io.netty.buffer.ByteBuf)>(v4, v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The destination buffer \u0001 didn\'t have enough remaining space to hold the encrypted content in \u0001");
specialinvoke v321.<java.lang.AssertionError: void <init>(java.lang.Object)>(v322);
throw v321;
label137:
v323 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readerIndex()>();
v324 = virtualinvoke v18.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer internalNioBuffer(int,int)>(v323, v17);
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer put(java.nio.ByteBuffer)>(v324);
virtualinvoke v18.<io.netty.buffer.ByteBuf: boolean release()>();
label138:
exitmonitor v0;
label139:
return v314;
label140:
v325 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status BUFFER_OVERFLOW>;
v326 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResult(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v325, v88, v204, v17);
label141:
v327 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v327);
if v18 != null goto label142;
v328 = virtualinvoke v4.<java.nio.ByteBuffer: int position()>();
v329 = v328 + v17;
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v329);
goto label144;
label142:
v330 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v330 != 0 goto label143;
v331 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readableBytes()>();
v332 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v331 <= v332 goto label143;
v333 = new java.lang.AssertionError;
v334 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.ByteBuffer,io.netty.buffer.ByteBuf)>(v4, v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The destination buffer \u0001 didn\'t have enough remaining space to hold the encrypted content in \u0001");
specialinvoke v333.<java.lang.AssertionError: void <init>(java.lang.Object)>(v334);
throw v333;
label143:
v335 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readerIndex()>();
v336 = virtualinvoke v18.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer internalNioBuffer(int,int)>(v335, v17);
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer put(java.nio.ByteBuffer)>(v336);
virtualinvoke v18.<io.netty.buffer.ByteBuf: boolean release()>();
label144:
exitmonitor v0;
label145:
return v326;
label146:
v337 = <io.netty.internal.tcnative.SSL: int SSL_ERROR_WANT_X509_LOOKUP>;
if v264 == v337 goto label147;
v338 = <io.netty.internal.tcnative.SSL: int SSL_ERROR_WANT_CERTIFICATE_VERIFY>;
if v264 == v338 goto label147;
v339 = <io.netty.internal.tcnative.SSL: int SSL_ERROR_WANT_PRIVATE_KEY_OPERATION>;
if v264 != v339 goto label153;
label147:
v340 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_TASK>;
v341 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResult(javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v340, v204, v17);
label148:
v342 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v342);
if v18 != null goto label149;
v343 = virtualinvoke v4.<java.nio.ByteBuffer: int position()>();
v344 = v343 + v17;
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v344);
goto label151;
label149:
v345 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v345 != 0 goto label150;
v346 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readableBytes()>();
v347 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v346 <= v347 goto label150;
v348 = new java.lang.AssertionError;
v349 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.ByteBuffer,io.netty.buffer.ByteBuf)>(v4, v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The destination buffer \u0001 didn\'t have enough remaining space to hold the encrypted content in \u0001");
specialinvoke v348.<java.lang.AssertionError: void <init>(java.lang.Object)>(v349);
throw v348;
label150:
v350 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readerIndex()>();
v351 = virtualinvoke v18.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer internalNioBuffer(int,int)>(v350, v17);
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer put(java.nio.ByteBuffer)>(v351);
virtualinvoke v18.<io.netty.buffer.ByteBuf: boolean release()>();
label151:
exitmonitor v0;
label152:
return v341;
label153:
v352 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLException shutdownWithError(java.lang.String,int)>("SSL_write", v264);
throw v352;
label154:
v2 = v2 + 1;
goto label098;
label155:
v353 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResultMayFinishHandshake(javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v88, v204, v17);
label156:
v354 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v354);
if v18 != null goto label157;
v355 = virtualinvoke v4.<java.nio.ByteBuffer: int position()>();
v356 = v355 + v17;
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v356);
goto label159;
label157:
v357 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v357 != 0 goto label158;
v358 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readableBytes()>();
v359 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v358 <= v359 goto label158;
v360 = new java.lang.AssertionError;
v361 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.ByteBuffer,io.netty.buffer.ByteBuf)>(v4, v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The destination buffer \u0001 didn\'t have enough remaining space to hold the encrypted content in \u0001");
specialinvoke v360.<java.lang.AssertionError: void <init>(java.lang.Object)>(v361);
throw v360;
label158:
v362 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readerIndex()>();
v363 = virtualinvoke v18.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer internalNioBuffer(int,int)>(v362, v17);
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer put(java.nio.ByteBuffer)>(v363);
virtualinvoke v18.<io.netty.buffer.ByteBuf: boolean release()>();
label159:
exitmonitor v0;
label160:
return v353;
label161:
v364 := @caughtexception;
v365 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v365);
if v18 != null goto label162;
v366 = virtualinvoke v4.<java.nio.ByteBuffer: int position()>();
v367 = v366 + v17;
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v367);
goto label164;
label162:
v368 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v368 != 0 goto label163;
v369 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readableBytes()>();
v370 = virtualinvoke v4.<java.nio.ByteBuffer: int remaining()>();
if v369 <= v370 goto label163;
v371 = new java.lang.AssertionError;
v372 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.ByteBuffer,io.netty.buffer.ByteBuf)>(v4, v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The destination buffer \u0001 didn\'t have enough remaining space to hold the encrypted content in \u0001");
specialinvoke v371.<java.lang.AssertionError: void <init>(java.lang.Object)>(v372);
throw v371;
label163:
v373 = virtualinvoke v18.<io.netty.buffer.ByteBuf: int readerIndex()>();
v374 = virtualinvoke v18.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer internalNioBuffer(int,int)>(v373, v17);
virtualinvoke v4.<java.nio.ByteBuffer: java.nio.ByteBuffer put(java.nio.ByteBuffer)>(v374);
virtualinvoke v18.<io.netty.buffer.ByteBuf: boolean release()>();
label164:
throw v364;
label165:
v375 := @caughtexception;
exitmonitor v0;
throw v375;
catch java.lang.Throwable from label010 to label013 with label161;
catch java.lang.Throwable from label018 to label019 with label161;
catch java.lang.Throwable from label024 to label025 with label161;
catch java.lang.Throwable from label030 to label031 with label161;
catch java.lang.Throwable from label036 to label038 with label161;
catch java.lang.Throwable from label043 to label044 with label161;
catch java.lang.Throwable from label049 to label050 with label161;
catch java.lang.Throwable from label055 to label059 with label161;
catch java.lang.Throwable from label064 to label067 with label161;
catch java.lang.Throwable from label072 to label073 with label161;
catch java.lang.Throwable from label078 to label085 with label161;
catch java.lang.Throwable from label090 to label092 with label161;
catch java.lang.Throwable from label097 to label100 with label161;
catch java.lang.Throwable from label105 to label108 with label161;
catch java.lang.Throwable from label113 to label117 with label161;
catch java.lang.Throwable from label122 to label123 with label161;
catch java.lang.Throwable from label128 to label129 with label161;
catch java.lang.Throwable from label134 to label135 with label161;
catch java.lang.Throwable from label140 to label141 with label161;
catch java.lang.Throwable from label146 to label148 with label161;
catch java.lang.Throwable from label153 to label156 with label161;
catch java.lang.Throwable from label004 to label008 with label165;
catch java.lang.Throwable from label009 to label017 with label165;
catch java.lang.Throwable from label018 to label023 with label165;
catch java.lang.Throwable from label024 to label029 with label165;
catch java.lang.Throwable from label030 to label035 with label165;
catch java.lang.Throwable from label036 to label042 with label165;
catch java.lang.Throwable from label043 to label048 with label165;
catch java.lang.Throwable from label049 to label054 with label165;
catch java.lang.Throwable from label055 to label063 with label165;
catch java.lang.Throwable from label064 to label071 with label165;
catch java.lang.Throwable from label072 to label077 with label165;
catch java.lang.Throwable from label078 to label089 with label165;
catch java.lang.Throwable from label090 to label096 with label165;
catch java.lang.Throwable from label097 to label104 with label165;
catch java.lang.Throwable from label105 to label112 with label165;
catch java.lang.Throwable from label113 to label121 with label165;
catch java.lang.Throwable from label122 to label127 with label165;
catch java.lang.Throwable from label128 to label133 with label165;
catch java.lang.Throwable from label134 to label139 with label165;
catch java.lang.Throwable from label140 to label145 with label165;
catch java.lang.Throwable from label146 to label152 with label165;
catch java.lang.Throwable from label153 to label160 with label165;
}
private javax.net.ssl.SSLEngineResult newResult(javax.net.ssl.SSLEngineResult$HandshakeStatus, int, int)
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
javax.net.ssl.SSLEngineResult v5;
int v2, v3;
javax.net.ssl.SSLEngineResult$HandshakeStatus v1;
javax.net.ssl.SSLEngineResult$Status v4;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: javax.net.ssl.SSLEngineResult$HandshakeStatus;
v2 := @parameter1: int;
v3 := @parameter2: int;
v4 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status OK>;
v5 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResult(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v4, v1, v2, v3);
return v5;
}
private javax.net.ssl.SSLEngineResult newResult(javax.net.ssl.SSLEngineResult$Status, javax.net.ssl.SSLEngineResult$HandshakeStatus, int, int)
{
javax.net.ssl.SSLEngineResult$HandshakeStatus v2, v9;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
javax.net.ssl.SSLEngineResult v10, v7;
int v3, v4;
javax.net.ssl.SSLEngineResult$Status v1, v8;
boolean v5, v6;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: javax.net.ssl.SSLEngineResult$Status;
v2 := @parameter1: javax.net.ssl.SSLEngineResult$HandshakeStatus;
v3 := @parameter2: int;
v4 := @parameter3: int;
v5 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isOutboundDone()>();
if v5 == 0 goto label2;
v6 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isInboundDone()>();
if v6 == 0 goto label1;
v2 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NOT_HANDSHAKING>;
virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void shutdown()>();
label1:
v7 = new javax.net.ssl.SSLEngineResult;
v8 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status CLOSED>;
specialinvoke v7.<javax.net.ssl.SSLEngineResult: void <init>(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v8, v2, v3, v4);
return v7;
label2:
v9 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_TASK>;
if v2 != v9 goto label3;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean needTask> = 1;
label3:
v10 = new javax.net.ssl.SSLEngineResult;
specialinvoke v10.<javax.net.ssl.SSLEngineResult: void <init>(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v1, v2, v3, v4);
return v10;
}
private javax.net.ssl.SSLEngineResult newResultMayFinishHandshake(javax.net.ssl.SSLEngineResult$HandshakeStatus, int, int) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
javax.net.ssl.SSLEngineResult v5;
int v2, v3;
javax.net.ssl.SSLEngineResult$HandshakeStatus v1, v4;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: javax.net.ssl.SSLEngineResult$HandshakeStatus;
v2 := @parameter1: int;
v3 := @parameter2: int;
v4 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult$HandshakeStatus mayFinishHandshake(javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v1, v2, v3);
v5 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResult(javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v4, v2, v3);
return v5;
}
private javax.net.ssl.SSLEngineResult newResultMayFinishHandshake(javax.net.ssl.SSLEngineResult$Status, javax.net.ssl.SSLEngineResult$HandshakeStatus, int, int) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
javax.net.ssl.SSLEngineResult v6;
int v3, v4;
javax.net.ssl.SSLEngineResult$HandshakeStatus v2, v5;
javax.net.ssl.SSLEngineResult$Status v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: javax.net.ssl.SSLEngineResult$Status;
v2 := @parameter1: javax.net.ssl.SSLEngineResult$HandshakeStatus;
v3 := @parameter2: int;
v4 := @parameter3: int;
v5 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult$HandshakeStatus mayFinishHandshake(javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v2, v3, v4);
v6 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResult(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v1, v5, v3, v4);
return v6;
}
private javax.net.ssl.SSLException shutdownWithError(java.lang.String, int)
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
javax.net.ssl.SSLException v4;
int v2, v3;
java.lang.String v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: java.lang.String;
v2 := @parameter1: int;
v3 = staticinvoke <io.netty.internal.tcnative.SSL: int getLastErrorNumber()>();
v4 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLException shutdownWithError(java.lang.String,int,int)>(v1, v2, v3);
return v4;
}
private javax.net.ssl.SSLException shutdownWithError(java.lang.String, int, int)
{
java.lang.Throwable v12, v13;
java.lang.Object[] v8;
java.lang.Integer v10, v9;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
javax.net.ssl.SSLException v11;
io.netty.util.internal.logging.InternalLogger v4, v7;
int v2, v3;
java.lang.String v1, v6;
boolean v5;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: java.lang.String;
v2 := @parameter1: int;
v3 := @parameter2: int;
v4 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.util.internal.logging.InternalLogger logger>;
v5 = interfaceinvoke v4.<io.netty.util.internal.logging.InternalLogger: boolean isDebugEnabled()>();
if v5 == 0 goto label1;
v6 = staticinvoke <io.netty.internal.tcnative.SSL: java.lang.String getErrorString(long)>(v3);
v7 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.util.internal.logging.InternalLogger logger>;
v8 = newarray (java.lang.Object)[4];
v8[0] = v1;
v9 = staticinvoke <java.lang.Integer: java.lang.Integer valueOf(int)>(v2);
v8[1] = v9;
v10 = staticinvoke <java.lang.Integer: java.lang.Integer valueOf(int)>(v3);
v8[2] = v10;
v8[3] = v6;
interfaceinvoke v7.<io.netty.util.internal.logging.InternalLogger: void debug(java.lang.String,java.lang.Object[])>("{} failed with {}: OpenSSL error: {} {}", v8);
label1:
virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void shutdown()>();
v11 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLException newSSLExceptionForError(int)>(v3);
v12 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.Throwable pendingException>;
if v12 == null goto label2;
v13 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.Throwable pendingException>;
virtualinvoke v11.<javax.net.ssl.SSLException: java.lang.Throwable initCause(java.lang.Throwable)>(v13);
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.Throwable pendingException> = null;
label2:
return v11;
}
private javax.net.ssl.SSLEngineResult handleUnwrapException(int, int, javax.net.ssl.SSLException) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
javax.net.ssl.SSLEngineResult v6;
javax.net.ssl.SSLException v3;
int v1, v2, v4, v5;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: int;
v2 := @parameter1: int;
v3 := @parameter2: javax.net.ssl.SSLException;
v4 = staticinvoke <io.netty.internal.tcnative.SSL: int getLastErrorNumber()>();
if v4 == 0 goto label1;
v5 = <io.netty.internal.tcnative.SSL: int SSL_ERROR_SSL>;
v6 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult sslReadErrorResult(int,int,int,int)>(v5, v4, v1, v2);
return v6;
label1:
throw v3;
}
public final javax.net.ssl.SSLEngineResult unwrap(java.nio.ByteBuffer[], int, int, java.nio.ByteBuffer[], int, int) throws javax.net.ssl.SSLException
{
java.lang.IndexOutOfBoundsException v10, v16;
byte v53, v60, v69, v72, v75, v82;
long v100, v111, v113, v122, v130, v133, v135, v137, v139, v19, v28, v78, v89, v93, v99;
javax.net.ssl.SSLEngineResult$Status v106, v109, v120, v127, v145, v54, v67, v70, v73, v76;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState v38, v39, v40, v41, v42, v43, v52;
io.netty.handler.ssl.OpenSslSession v63, v66;
java.nio.ReadOnlyBufferException v25;
javax.net.ssl.SSLEngineResult$HandshakeStatus v128, v37, v44, v46;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.nio.ByteBuffer[] v1, v4;
io.netty.handler.ssl.NotSslRecordException v58;
int v101, v102, v103, v104, v11, v114, v115, v116, v117, v123, v124, v125, v13, v131, v14, v140, v141, v142, v143, v15, v17, v2, v20, v21, v26, v27, v29, v3, v32, v5, v50, v56, v57, v59, v6, v61, v64, v7, v8, v84, v85, v87, v9, v90, v96;
java.lang.Object v23, v31;
javax.net.ssl.SSLException v62, v91, v97;
java.lang.Throwable v134, v136, v147;
java.lang.AssertionError v80, v83;
javax.net.ssl.SSLEngineResult v107, v110, v121, v129, v132, v146, v36, v45, v47, v49, v55, v68, v71, v74, v77, v92, v98;
java.lang.String v12, v18, v65;
java.nio.ByteBuffer v22, v30, v86, v94;
boolean v105, v108, v112, v118, v119, v126, v138, v144, v24, v33, v34, v35, v48, v51, v79, v81, v95;
io.netty.buffer.ByteBuf v88;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: java.nio.ByteBuffer[];
v2 := @parameter1: int;
v3 := @parameter2: int;
v4 := @parameter3: java.nio.ByteBuffer[];
v5 := @parameter4: int;
v6 := @parameter5: int;
staticinvoke <io.netty.util.internal.ObjectUtil: java.lang.Object checkNotNullWithIAE(java.lang.Object,java.lang.String)>(v1, "srcs");
v7 = lengthof v1;
if v2 >= v7 goto label01;
v8 = v2 + v3;
v9 = lengthof v1;
if v8 <= v9 goto label02;
label01:
v10 = new java.lang.IndexOutOfBoundsException;
v11 = lengthof v1;
v12 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (int,int,int)>(v2, v3, v11) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("offset: \u0001, length: \u0001 (expected: offset <= offset + length <= srcs.length (\u0001))");
specialinvoke v10.<java.lang.IndexOutOfBoundsException: void <init>(java.lang.String)>(v12);
throw v10;
label02:
staticinvoke <io.netty.util.internal.ObjectUtil: java.lang.Object checkNotNullWithIAE(java.lang.Object,java.lang.String)>(v4, "dsts");
v13 = lengthof v4;
if v5 >= v13 goto label03;
v14 = v5 + v6;
v15 = lengthof v4;
if v14 <= v15 goto label04;
label03:
v16 = new java.lang.IndexOutOfBoundsException;
v17 = lengthof v4;
v18 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (int,int,int)>(v5, v6, v17) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("offset: \u0001, length: \u0001 (expected: offset <= offset + length <= dsts.length (\u0001))");
specialinvoke v16.<java.lang.IndexOutOfBoundsException: void <init>(java.lang.String)>(v18);
throw v16;
label04:
v19 = 0L;
v20 = v5 + v6;
v21 = v5;
label05:
if v21 >= v20 goto label07;
v22 = v4[v21];
v23 = staticinvoke <io.netty.util.internal.ObjectUtil: java.lang.Object checkNotNullArrayParam(java.lang.Object,int,java.lang.String)>(v22, v21, "dsts");
v24 = virtualinvoke v23.<java.nio.ByteBuffer: boolean isReadOnly()>();
if v24 == 0 goto label06;
v25 = new java.nio.ReadOnlyBufferException;
specialinvoke v25.<java.nio.ReadOnlyBufferException: void <init>()>();
throw v25;
label06:
v26 = virtualinvoke v23.<java.nio.ByteBuffer: int remaining()>();
v19 = v19 + v26;
v21 = v21 + 1;
goto label05;
label07:
v27 = v2 + v3;
v28 = 0L;
v29 = v2;
label08:
if v29 >= v27 goto label09;
v30 = v1[v29];
v31 = staticinvoke <io.netty.util.internal.ObjectUtil: java.lang.Object checkNotNullArrayParam(java.lang.Object,int,java.lang.String)>(v30, v29, "srcs");
v32 = virtualinvoke v31.<java.nio.ByteBuffer: int remaining()>();
v28 = v28 + v32;
v29 = v29 + 1;
goto label08;
label09:
entermonitor v0;
label10:
v33 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isInboundDone()>();
if v33 == 0 goto label15;
v34 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isOutboundDone()>();
if v34 != 0 goto label11;
v35 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v35 == 0 goto label12;
label11:
v36 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult CLOSED_NOT_HANDSHAKING>;
goto label13;
label12:
v36 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult NEED_WRAP_CLOSED>;
label13:
exitmonitor v0;
label14:
return v36;
label15:
v37 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NOT_HANDSHAKING>;
v38 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState handshakeState>;
v39 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState handshakeState>;
v40 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState FINISHED>;
if v39 == v40 goto label22;
v41 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState handshakeState>;
v42 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState STARTED_EXPLICITLY>;
if v41 == v42 goto label16;
v43 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState STARTED_IMPLICITLY>;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState handshakeState> = v43;
label16:
v37 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult$HandshakeStatus handshake()>();
v44 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_TASK>;
if v37 != v44 goto label18;
v45 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResult(javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v37, 0, 0);
exitmonitor v0;
label17:
return v45;
label18:
v46 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_WRAP>;
if v37 != v46 goto label20;
v47 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult NEED_WRAP_OK>;
exitmonitor v0;
label19:
return v47;
label20:
v48 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isInboundDone>;
if v48 == 0 goto label22;
v49 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult NEED_WRAP_CLOSED>;
exitmonitor v0;
label21:
return v49;
label22:
v50 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int sslPending0()>();
v51 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean jdkCompatibilityMode>;
if v51 != 0 goto label23;
v52 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState FINISHED>;
if v38 == v52 goto label31;
label23:
v53 = v28 cmp 5L;
if v53 >= 0 goto label25;
v54 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status BUFFER_UNDERFLOW>;
v55 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResultMayFinishHandshake(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v54, v37, 0, 0);
exitmonitor v0;
label24:
return v55;
label25:
v56 = staticinvoke <io.netty.handler.ssl.SslUtils: int getEncryptedPacketLength(java.nio.ByteBuffer[],int)>(v1, v2);
v57 = (int) -2;
if v56 != v57 goto label26;
v58 = new io.netty.handler.ssl.NotSslRecordException;
specialinvoke v58.<io.netty.handler.ssl.NotSslRecordException: void <init>(java.lang.String)>("not an SSL/TLS record");
throw v58;
label26:
v59 = v56 - 5;
v60 = v59 cmp v19;
if v60 <= 0 goto label29;
v61 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int MAX_RECORD_SIZE>;
if v59 <= v61 goto label27;
v62 = new javax.net.ssl.SSLException;
v63 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.OpenSslSession session>;
v64 = interfaceinvoke v63.<io.netty.handler.ssl.OpenSslSession: int getApplicationBufferSize()>();
v65 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (int,int)>(v59, v64) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Illegal packet length: \u0001 > \u0001");
specialinvoke v62.<javax.net.ssl.SSLException: void <init>(java.lang.String)>(v65);
throw v62;
label27:
v66 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.OpenSslSession session>;
interfaceinvoke v66.<io.netty.handler.ssl.OpenSslSession: void tryExpandApplicationBufferSize(int)>(v59);
v67 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status BUFFER_OVERFLOW>;
v68 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResultMayFinishHandshake(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v67, v37, 0, 0);
exitmonitor v0;
label28:
return v68;
label29:
v69 = v28 cmp v56;
if v69 >= 0 goto label36;
v70 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status BUFFER_UNDERFLOW>;
v71 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResultMayFinishHandshake(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v70, v37, 0, 0);
exitmonitor v0;
label30:
return v71;
label31:
v72 = v28 cmp 0L;
if v72 != 0 goto label33;
if v50 > 0 goto label33;
v73 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status BUFFER_UNDERFLOW>;
v74 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResultMayFinishHandshake(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v73, v37, 0, 0);
exitmonitor v0;
label32:
return v74;
label33:
v75 = v19 cmp 0L;
if v75 != 0 goto label35;
v76 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status BUFFER_OVERFLOW>;
v77 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResultMayFinishHandshake(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v76, v37, 0, 0);
exitmonitor v0;
label34:
return v77;
label35:
v78 = staticinvoke <java.lang.Math: long min(long,long)>(2147483647L, v28);
label36:
v79 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v79 != 0 goto label37;
if v2 < v27 goto label37;
v80 = new java.lang.AssertionError;
specialinvoke v80.<java.lang.AssertionError: void <init>()>();
throw v80;
label37:
v81 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v81 != 0 goto label38;
v82 = v19 cmp 0L;
if v82 > 0 goto label38;
v83 = new java.lang.AssertionError;
specialinvoke v83.<java.lang.AssertionError: void <init>()>();
throw v83;
label38:
v84 = 0;
v85 = 0;
label39:
v86 = v1[v2];
v87 = virtualinvoke v86.<java.nio.ByteBuffer: int remaining()>();
if v87 != 0 goto label41;
if v50 > 0 goto label40;
v2 = v2 + 1;
if v2 < v27 goto label39;
goto label88;
label40:
v88 = null;
v89 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v90 = staticinvoke <io.netty.internal.tcnative.SSL: int bioLengthByteBuffer(long)>(v89);
goto label47;
label41:
v90 = staticinvoke <java.lang.Math: int min(int,int)>(v78, v87);
label42:
v88 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.buffer.ByteBuf writeEncryptedData(java.nio.ByteBuffer,int)>(v86, v90);
label43:
goto label47;
label44:
v91 := @caughtexception;
v92 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult handleUnwrapException(int,int,javax.net.ssl.SSLException)>(v85, v84, v91);
label45:
v93 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v93);
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void rejectRemoteInitiatedRenegotiation()>();
exitmonitor v0;
label46:
return v92;
label47:
v94 = v4[v5];
v95 = virtualinvoke v94.<java.nio.ByteBuffer: boolean hasRemaining()>();
if v95 != 0 goto label49;
v5 = v5 + 1;
if v5 < v20 goto label47;
label48:
if v88 == null goto label88;
virtualinvoke v88.<io.netty.buffer.ByteBuf: boolean release()>();
goto label88;
label49:
v96 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int readPlaintextData(java.nio.ByteBuffer)>(v94);
label50:
goto label55;
label51:
v97 := @caughtexception;
v98 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult handleUnwrapException(int,int,javax.net.ssl.SSLException)>(v85, v84, v97);
label52:
if v88 == null goto label53;
virtualinvoke v88.<io.netty.buffer.ByteBuf: boolean release()>();
label53:
v99 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v99);
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void rejectRemoteInitiatedRenegotiation()>();
exitmonitor v0;
label54:
return v98;
label55:
v100 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v101 = staticinvoke <io.netty.internal.tcnative.SSL: int bioLengthByteBuffer(long)>(v100);
v102 = v90 - v101;
v85 = v85 + v102;
v78 = v78 - v102;
v90 = v90 - v102;
v103 = virtualinvoke v86.<java.nio.ByteBuffer: int position()>();
v104 = v103 + v102;
virtualinvoke v86.<java.nio.ByteBuffer: java.nio.ByteBuffer position(int)>(v104);
if v96 <= 0 goto label65;
v84 = v84 + v96;
v105 = virtualinvoke v94.<java.nio.ByteBuffer: boolean hasRemaining()>();
if v105 != 0 goto label63;
v50 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int sslPending0()>();
v5 = v5 + 1;
if v5 < v20 goto label47;
if v50 <= 0 goto label56;
v106 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status BUFFER_OVERFLOW>;
v107 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResult(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v106, v37, v85, v84);
goto label59;
label56:
v108 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isInboundDone()>();
if v108 == 0 goto label57;
v109 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status CLOSED>;
goto label58;
label57:
v109 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status OK>;
label58:
v107 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResultMayFinishHandshake(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v109, v37, v85, v84);
label59:
v110 = v107;
label60:
if v88 == null goto label61;
virtualinvoke v88.<io.netty.buffer.ByteBuf: boolean release()>();
label61:
v111 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v111);
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void rejectRemoteInitiatedRenegotiation()>();
exitmonitor v0;
label62:
return v110;
label63:
if v78 == 0 goto label64;
v112 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean jdkCompatibilityMode>;
if v112 == 0 goto label47;
label64:
if v88 == null goto label88;
virtualinvoke v88.<io.netty.buffer.ByteBuf: boolean release()>();
goto label88;
label65:
v113 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v114 = staticinvoke <io.netty.internal.tcnative.SSL: int getError(long,int)>(v113, v96);
v115 = <io.netty.internal.tcnative.SSL: int SSL_ERROR_WANT_READ>;
if v114 == v115 goto label83;
v116 = <io.netty.internal.tcnative.SSL: int SSL_ERROR_WANT_WRITE>;
if v114 == v116 goto label83;
v117 = <io.netty.internal.tcnative.SSL: int SSL_ERROR_ZERO_RETURN>;
if v114 != v117 goto label72;
v118 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean receivedShutdown>;
if v118 != 0 goto label66;
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void closeAll()>();
label66:
v119 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isInboundDone()>();
if v119 == 0 goto label67;
v120 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status CLOSED>;
goto label68;
label67:
v120 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status OK>;
label68:
v121 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResultMayFinishHandshake(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v120, v37, v85, v84);
label69:
if v88 == null goto label70;
virtualinvoke v88.<io.netty.buffer.ByteBuf: boolean release()>();
label70:
v122 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v122);
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void rejectRemoteInitiatedRenegotiation()>();
exitmonitor v0;
label71:
return v121;
label72:
v123 = <io.netty.internal.tcnative.SSL: int SSL_ERROR_WANT_X509_LOOKUP>;
if v114 == v123 goto label73;
v124 = <io.netty.internal.tcnative.SSL: int SSL_ERROR_WANT_CERTIFICATE_VERIFY>;
if v114 == v124 goto label73;
v125 = <io.netty.internal.tcnative.SSL: int SSL_ERROR_WANT_PRIVATE_KEY_OPERATION>;
if v114 != v125 goto label79;
label73:
v126 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isInboundDone()>();
if v126 == 0 goto label74;
v127 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status CLOSED>;
goto label75;
label74:
v127 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status OK>;
label75:
v128 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_TASK>;
v129 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResult(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v127, v128, v85, v84);
label76:
if v88 == null goto label77;
virtualinvoke v88.<io.netty.buffer.ByteBuf: boolean release()>();
label77:
v130 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v130);
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void rejectRemoteInitiatedRenegotiation()>();
exitmonitor v0;
label78:
return v129;
label79:
v131 = staticinvoke <io.netty.internal.tcnative.SSL: int getLastErrorNumber()>();
v132 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult sslReadErrorResult(int,int,int,int)>(v114, v131, v85, v84);
label80:
if v88 == null goto label81;
virtualinvoke v88.<io.netty.buffer.ByteBuf: boolean release()>();
label81:
v133 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v133);
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void rejectRemoteInitiatedRenegotiation()>();
exitmonitor v0;
label82:
return v132;
label83:
v2 = v2 + 1;
if v2 < v27 goto label85;
label84:
if v88 == null goto label88;
virtualinvoke v88.<io.netty.buffer.ByteBuf: boolean release()>();
goto label88;
label85:
if v88 == null goto label39;
virtualinvoke v88.<io.netty.buffer.ByteBuf: boolean release()>();
goto label39;
label86:
v134 := @caughtexception;
if v88 == null goto label87;
virtualinvoke v88.<io.netty.buffer.ByteBuf: boolean release()>();
label87:
throw v134;
label88:
v135 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v135);
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void rejectRemoteInitiatedRenegotiation()>();
goto label90;
label89:
v136 := @caughtexception;
v137 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
staticinvoke <io.netty.internal.tcnative.SSL: void bioClearByteBuffer(long)>(v137);
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void rejectRemoteInitiatedRenegotiation()>();
throw v136;
label90:
v138 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean receivedShutdown>;
if v138 != 0 goto label91;
v139 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v140 = staticinvoke <io.netty.internal.tcnative.SSL: int getShutdown(long)>(v139);
v141 = <io.netty.internal.tcnative.SSL: int SSL_RECEIVED_SHUTDOWN>;
v142 = v140 & v141;
v143 = <io.netty.internal.tcnative.SSL: int SSL_RECEIVED_SHUTDOWN>;
if v142 != v143 goto label91;
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void closeAll()>();
label91:
v144 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isInboundDone()>();
if v144 == 0 goto label92;
v145 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status CLOSED>;
goto label93;
label92:
v145 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status OK>;
label93:
v146 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult newResultMayFinishHandshake(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v145, v37, v85, v84);
exitmonitor v0;
label94:
return v146;
label95:
v147 := @caughtexception;
exitmonitor v0;
throw v147;
catch javax.net.ssl.SSLException from label42 to label43 with label44;
catch javax.net.ssl.SSLException from label49 to label50 with label51;
catch java.lang.Throwable from label47 to label48 with label86;
catch java.lang.Throwable from label49 to label52 with label86;
catch java.lang.Throwable from label55 to label60 with label86;
catch java.lang.Throwable from label63 to label64 with label86;
catch java.lang.Throwable from label65 to label69 with label86;
catch java.lang.Throwable from label72 to label76 with label86;
catch java.lang.Throwable from label79 to label80 with label86;
catch java.lang.Throwable from label83 to label84 with label86;
catch java.lang.Throwable from label39 to label45 with label89;
catch java.lang.Throwable from label47 to label53 with label89;
catch java.lang.Throwable from label55 to label61 with label89;
catch java.lang.Throwable from label63 to label70 with label89;
catch java.lang.Throwable from label72 to label77 with label89;
catch java.lang.Throwable from label79 to label81 with label89;
catch java.lang.Throwable from label83 to label88 with label89;
catch java.lang.Throwable from label10 to label14 with label95;
catch java.lang.Throwable from label15 to label17 with label95;
catch java.lang.Throwable from label18 to label19 with label95;
catch java.lang.Throwable from label20 to label21 with label95;
catch java.lang.Throwable from label22 to label24 with label95;
catch java.lang.Throwable from label25 to label28 with label95;
catch java.lang.Throwable from label29 to label30 with label95;
catch java.lang.Throwable from label31 to label32 with label95;
catch java.lang.Throwable from label33 to label34 with label95;
catch java.lang.Throwable from label35 to label46 with label95;
catch java.lang.Throwable from label47 to label54 with label95;
catch java.lang.Throwable from label55 to label62 with label95;
catch java.lang.Throwable from label63 to label71 with label95;
catch java.lang.Throwable from label72 to label78 with label95;
catch java.lang.Throwable from label79 to label82 with label95;
catch java.lang.Throwable from label83 to label94 with label95;
}
private boolean needWrapAgain(int)
{
java.lang.Throwable v4, v6, v8;
long v2;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
javax.net.ssl.SSLException v5, v9;
int v1, v3;
boolean v7;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: int;
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v3 = staticinvoke <io.netty.internal.tcnative.SSL: int bioLengthNonApplication(long)>(v2);
if v3 <= 0 goto label3;
v4 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.Throwable pendingException>;
if v4 != null goto label1;
v5 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLException newSSLExceptionForError(int)>(v1);
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.Throwable pendingException> = v5;
goto label2;
label1:
v6 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.Throwable pendingException>;
v7 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean shouldAddSuppressed(java.lang.Throwable,int)>(v6, v1);
if v7 == 0 goto label2;
v8 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.Throwable pendingException>;
v9 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLException newSSLExceptionForError(int)>(v1);
staticinvoke <io.netty.util.internal.ThrowableUtil: void addSuppressed(java.lang.Throwable,java.lang.Throwable)>(v8, v9);
label2:
staticinvoke <io.netty.internal.tcnative.SSL: void clearError()>();
return 1;
label3:
return 0;
}
private javax.net.ssl.SSLException newSSLExceptionForError(int)
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine$OpenSslHandshakeException v7;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
javax.net.ssl.SSLException v6;
int v1;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine$OpenSslException v5;
java.lang.String v2;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState v3, v4;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: int;
v2 = staticinvoke <io.netty.internal.tcnative.SSL: java.lang.String getErrorString(long)>(v1);
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState handshakeState>;
v4 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState FINISHED>;
if v3 != v4 goto label1;
v5 = new io.netty.handler.ssl.ReferenceCountedOpenSslEngine$OpenSslException;
v6 = v5;
specialinvoke v5.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine$OpenSslException: void <init>(java.lang.String,int)>(v2, v1);
goto label2;
label1:
v7 = new io.netty.handler.ssl.ReferenceCountedOpenSslEngine$OpenSslHandshakeException;
v6 = v7;
specialinvoke v7.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine$OpenSslHandshakeException: void <init>(java.lang.String,int)>(v2, v1);
label2:
return v6;
}
private static boolean shouldAddSuppressed(java.lang.Throwable, int)
{
java.lang.Throwable v0, v5;
java.lang.Throwable[] v2;
int v1, v3, v4, v7;
boolean v6;
v0 := @parameter0: java.lang.Throwable;
v1 := @parameter1: int;
v2 = staticinvoke <io.netty.util.internal.ThrowableUtil: java.lang.Throwable[] getSuppressed(java.lang.Throwable)>(v0);
v3 = lengthof v2;
v4 = 0;
label1:
if v4 >= v3 goto label3;
v5 = v2[v4];
v6 = v5 instanceof io.netty.handler.ssl.ReferenceCountedOpenSslEngine$NativeSslException;
if v6 == 0 goto label2;
v7 = interfaceinvoke v5.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine$NativeSslException: int errorCode()>();
if v7 != v1 goto label2;
return 0;
label2:
v4 = v4 + 1;
goto label1;
label3:
return 1;
}
private javax.net.ssl.SSLEngineResult sslReadErrorResult(int, int, int, int) throws javax.net.ssl.SSLException
{
javax.net.ssl.SSLEngineResult$HandshakeStatus v8;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
javax.net.ssl.SSLEngineResult v6;
javax.net.ssl.SSLException v9;
int v1, v2, v3, v4;
javax.net.ssl.SSLEngineResult$Status v7;
boolean v5;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: int;
v2 := @parameter1: int;
v3 := @parameter2: int;
v4 := @parameter3: int;
v5 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean needWrapAgain(int)>(v2);
if v5 == 0 goto label1;
v6 = new javax.net.ssl.SSLEngineResult;
v7 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status OK>;
v8 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_WRAP>;
specialinvoke v6.<javax.net.ssl.SSLEngineResult: void <init>(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v7, v8, v3, v4);
return v6;
label1:
v9 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLException shutdownWithError(java.lang.String,int,int)>("SSL_read", v1, v2);
throw v9;
}
private void closeAll() throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean receivedShutdown> = 1;
virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void closeOutbound()>();
virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void closeInbound()>();
return;
}
private void rejectRemoteInitiatedRenegotiation() throws javax.net.ssl.SSLHandshakeException
{
javax.net.ssl.SSLHandshakeException v14;
io.netty.handler.ssl.OpenSslSession v9;
long v3, v6;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
int v4, v7;
java.lang.String v10, v8;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState v12, v13;
boolean v1, v11, v2, v5;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v1 != 0 goto label3;
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean clientMode>;
if v2 != 0 goto label1;
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v4 = staticinvoke <io.netty.internal.tcnative.SSL: int getHandshakeCount(long)>(v3);
if v4 > 1 goto label2;
label1:
v5 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean clientMode>;
if v5 == 0 goto label3;
v6 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v7 = staticinvoke <io.netty.internal.tcnative.SSL: int getHandshakeCount(long)>(v6);
if v7 <= 2 goto label3;
label2:
v8 = "TLSv1.3";
v9 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.OpenSslSession session>;
v10 = interfaceinvoke v9.<io.netty.handler.ssl.OpenSslSession: java.lang.String getProtocol()>();
v11 = virtualinvoke v8.<java.lang.String: boolean equals(java.lang.Object)>(v10);
if v11 != 0 goto label3;
v12 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState handshakeState>;
v13 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState FINISHED>;
if v12 != v13 goto label3;
virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void shutdown()>();
v14 = new javax.net.ssl.SSLHandshakeException;
specialinvoke v14.<javax.net.ssl.SSLHandshakeException: void <init>(java.lang.String)>("remote-initiated renegotiation not allowed");
throw v14;
label3:
return;
}
public final javax.net.ssl.SSLEngineResult unwrap(java.nio.ByteBuffer[], java.nio.ByteBuffer[]) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.nio.ByteBuffer[] v1, v2;
javax.net.ssl.SSLEngineResult v5;
int v3, v4;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: java.nio.ByteBuffer[];
v2 := @parameter1: java.nio.ByteBuffer[];
v3 = lengthof v1;
v4 = lengthof v2;
v5 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult unwrap(java.nio.ByteBuffer[],int,int,java.nio.ByteBuffer[],int,int)>(v1, 0, v3, v2, 0, v4);
return v5;
}
private java.nio.ByteBuffer[] singleSrcBuffer(java.nio.ByteBuffer)
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.nio.ByteBuffer[] v2, v3;
java.nio.ByteBuffer v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: java.nio.ByteBuffer;
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.nio.ByteBuffer[] singleSrcBuffer>;
v2[0] = v1;
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.nio.ByteBuffer[] singleSrcBuffer>;
return v3;
}
private void resetSingleSrcBuffer()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.nio.ByteBuffer[] v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.nio.ByteBuffer[] singleSrcBuffer>;
v1[0] = null;
return;
}
private java.nio.ByteBuffer[] singleDstBuffer(java.nio.ByteBuffer)
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.nio.ByteBuffer[] v2, v3;
java.nio.ByteBuffer v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: java.nio.ByteBuffer;
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.nio.ByteBuffer[] singleDstBuffer>;
v2[0] = v1;
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.nio.ByteBuffer[] singleDstBuffer>;
return v3;
}
private void resetSingleDstBuffer()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.nio.ByteBuffer[] v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.nio.ByteBuffer[] singleDstBuffer>;
v1[0] = null;
return;
}
public final synchronized javax.net.ssl.SSLEngineResult unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer[], int, int) throws javax.net.ssl.SSLException
{
java.lang.Throwable v7;
java.nio.ByteBuffer[] v2, v5;
java.nio.ByteBuffer v1;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
javax.net.ssl.SSLEngineResult v6;
int v3, v4;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: java.nio.ByteBuffer;
v2 := @parameter1: java.nio.ByteBuffer[];
v3 := @parameter2: int;
v4 := @parameter3: int;
label1:
v5 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.nio.ByteBuffer[] singleSrcBuffer(java.nio.ByteBuffer)>(v1);
v6 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult unwrap(java.nio.ByteBuffer[],int,int,java.nio.ByteBuffer[],int,int)>(v5, 0, 1, v2, v3, v4);
label2:
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void resetSingleSrcBuffer()>();
return v6;
label3:
v7 := @caughtexception;
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void resetSingleSrcBuffer()>();
throw v7;
catch java.lang.Throwable from label1 to label2 with label3;
}
public final synchronized javax.net.ssl.SSLEngineResult wrap(java.nio.ByteBuffer, java.nio.ByteBuffer) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.lang.Throwable v5;
java.nio.ByteBuffer[] v3;
javax.net.ssl.SSLEngineResult v4;
java.nio.ByteBuffer v1, v2;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: java.nio.ByteBuffer;
v2 := @parameter1: java.nio.ByteBuffer;
label1:
v3 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.nio.ByteBuffer[] singleSrcBuffer(java.nio.ByteBuffer)>(v1);
v4 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult wrap(java.nio.ByteBuffer[],java.nio.ByteBuffer)>(v3, v2);
label2:
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void resetSingleSrcBuffer()>();
return v4;
label3:
v5 := @caughtexception;
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void resetSingleSrcBuffer()>();
throw v5;
catch java.lang.Throwable from label1 to label2 with label3;
}
public final synchronized javax.net.ssl.SSLEngineResult unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.lang.Throwable v6;
java.nio.ByteBuffer[] v3, v4;
javax.net.ssl.SSLEngineResult v5;
java.nio.ByteBuffer v1, v2;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: java.nio.ByteBuffer;
v2 := @parameter1: java.nio.ByteBuffer;
label1:
v3 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.nio.ByteBuffer[] singleSrcBuffer(java.nio.ByteBuffer)>(v1);
v4 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.nio.ByteBuffer[] singleDstBuffer(java.nio.ByteBuffer)>(v2);
v5 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult unwrap(java.nio.ByteBuffer[],java.nio.ByteBuffer[])>(v3, v4);
label2:
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void resetSingleSrcBuffer()>();
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void resetSingleDstBuffer()>();
return v5;
label3:
v6 := @caughtexception;
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void resetSingleSrcBuffer()>();
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void resetSingleDstBuffer()>();
throw v6;
catch java.lang.Throwable from label1 to label2 with label3;
}
public final synchronized javax.net.ssl.SSLEngineResult unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer[]) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.lang.Throwable v5;
java.nio.ByteBuffer[] v2, v3;
javax.net.ssl.SSLEngineResult v4;
java.nio.ByteBuffer v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: java.nio.ByteBuffer;
v2 := @parameter1: java.nio.ByteBuffer[];
label1:
v3 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.nio.ByteBuffer[] singleSrcBuffer(java.nio.ByteBuffer)>(v1);
v4 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult unwrap(java.nio.ByteBuffer[],java.nio.ByteBuffer[])>(v3, v2);
label2:
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void resetSingleSrcBuffer()>();
return v4;
label3:
v5 := @caughtexception;
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void resetSingleSrcBuffer()>();
throw v5;
catch java.lang.Throwable from label1 to label2 with label3;
}
private synchronized void runAndResetNeedTask(java.lang.Runnable)
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.lang.Throwable v3;
java.lang.Runnable v1;
boolean v2;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: java.lang.Runnable;
label1:
v2 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v2 == 0 goto label3;
label2:
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean needTask> = 0;
return;
label3:
interfaceinvoke v1.<java.lang.Runnable: void run()>();
label4:
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean needTask> = 0;
goto label6;
label5:
v3 := @caughtexception;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean needTask> = 0;
throw v3;
label6:
return;
catch java.lang.Throwable from label1 to label2 with label5;
catch java.lang.Throwable from label3 to label4 with label5;
}
public final synchronized java.lang.Runnable getDelegatedTask()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine$TaskDecorator v6;
long v2;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine$AsyncTaskDecorator v5;
java.lang.Runnable v3;
boolean v1, v4;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v1 == 0 goto label1;
return null;
label1:
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v3 = staticinvoke <io.netty.internal.tcnative.SSL: java.lang.Runnable getTask(long)>(v2);
if v3 != null goto label2;
return null;
label2:
v4 = v3 instanceof io.netty.internal.tcnative.AsyncTask;
if v4 == 0 goto label3;
v5 = new io.netty.handler.ssl.ReferenceCountedOpenSslEngine$AsyncTaskDecorator;
specialinvoke v5.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine$AsyncTaskDecorator: void <init>(io.netty.handler.ssl.ReferenceCountedOpenSslEngine,io.netty.internal.tcnative.AsyncTask)>(v0, v3);
return v5;
label3:
v6 = new io.netty.handler.ssl.ReferenceCountedOpenSslEngine$TaskDecorator;
specialinvoke v6.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine$TaskDecorator: void <init>(io.netty.handler.ssl.ReferenceCountedOpenSslEngine,java.lang.Runnable)>(v0, v3);
return v6;
}
public final synchronized void closeInbound() throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
javax.net.ssl.SSLException v6;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState v3, v4;
boolean v1, v2, v5;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isInboundDone>;
if v1 == 0 goto label1;
return;
label1:
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isInboundDone> = 1;
v2 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isOutboundDone()>();
if v2 == 0 goto label2;
virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void shutdown()>();
label2:
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState handshakeState>;
v4 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState NOT_STARTED>;
if v3 == v4 goto label3;
v5 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean receivedShutdown>;
if v5 != 0 goto label3;
v6 = new javax.net.ssl.SSLException;
specialinvoke v6.<javax.net.ssl.SSLException: void <init>(java.lang.String)>("Inbound closed before receiving peer\'s close_notify: possible truncation attack?");
throw v6;
label3:
return;
}
public final synchronized boolean isInboundDone()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
boolean v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isInboundDone>;
return v1;
}
public final synchronized void closeOutbound()
{
long v5;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
int v6, v7, v8, v9;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState v2, v3;
boolean v1, v4;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean outboundClosed>;
if v1 == 0 goto label1;
return;
label1:
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean outboundClosed> = 1;
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState handshakeState>;
v3 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState NOT_STARTED>;
if v2 == v3 goto label2;
v4 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v4 != 0 goto label2;
v5 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v6 = staticinvoke <io.netty.internal.tcnative.SSL: int getShutdown(long)>(v5);
v7 = <io.netty.internal.tcnative.SSL: int SSL_SENT_SHUTDOWN>;
v8 = v6 & v7;
v9 = <io.netty.internal.tcnative.SSL: int SSL_SENT_SHUTDOWN>;
if v8 == v9 goto label3;
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean doSSLShutdown()>();
goto label3;
label2:
virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void shutdown()>();
label3:
return;
}
private boolean doSSLShutdown()
{
long v1, v3, v5;
java.lang.Integer v13;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
io.netty.util.internal.logging.InternalLogger v12, v9;
int v11, v2, v4, v6, v7, v8;
java.lang.String v14;
boolean v10;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v2 = staticinvoke <io.netty.internal.tcnative.SSL: int isInInit(long)>(v1);
if v2 == 0 goto label1;
return 0;
label1:
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v4 = staticinvoke <io.netty.internal.tcnative.SSL: int shutdownSSL(long)>(v3);
if v4 >= 0 goto label5;
v5 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v6 = staticinvoke <io.netty.internal.tcnative.SSL: int getError(long,int)>(v5, v4);
v7 = <io.netty.internal.tcnative.SSL: int SSL_ERROR_SYSCALL>;
if v6 == v7 goto label2;
v8 = <io.netty.internal.tcnative.SSL: int SSL_ERROR_SSL>;
if v6 != v8 goto label4;
label2:
v9 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.util.internal.logging.InternalLogger logger>;
v10 = interfaceinvoke v9.<io.netty.util.internal.logging.InternalLogger: boolean isDebugEnabled()>();
if v10 == 0 goto label3;
v11 = staticinvoke <io.netty.internal.tcnative.SSL: int getLastErrorNumber()>();
v12 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.util.internal.logging.InternalLogger logger>;
v13 = staticinvoke <java.lang.Integer: java.lang.Integer valueOf(int)>(v11);
v14 = staticinvoke <io.netty.internal.tcnative.SSL: java.lang.String getErrorString(long)>(v11);
interfaceinvoke v12.<io.netty.util.internal.logging.InternalLogger: void debug(java.lang.String,java.lang.Object,java.lang.Object)>("SSL_shutdown failed: OpenSSL error: {} {}", v13, v14);
label3:
virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void shutdown()>();
return 0;
label4:
staticinvoke <io.netty.internal.tcnative.SSL: void clearError()>();
label5:
return 1;
}
public final synchronized boolean isOutboundDone()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
byte v3;
int v5;
long v2, v4;
boolean v1, v6;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean outboundClosed>;
if v1 == 0 goto label2;
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v3 = v2 cmp 0L;
if v3 == 0 goto label1;
v4 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v5 = staticinvoke <io.netty.internal.tcnative.SSL: int bioLengthNonApplication(long)>(v4);
if v5 != 0 goto label2;
label1:
v6 = 1;
goto label3;
label2:
v6 = 0;
label3:
return v6;
}
public final java.lang.String[] getSupportedCipherSuites()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.lang.Object[] v3;
java.util.Set v1;
java.lang.String[] v2;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = <io.netty.handler.ssl.OpenSsl: java.util.Set AVAILABLE_CIPHER_SUITES>;
v2 = newarray (java.lang.String)[0];
v3 = interfaceinvoke v1.<java.util.Set: java.lang.Object[] toArray(java.lang.Object[])>(v2);
return v3;
}
public final java.lang.String[] getEnabledCipherSuites()
{
java.lang.Throwable v11, v25;
java.lang.Object[] v27;
java.lang.String[] v10, v12, v26, v3, v8;
long v2, v4;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
int v14, v15, v16, v17, v18, v5, v6;
java.lang.String v19, v20, v21, v22;
java.util.LinkedHashSet v13;
boolean v1, v23, v24, v7, v9;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
entermonitor v0;
label01:
v1 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v1 != 0 goto label03;
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v3 = staticinvoke <io.netty.internal.tcnative.SSL: java.lang.String[] getCiphers(long)>(v2);
v4 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v5 = staticinvoke <io.netty.internal.tcnative.SSL: int getOptions(long)>(v4);
v6 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_TLSv1_3>;
v7 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isProtocolEnabled(int,int,java.lang.String)>(v5, v6, "TLSv1.3");
if v7 == 0 goto label02;
v8 = <io.netty.handler.ssl.OpenSsl: java.lang.String[] EXTRA_SUPPORTED_TLS_1_3_CIPHERS>;
v9 = 1;
goto label05;
label02:
v8 = <io.netty.util.internal.EmptyArrays: java.lang.String[] EMPTY_STRINGS>;
v9 = 0;
goto label05;
label03:
v10 = <io.netty.util.internal.EmptyArrays: java.lang.String[] EMPTY_STRINGS>;
exitmonitor v0;
label04:
return v10;
label05:
exitmonitor v0;
label06:
goto label08;
label07:
v11 := @caughtexception;
exitmonitor v0;
throw v11;
label08:
if v3 != null goto label09;
v12 = <io.netty.util.internal.EmptyArrays: java.lang.String[] EMPTY_STRINGS>;
return v12;
label09:
v13 = new java.util.LinkedHashSet;
v14 = lengthof v3;
v15 = lengthof v8;
v16 = v14 + v15;
specialinvoke v13.<java.util.LinkedHashSet: void <init>(int)>(v16);
entermonitor v0;
label10:
v17 = 0;
label11:
v18 = lengthof v3;
if v17 >= v18 goto label17;
v19 = v3[v17];
v20 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.String toJavaCipherSuite(java.lang.String)>(v19);
if v20 != null goto label12;
v21 = v3[v17];
goto label13;
label12:
v21 = v20;
label13:
v22 = v21;
if v9 == 0 goto label14;
v23 = staticinvoke <io.netty.handler.ssl.OpenSsl: boolean isTlsv13Supported()>();
if v23 != 0 goto label15;
label14:
v24 = staticinvoke <io.netty.handler.ssl.SslUtils: boolean isTLSv13Cipher(java.lang.String)>(v22);
if v24 != 0 goto label16;
label15:
interfaceinvoke v13.<java.util.Set: boolean add(java.lang.Object)>(v22);
label16:
v17 = v17 + 1;
goto label11;
label17:
staticinvoke <java.util.Collections: boolean addAll(java.util.Collection,java.lang.Object[])>(v13, v8);
exitmonitor v0;
label18:
goto label20;
label19:
v25 := @caughtexception;
exitmonitor v0;
throw v25;
label20:
v26 = newarray (java.lang.String)[0];
v27 = interfaceinvoke v13.<java.util.Set: java.lang.Object[] toArray(java.lang.Object[])>(v26);
return v27;
catch java.lang.Throwable from label01 to label04 with label07;
catch java.lang.Throwable from label05 to label06 with label07;
catch java.lang.Throwable from label10 to label18 with label19;
}
public final void setEnabledCipherSuites(java.lang.String[])
{
java.lang.Throwable v30;
java.lang.IllegalStateException v26, v28;
java.lang.Object[] v24;
java.lang.String[] v1, v18, v20, v23;
long v12, v14;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.util.HashSet v17;
int v19;
java.lang.String v16, v27, v29, v6, v7;
boolean v11, v13, v21, v22, v5, v8, v9;
java.lang.IllegalArgumentException v10;
java.lang.Exception v25;
java.util.List v4;
io.netty.util.internal.logging.InternalLogger v15;
java.lang.StringBuilder v2, v3;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: java.lang.String[];
staticinvoke <io.netty.util.internal.ObjectUtil: java.lang.Object checkNotNull(java.lang.Object,java.lang.String)>(v1, "cipherSuites");
v2 = new java.lang.StringBuilder;
specialinvoke v2.<java.lang.StringBuilder: void <init>()>();
v3 = new java.lang.StringBuilder;
specialinvoke v3.<java.lang.StringBuilder: void <init>()>();
v4 = staticinvoke <java.util.Arrays: java.util.List asList(java.lang.Object[])>(v1);
v5 = staticinvoke <io.netty.handler.ssl.OpenSsl: boolean isBoringSSL()>();
staticinvoke <io.netty.handler.ssl.CipherSuiteConverter: void convertToCipherStrings(java.lang.Iterable,java.lang.StringBuilder,java.lang.StringBuilder,boolean)>(v4, v2, v3, v5);
v6 = virtualinvoke v2.<java.lang.StringBuilder: java.lang.String toString()>();
v7 = virtualinvoke v3.<java.lang.StringBuilder: java.lang.String toString()>();
v8 = staticinvoke <io.netty.handler.ssl.OpenSsl: boolean isTlsv13Supported()>();
if v8 != 0 goto label01;
v9 = virtualinvoke v7.<java.lang.String: boolean isEmpty()>();
if v9 != 0 goto label01;
v10 = new java.lang.IllegalArgumentException;
specialinvoke v10.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>("TLSv1.3 is not supported by this java version.");
throw v10;
label01:
entermonitor v0;
label02:
v11 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v11 != 0 goto label09;
label03:
v12 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
staticinvoke <io.netty.internal.tcnative.SSL: boolean setCipherSuites(long,java.lang.String,boolean)>(v12, v6, 0);
v13 = staticinvoke <io.netty.handler.ssl.OpenSsl: boolean isTlsv13Supported()>();
if v13 == 0 goto label04;
v14 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v15 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.util.internal.logging.InternalLogger logger>;
v16 = staticinvoke <io.netty.handler.ssl.OpenSsl: java.lang.String checkTls13Ciphers(io.netty.util.internal.logging.InternalLogger,java.lang.String)>(v15, v7);
staticinvoke <io.netty.internal.tcnative.SSL: boolean setCipherSuites(long,java.lang.String,boolean)>(v14, v16, 1);
label04:
v17 = new java.util.HashSet;
v18 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.String[] explicitlyEnabledProtocols>;
v19 = lengthof v18;
specialinvoke v17.<java.util.HashSet: void <init>(int)>(v19);
v20 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.String[] explicitlyEnabledProtocols>;
staticinvoke <java.util.Collections: boolean addAll(java.util.Collection,java.lang.Object[])>(v17, v20);
v21 = virtualinvoke v6.<java.lang.String: boolean isEmpty()>();
if v21 == 0 goto label05;
interfaceinvoke v17.<java.util.Set: boolean remove(java.lang.Object)>("TLSv1");
interfaceinvoke v17.<java.util.Set: boolean remove(java.lang.Object)>("TLSv1.1");
interfaceinvoke v17.<java.util.Set: boolean remove(java.lang.Object)>("TLSv1.2");
interfaceinvoke v17.<java.util.Set: boolean remove(java.lang.Object)>("SSLv3");
interfaceinvoke v17.<java.util.Set: boolean remove(java.lang.Object)>("SSLv2");
interfaceinvoke v17.<java.util.Set: boolean remove(java.lang.Object)>("SSLv2Hello");
label05:
v22 = virtualinvoke v7.<java.lang.String: boolean isEmpty()>();
if v22 == 0 goto label06;
interfaceinvoke v17.<java.util.Set: boolean remove(java.lang.Object)>("TLSv1.3");
label06:
v23 = <io.netty.util.internal.EmptyArrays: java.lang.String[] EMPTY_STRINGS>;
v24 = interfaceinvoke v17.<java.util.Set: java.lang.Object[] toArray(java.lang.Object[])>(v23);
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void setEnabledProtocols0(java.lang.String[],boolean)>(v24, 0);
label07:
goto label10;
label08:
v25 := @caughtexception;
v26 = new java.lang.IllegalStateException;
v27 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v6) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("failed to enable cipher suites: \u0001");
specialinvoke v26.<java.lang.IllegalStateException: void <init>(java.lang.String,java.lang.Throwable)>(v27, v25);
throw v26;
label09:
v28 = new java.lang.IllegalStateException;
v29 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v6) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("failed to enable cipher suites: \u0001");
specialinvoke v28.<java.lang.IllegalStateException: void <init>(java.lang.String)>(v29);
throw v28;
label10:
exitmonitor v0;
label11:
goto label13;
label12:
v30 := @caughtexception;
exitmonitor v0;
throw v30;
label13:
return;
catch java.lang.Exception from label03 to label07 with label08;
catch java.lang.Throwable from label02 to label11 with label12;
}
public final java.lang.String[] getSupportedProtocols()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.lang.Object[] v3;
java.util.Set v1;
java.lang.String[] v2;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = <io.netty.handler.ssl.OpenSsl: java.util.Set SUPPORTED_PROTOCOLS_SET>;
v2 = newarray (java.lang.String)[0];
v3 = interfaceinvoke v1.<java.util.Set: java.lang.Object[] toArray(java.lang.Object[])>(v2);
return v3;
}
public final java.lang.String[] getEnabledProtocols()
{
java.lang.Throwable v7;
java.lang.Object[] v21, v6;
java.lang.String[] v20, v5;
long v3;
java.util.ArrayList v1;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
int v10, v12, v14, v16, v18, v4, v8;
boolean v11, v13, v15, v17, v19, v2, v9;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = new java.util.ArrayList;
specialinvoke v1.<java.util.ArrayList: void <init>(int)>(6);
interfaceinvoke v1.<java.util.List: boolean add(java.lang.Object)>("SSLv2Hello");
entermonitor v0;
label01:
v2 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v2 != 0 goto label02;
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v4 = staticinvoke <io.netty.internal.tcnative.SSL: int getOptions(long)>(v3);
goto label04;
label02:
v5 = newarray (java.lang.String)[0];
v6 = interfaceinvoke v1.<java.util.List: java.lang.Object[] toArray(java.lang.Object[])>(v5);
exitmonitor v0;
label03:
return v6;
label04:
exitmonitor v0;
label05:
goto label07;
label06:
v7 := @caughtexception;
exitmonitor v0;
throw v7;
label07:
v8 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_TLSv1>;
v9 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isProtocolEnabled(int,int,java.lang.String)>(v4, v8, "TLSv1");
if v9 == 0 goto label08;
interfaceinvoke v1.<java.util.List: boolean add(java.lang.Object)>("TLSv1");
label08:
v10 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_TLSv1_1>;
v11 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isProtocolEnabled(int,int,java.lang.String)>(v4, v10, "TLSv1.1");
if v11 == 0 goto label09;
interfaceinvoke v1.<java.util.List: boolean add(java.lang.Object)>("TLSv1.1");
label09:
v12 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_TLSv1_2>;
v13 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isProtocolEnabled(int,int,java.lang.String)>(v4, v12, "TLSv1.2");
if v13 == 0 goto label10;
interfaceinvoke v1.<java.util.List: boolean add(java.lang.Object)>("TLSv1.2");
label10:
v14 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_TLSv1_3>;
v15 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isProtocolEnabled(int,int,java.lang.String)>(v4, v14, "TLSv1.3");
if v15 == 0 goto label11;
interfaceinvoke v1.<java.util.List: boolean add(java.lang.Object)>("TLSv1.3");
label11:
v16 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_SSLv2>;
v17 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isProtocolEnabled(int,int,java.lang.String)>(v4, v16, "SSLv2");
if v17 == 0 goto label12;
interfaceinvoke v1.<java.util.List: boolean add(java.lang.Object)>("SSLv2");
label12:
v18 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_SSLv3>;
v19 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isProtocolEnabled(int,int,java.lang.String)>(v4, v18, "SSLv3");
if v19 == 0 goto label13;
interfaceinvoke v1.<java.util.List: boolean add(java.lang.Object)>("SSLv3");
label13:
v20 = newarray (java.lang.String)[0];
v21 = interfaceinvoke v1.<java.util.List: java.lang.Object[] toArray(java.lang.Object[])>(v20);
return v21;
catch java.lang.Throwable from label01 to label03 with label06;
catch java.lang.Throwable from label04 to label05 with label06;
}
private static boolean isProtocolEnabled(int, int, java.lang.String)
{
int v0, v1, v3;
java.util.Set v4;
java.lang.String v2;
boolean v5, v6;
v0 := @parameter0: int;
v1 := @parameter1: int;
v2 := @parameter2: java.lang.String;
v3 = v0 & v1;
if v3 != 0 goto label1;
v4 = <io.netty.handler.ssl.OpenSsl: java.util.Set SUPPORTED_PROTOCOLS_SET>;
v5 = interfaceinvoke v4.<java.util.Set: boolean contains(java.lang.Object)>(v2);
if v5 == 0 goto label1;
v6 = 1;
goto label2;
label1:
v6 = 0;
label2:
return v6;
}
public final void setEnabledProtocols(java.lang.String[])
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.lang.String[] v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: java.lang.String[];
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void setEnabledProtocols0(java.lang.String[],boolean)>(v1, 1);
return;
}
private void setEnabledProtocols0(java.lang.String[], boolean)
{
java.lang.IllegalStateException v44;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
byte v5;
int[] v3, v34, v39, v41;
boolean v10, v13, v14, v15, v16, v17, v18, v19, v2, v36;
java.util.Set v9;
java.util.List v45;
java.lang.Throwable v47;
java.lang.String[] v1;
long v20, v43;
java.lang.AssertionError v37;
int v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v35, v38, v4, v40, v42, v6, v7;
java.lang.String v12, v46, v8;
java.lang.IllegalArgumentException v11;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: java.lang.String[];
v2 := @parameter1: boolean;
staticinvoke <io.netty.util.internal.ObjectUtil: java.lang.Object checkNotNullWithIAE(java.lang.Object,java.lang.String)>(v1, "protocols");
v3 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int[] OPENSSL_OP_NO_PROTOCOLS>;
v4 = lengthof v3;
v5 = 0;
v6 = lengthof v1;
v7 = 0;
label01:
if v7 >= v6 goto label15;
v8 = v1[v7];
v9 = <io.netty.handler.ssl.OpenSsl: java.util.Set SUPPORTED_PROTOCOLS_SET>;
v10 = interfaceinvoke v9.<java.util.Set: boolean contains(java.lang.Object)>(v8);
if v10 != 0 goto label02;
v11 = new java.lang.IllegalArgumentException;
v12 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v8) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Protocol \u0001 is not supported.");
specialinvoke v11.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(v12);
throw v11;
label02:
v13 = virtualinvoke v8.<java.lang.String: boolean equals(java.lang.Object)>("SSLv2");
if v13 == 0 goto label04;
if v4 <= 0 goto label03;
v4 = 0;
label03:
if v5 >= 0 goto label14;
v5 = 0;
goto label14;
label04:
v14 = virtualinvoke v8.<java.lang.String: boolean equals(java.lang.Object)>("SSLv3");
if v14 == 0 goto label06;
if v4 <= 1 goto label05;
v4 = 1;
label05:
if v5 >= 1 goto label14;
v5 = 1;
goto label14;
label06:
v15 = virtualinvoke v8.<java.lang.String: boolean equals(java.lang.Object)>("TLSv1");
if v15 == 0 goto label08;
if v4 <= 2 goto label07;
v4 = 2;
label07:
if v5 >= 2 goto label14;
v5 = 2;
goto label14;
label08:
v16 = virtualinvoke v8.<java.lang.String: boolean equals(java.lang.Object)>("TLSv1.1");
if v16 == 0 goto label10;
if v4 <= 3 goto label09;
v4 = 3;
label09:
if v5 >= 3 goto label14;
v5 = 3;
goto label14;
label10:
v17 = virtualinvoke v8.<java.lang.String: boolean equals(java.lang.Object)>("TLSv1.2");
if v17 == 0 goto label12;
if v4 <= 4 goto label11;
v4 = 4;
label11:
if v5 >= 4 goto label14;
v5 = 4;
goto label14;
label12:
v18 = virtualinvoke v8.<java.lang.String: boolean equals(java.lang.Object)>("TLSv1.3");
if v18 == 0 goto label14;
if v4 <= 5 goto label13;
v4 = 5;
label13:
if v5 >= 5 goto label14;
v5 = 5;
label14:
v7 = v7 + 1;
goto label01;
label15:
entermonitor v0;
label16:
if v2 == 0 goto label17;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.String[] explicitlyEnabledProtocols> = v1;
label17:
v19 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v19 != 0 goto label23;
v20 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v21 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_SSLv2>;
v22 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_SSLv3>;
v23 = v21 | v22;
v24 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_TLSv1>;
v25 = v23 | v24;
v26 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_TLSv1_1>;
v27 = v25 | v26;
v28 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_TLSv1_2>;
v29 = v27 | v28;
v30 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_TLSv1_3>;
v31 = v29 | v30;
staticinvoke <io.netty.internal.tcnative.SSL: void clearOptions(long,int)>(v20, v31);
v32 = 0;
v33 = 0;
label18:
if v33 >= v4 goto label19;
v34 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int[] OPENSSL_OP_NO_PROTOCOLS>;
v35 = v34[v33];
v32 = v32 | v35;
v33 = v33 + 1;
goto label18;
label19:
v36 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v36 != 0 goto label20;
if v5 != 2147483647 goto label20;
v37 = new java.lang.AssertionError;
specialinvoke v37.<java.lang.AssertionError: void <init>()>();
throw v37;
label20:
v38 = v5 + 1;
label21:
v39 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int[] OPENSSL_OP_NO_PROTOCOLS>;
v40 = lengthof v39;
if v38 >= v40 goto label22;
v41 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int[] OPENSSL_OP_NO_PROTOCOLS>;
v42 = v41[v38];
v32 = v32 | v42;
v38 = v38 + 1;
goto label21;
label22:
v43 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
staticinvoke <io.netty.internal.tcnative.SSL: void setOptions(long,int)>(v43, v32);
goto label24;
label23:
v44 = new java.lang.IllegalStateException;
v45 = staticinvoke <java.util.Arrays: java.util.List asList(java.lang.Object[])>(v1);
v46 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.util.List)>(v45) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("failed to enable protocols: \u0001");
specialinvoke v44.<java.lang.IllegalStateException: void <init>(java.lang.String)>(v46);
throw v44;
label24:
exitmonitor v0;
label25:
goto label27;
label26:
v47 := @caughtexception;
exitmonitor v0;
throw v47;
label27:
return;
catch java.lang.Throwable from label16 to label25 with label26;
}
public final javax.net.ssl.SSLSession getSession()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
io.netty.handler.ssl.OpenSslSession v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.OpenSslSession session>;
return v1;
}
public final synchronized void beginHandshake() throws javax.net.ssl.SSLException
{
java.lang.Error v10;
javax.net.ssl.SSLEngineResult$HandshakeStatus v8, v9;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
javax.net.ssl.SSLException v6;
int[] v1;
int v3, v4;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState v2, v5, v7;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$3: int[] $SwitchMap$io$netty$handler$ssl$ReferenceCountedOpenSslEngine$HandshakeState>;
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState handshakeState>;
v3 = virtualinvoke v2.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState: int ordinal()>();
v4 = v1[v3];
tableswitch(v4)
{
case 1: goto label3;
case 2: goto label2;
case 3: goto label1;
case 4: goto label6;
default: goto label5;
};
label1:
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void checkEngineClosed()>();
v5 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState STARTED_EXPLICITLY>;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState handshakeState> = v5;
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void calculateMaxWrapOverhead()>();
goto label6;
label2:
v6 = new javax.net.ssl.SSLException;
specialinvoke v6.<javax.net.ssl.SSLException: void <init>(java.lang.String)>("renegotiation unsupported");
throw v6;
label3:
v7 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState STARTED_EXPLICITLY>;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState handshakeState> = v7;
v8 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult$HandshakeStatus handshake()>();
v9 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_TASK>;
if v8 != v9 goto label4;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean needTask> = 1;
label4:
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void calculateMaxWrapOverhead()>();
goto label6;
label5:
v10 = new java.lang.Error;
specialinvoke v10.<java.lang.Error: void <init>()>();
throw v10;
label6:
return;
}
private void checkEngineClosed() throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
javax.net.ssl.SSLException v2;
boolean v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v1 == 0 goto label1;
v2 = new javax.net.ssl.SSLException;
specialinvoke v2.<javax.net.ssl.SSLException: void <init>(java.lang.String)>("engine closed");
throw v2;
label1:
return;
}
private static javax.net.ssl.SSLEngineResult$HandshakeStatus pendingStatus(int)
{
int v0;
javax.net.ssl.SSLEngineResult$HandshakeStatus v1;
v0 := @parameter0: int;
if v0 <= 0 goto label1;
v1 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_WRAP>;
goto label2;
label1:
v1 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_UNWRAP>;
label2:
return v1;
}
private static boolean isEmpty(java.lang.Object[])
{
int v1;
java.lang.Object[] v0;
boolean v2;
v0 := @parameter0: java.lang.Object[];
if v0 == null goto label1;
v1 = lengthof v0;
if v1 != 0 goto label2;
label1:
v2 = 1;
goto label3;
label2:
v2 = 0;
label3:
return v2;
}
private static boolean isEmpty(byte[])
{
int v1;
byte[] v0;
boolean v2;
v0 := @parameter0: byte[];
if v0 == null goto label1;
v1 = lengthof v0;
if v1 != 0 goto label2;
label1:
v2 = 1;
goto label3;
label2:
v2 = 0;
label3:
return v2;
}
private javax.net.ssl.SSLEngineResult$HandshakeStatus handshakeException() throws javax.net.ssl.SSLException
{
java.lang.Throwable v4;
javax.net.ssl.SSLHandshakeException v8;
javax.net.ssl.SSLEngineResult$HandshakeStatus v3;
long v1;
java.lang.AssertionError v6;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
int v2;
boolean v5, v7;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v2 = staticinvoke <io.netty.internal.tcnative.SSL: int bioLengthNonApplication(long)>(v1);
if v2 <= 0 goto label1;
v3 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_WRAP>;
return v3;
label1:
v4 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.Throwable pendingException>;
v5 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v5 != 0 goto label2;
if v4 != null goto label2;
v6 = new java.lang.AssertionError;
specialinvoke v6.<java.lang.AssertionError: void <init>()>();
throw v6;
label2:
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.Throwable pendingException> = null;
virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void shutdown()>();
v7 = v4 instanceof javax.net.ssl.SSLHandshakeException;
if v7 == 0 goto label3;
throw v4;
label3:
v8 = new javax.net.ssl.SSLHandshakeException;
specialinvoke v8.<javax.net.ssl.SSLHandshakeException: void <init>(java.lang.String)>("General OpenSslEngine problem");
virtualinvoke v8.<javax.net.ssl.SSLHandshakeException: java.lang.Throwable initCause(java.lang.Throwable)>(v4);
throw v8;
}
final void initHandshakeException(java.lang.Throwable)
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.lang.Throwable v1, v2, v3;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: java.lang.Throwable;
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.Throwable pendingException>;
if v2 != null goto label1;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.Throwable pendingException> = v1;
goto label2;
label1:
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.Throwable pendingException>;
staticinvoke <io.netty.util.internal.ThrowableUtil: void addSuppressed(java.lang.Throwable,java.lang.Throwable)>(v3, v1);
label2:
return;
}
private javax.net.ssl.SSLEngineResult$HandshakeStatus handshake() throws javax.net.ssl.SSLException
{
byte[] v44, v50;
javax.net.ssl.SSLEngineResult$HandshakeStatus v2, v28, v32, v35, v37, v41, v5, v59, v9;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
byte v18;
boolean v1, v11, v34;
io.netty.handler.ssl.OpenSslEngineMap v10;
byte[][] v52;
javax.net.ssl.SSLException v38;
io.netty.handler.ssl.OpenSslSessionContext v13;
java.lang.Throwable v36, v6;
long v16, v17, v19, v20, v22, v26, v39, v43, v45, v47, v49, v51, v53, v54, v55, v57, v58, v7;
int v15, v21, v23, v24, v25, v27, v29, v30, v31, v33, v40, v8;
java.lang.String v14, v46, v48;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState v3, v4;
io.netty.handler.ssl.OpenSslSession v42;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v12, v56;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean needTask>;
if v1 == 0 goto label01;
v2 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_TASK>;
return v2;
label01:
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState handshakeState>;
v4 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState FINISHED>;
if v3 != v4 goto label02;
v5 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus FINISHED>;
return v5;
label02:
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void checkEngineClosed()>();
v6 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.Throwable pendingException>;
if v6 == null goto label04;
v7 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v8 = staticinvoke <io.netty.internal.tcnative.SSL: int doHandshake(long)>(v7);
if v8 > 0 goto label03;
staticinvoke <io.netty.internal.tcnative.SSL: void clearError()>();
label03:
v9 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult$HandshakeStatus handshakeException()>();
return v9;
label04:
v10 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.OpenSslEngineMap engineMap>;
interfaceinvoke v10.<io.netty.handler.ssl.OpenSslEngineMap: void add(io.netty.handler.ssl.ReferenceCountedOpenSslEngine)>(v0);
v11 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean sessionSet>;
if v11 != 0 goto label05;
v12 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslContext parentContext>;
v13 = virtualinvoke v12.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.handler.ssl.OpenSslSessionContext sessionContext()>();
v14 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.String getPeerHost()>();
v15 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int getPeerPort()>();
v16 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
virtualinvoke v13.<io.netty.handler.ssl.OpenSslSessionContext: void setSessionFromCache(java.lang.String,int,long)>(v14, v15, v16);
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean sessionSet> = 1;
label05:
v17 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long lastAccessed>;
v18 = v17 cmp -1L;
if v18 != 0 goto label06;
v19 = staticinvoke <java.lang.System: long currentTimeMillis()>();
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long lastAccessed> = v19;
label06:
v20 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v21 = staticinvoke <io.netty.internal.tcnative.SSL: int doHandshake(long)>(v20);
if v21 > 0 goto label13;
v22 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v23 = staticinvoke <io.netty.internal.tcnative.SSL: int getError(long,int)>(v22, v21);
v24 = <io.netty.internal.tcnative.SSL: int SSL_ERROR_WANT_READ>;
if v23 == v24 goto label07;
v25 = <io.netty.internal.tcnative.SSL: int SSL_ERROR_WANT_WRITE>;
if v23 != v25 goto label08;
label07:
v26 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v27 = staticinvoke <io.netty.internal.tcnative.SSL: int bioLengthNonApplication(long)>(v26);
v28 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult$HandshakeStatus pendingStatus(int)>(v27);
return v28;
label08:
v29 = <io.netty.internal.tcnative.SSL: int SSL_ERROR_WANT_X509_LOOKUP>;
if v23 == v29 goto label09;
v30 = <io.netty.internal.tcnative.SSL: int SSL_ERROR_WANT_CERTIFICATE_VERIFY>;
if v23 == v30 goto label09;
v31 = <io.netty.internal.tcnative.SSL: int SSL_ERROR_WANT_PRIVATE_KEY_OPERATION>;
if v23 != v31 goto label10;
label09:
v32 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_TASK>;
return v32;
label10:
v33 = staticinvoke <io.netty.internal.tcnative.SSL: int getLastErrorNumber()>();
v34 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean needWrapAgain(int)>(v33);
if v34 == 0 goto label11;
v35 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_WRAP>;
return v35;
label11:
v36 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.Throwable pendingException>;
if v36 == null goto label12;
v37 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult$HandshakeStatus handshakeException()>();
return v37;
label12:
v38 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLException shutdownWithError(java.lang.String,int)>("SSL_do_handshake", v23);
throw v38;
label13:
v39 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v40 = staticinvoke <io.netty.internal.tcnative.SSL: int bioLengthNonApplication(long)>(v39);
if v40 <= 0 goto label14;
v41 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_WRAP>;
return v41;
label14:
v42 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.OpenSslSession session>;
v43 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v44 = staticinvoke <io.netty.internal.tcnative.SSL: byte[] getSessionId(long)>(v43);
v45 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v46 = staticinvoke <io.netty.internal.tcnative.SSL: java.lang.String getCipherForSSL(long)>(v45);
v47 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v48 = staticinvoke <io.netty.internal.tcnative.SSL: java.lang.String getVersion(long)>(v47);
v49 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v50 = staticinvoke <io.netty.internal.tcnative.SSL: byte[] getPeerCertificate(long)>(v49);
v51 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v52 = staticinvoke <io.netty.internal.tcnative.SSL: byte[][] getPeerCertChain(long)>(v51);
v53 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v54 = staticinvoke <io.netty.internal.tcnative.SSL: long getTime(long)>(v53);
v55 = v54 * 1000L;
v56 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslContext parentContext>;
v57 = virtualinvoke v56.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long sessionTimeout()>();
v58 = v57 * 1000L;
interfaceinvoke v42.<io.netty.handler.ssl.OpenSslSession: void handshakeFinished(byte[],java.lang.String,java.lang.String,byte[],byte[][],long,long)>(v44, v46, v48, v50, v52, v55, v58);
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void selectApplicationProtocol()>();
v59 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus FINISHED>;
return v59;
}
private javax.net.ssl.SSLEngineResult$HandshakeStatus mayFinishHandshake(javax.net.ssl.SSLEngineResult$HandshakeStatus, int, int) throws javax.net.ssl.SSLException
{
javax.net.ssl.SSLEngineResult$HandshakeStatus v1, v4, v5, v6, v7, v8;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
int v2, v3;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: javax.net.ssl.SSLEngineResult$HandshakeStatus;
v2 := @parameter1: int;
v3 := @parameter2: int;
v4 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_UNWRAP>;
if v1 != v4 goto label1;
if v3 > 0 goto label2;
label1:
v5 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_WRAP>;
if v1 != v5 goto label3;
if v2 <= 0 goto label3;
label2:
v6 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult$HandshakeStatus handshake()>();
goto label6;
label3:
v7 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus FINISHED>;
if v1 == v7 goto label4;
v8 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult$HandshakeStatus getHandshakeStatus()>();
goto label5;
label4:
v8 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus FINISHED>;
label5:
v6 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult$HandshakeStatus mayFinishHandshake(javax.net.ssl.SSLEngineResult$HandshakeStatus)>(v8);
label6:
return v6;
}
private javax.net.ssl.SSLEngineResult$HandshakeStatus mayFinishHandshake(javax.net.ssl.SSLEngineResult$HandshakeStatus) throws javax.net.ssl.SSLException
{
javax.net.ssl.SSLEngineResult$HandshakeStatus v1, v2, v5, v9;
long v7;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
int v8;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState v3, v4;
boolean v6;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: javax.net.ssl.SSLEngineResult$HandshakeStatus;
v2 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NOT_HANDSHAKING>;
if v1 != v2 goto label2;
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState handshakeState>;
v4 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState FINISHED>;
if v3 == v4 goto label1;
v5 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult$HandshakeStatus handshake()>();
return v5;
label1:
v6 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v6 != 0 goto label2;
v7 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v8 = staticinvoke <io.netty.internal.tcnative.SSL: int bioLengthNonApplication(long)>(v7);
if v8 <= 0 goto label2;
v9 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_WRAP>;
return v9;
label2:
return v1;
}
public final synchronized javax.net.ssl.SSLEngineResult$HandshakeStatus getHandshakeStatus()
{
javax.net.ssl.SSLEngineResult$HandshakeStatus v3, v6, v7;
long v4;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
int v5;
boolean v1, v2;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean needPendingStatus()>();
if v1 == 0 goto label2;
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean needTask>;
if v2 == 0 goto label1;
v3 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_TASK>;
return v3;
label1:
v4 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long networkBIO>;
v5 = staticinvoke <io.netty.internal.tcnative.SSL: int bioLengthNonApplication(long)>(v4);
v6 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult$HandshakeStatus pendingStatus(int)>(v5);
return v6;
label2:
v7 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NOT_HANDSHAKING>;
return v7;
}
private javax.net.ssl.SSLEngineResult$HandshakeStatus getHandshakeStatus(int)
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
int v1;
javax.net.ssl.SSLEngineResult$HandshakeStatus v4, v5, v6;
boolean v2, v3;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: int;
v2 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean needPendingStatus()>();
if v2 == 0 goto label2;
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean needTask>;
if v3 == 0 goto label1;
v4 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_TASK>;
return v4;
label1:
v5 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult$HandshakeStatus pendingStatus(int)>(v1);
return v5;
label2:
v6 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NOT_HANDSHAKING>;
return v6;
}
private boolean needPendingStatus()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState v1, v2, v4, v5;
boolean v3, v6, v7, v8;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState handshakeState>;
v2 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState NOT_STARTED>;
if v1 == v2 goto label2;
v3 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v3 != 0 goto label2;
v4 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState handshakeState>;
v5 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState: io.netty.handler.ssl.ReferenceCountedOpenSslEngine$HandshakeState FINISHED>;
if v4 != v5 goto label1;
v6 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isInboundDone()>();
if v6 != 0 goto label1;
v7 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isOutboundDone()>();
if v7 == 0 goto label2;
label1:
v8 = 1;
goto label3;
label2:
v8 = 0;
label3:
return v8;
}
private java.lang.String toJavaCipherSuite(java.lang.String)
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
long v2;
java.lang.String v1, v3, v4, v5;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: java.lang.String;
if v1 != null goto label1;
return null;
label1:
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v3 = staticinvoke <io.netty.internal.tcnative.SSL: java.lang.String getVersion(long)>(v2);
v4 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.String toJavaCipherSuitePrefix(java.lang.String)>(v3);
v5 = staticinvoke <io.netty.handler.ssl.CipherSuiteConverter: java.lang.String toJava(java.lang.String,java.lang.String)>(v1, v4);
return v5;
}
private static java.lang.String toJavaCipherSuitePrefix(java.lang.String)
{
int v2;
java.lang.String v0;
boolean v1;
v0 := @parameter0: java.lang.String;
if v0 == null goto label1;
v1 = virtualinvoke v0.<java.lang.String: boolean isEmpty()>();
if v1 == 0 goto label2;
label1:
v2 = 0;
goto label3;
label2:
v2 = virtualinvoke v0.<java.lang.String: char charAt(int)>(0);
label3:
lookupswitch(v2)
{
case 83: goto label5;
case 84: goto label4;
default: goto label6;
};
label4:
return "TLS";
label5:
return "SSL";
label6:
return "UNKNOWN";
}
public final void setUseClientMode(boolean)
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.lang.UnsupportedOperationException v3;
boolean v1, v2;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: boolean;
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean clientMode>;
if v1 == v2 goto label1;
v3 = new java.lang.UnsupportedOperationException;
specialinvoke v3.<java.lang.UnsupportedOperationException: void <init>()>();
throw v3;
label1:
return;
}
public final boolean getUseClientMode()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
boolean v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean clientMode>;
return v1;
}
public final void setNeedClientAuth(boolean)
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
io.netty.handler.ssl.ClientAuth v2;
boolean v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: boolean;
if v1 == 0 goto label1;
v2 = <io.netty.handler.ssl.ClientAuth: io.netty.handler.ssl.ClientAuth REQUIRE>;
goto label2;
label1:
v2 = <io.netty.handler.ssl.ClientAuth: io.netty.handler.ssl.ClientAuth NONE>;
label2:
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void setClientAuth(io.netty.handler.ssl.ClientAuth)>(v2);
return;
}
public final boolean getNeedClientAuth()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
io.netty.handler.ssl.ClientAuth v1, v2;
boolean v3;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ClientAuth clientAuth>;
v2 = <io.netty.handler.ssl.ClientAuth: io.netty.handler.ssl.ClientAuth REQUIRE>;
if v1 != v2 goto label1;
v3 = 1;
goto label2;
label1:
v3 = 0;
label2:
return v3;
}
public final void setWantClientAuth(boolean)
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
io.netty.handler.ssl.ClientAuth v2;
boolean v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: boolean;
if v1 == 0 goto label1;
v2 = <io.netty.handler.ssl.ClientAuth: io.netty.handler.ssl.ClientAuth OPTIONAL>;
goto label2;
label1:
v2 = <io.netty.handler.ssl.ClientAuth: io.netty.handler.ssl.ClientAuth NONE>;
label2:
specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void setClientAuth(io.netty.handler.ssl.ClientAuth)>(v2);
return;
}
public final boolean getWantClientAuth()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
io.netty.handler.ssl.ClientAuth v1, v2;
boolean v3;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ClientAuth clientAuth>;
v2 = <io.netty.handler.ssl.ClientAuth: io.netty.handler.ssl.ClientAuth OPTIONAL>;
if v1 != v2 goto label1;
v3 = 1;
goto label2;
label1:
v3 = 0;
label2:
return v3;
}
public final synchronized void setVerify(int, int)
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
int v1, v2;
long v4;
boolean v3;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: int;
v2 := @parameter1: int;
v3 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v3 != 0 goto label1;
v4 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
staticinvoke <io.netty.internal.tcnative.SSL: void setVerify(long,int,int)>(v4, v1, v2);
label1:
return;
}
private void setClientAuth(io.netty.handler.ssl.ClientAuth)
{
java.lang.Throwable v13;
java.lang.Error v11;
long v10, v8, v9;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
io.netty.handler.ssl.ClientAuth v1, v3;
int[] v5;
int v6, v7;
java.lang.String v12;
boolean v2, v4;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: io.netty.handler.ssl.ClientAuth;
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean clientMode>;
if v2 == 0 goto label01;
return;
label01:
entermonitor v0;
label02:
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ClientAuth clientAuth>;
if v3 != v1 goto label04;
exitmonitor v0;
label03:
return;
label04:
v4 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v4 != 0 goto label09;
v5 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$3: int[] $SwitchMap$io$netty$handler$ssl$ClientAuth>;
v6 = virtualinvoke v1.<io.netty.handler.ssl.ClientAuth: int ordinal()>();
v7 = v5[v6];
tableswitch(v7)
{
case 1: goto label05;
case 2: goto label06;
case 3: goto label07;
default: goto label08;
};
label05:
v8 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
staticinvoke <io.netty.internal.tcnative.SSL: void setVerify(long,int,int)>(v8, 0, 10);
goto label09;
label06:
v9 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
staticinvoke <io.netty.internal.tcnative.SSL: void setVerify(long,int,int)>(v9, 2, 10);
goto label09;
label07:
v10 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
staticinvoke <io.netty.internal.tcnative.SSL: void setVerify(long,int,int)>(v10, 1, 10);
goto label09;
label08:
v11 = new java.lang.Error;
v12 = virtualinvoke v1.<io.netty.handler.ssl.ClientAuth: java.lang.String toString()>();
specialinvoke v11.<java.lang.Error: void <init>(java.lang.String)>(v12);
throw v11;
label09:
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.ClientAuth clientAuth> = v1;
exitmonitor v0;
label10:
goto label12;
label11:
v13 := @caughtexception;
exitmonitor v0;
throw v13;
label12:
return;
catch java.lang.Throwable from label02 to label03 with label11;
catch java.lang.Throwable from label04 to label10 with label11;
}
public final void setEnableSessionCreation(boolean)
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.lang.UnsupportedOperationException v2;
boolean v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: boolean;
if v1 == 0 goto label1;
v2 = new java.lang.UnsupportedOperationException;
specialinvoke v2.<java.lang.UnsupportedOperationException: void <init>()>();
throw v2;
label1:
return;
}
public final boolean getEnableSessionCreation()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
return 0;
}
public final synchronized javax.net.ssl.SSLParameters getSSLParameters()
{
java.util.Collection v13;
javax.net.ssl.SSLParameters v1;
long v8;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.util.List v5, v6;
int v10, v11, v2, v9;
java.lang.Object v4;
java.lang.String v3;
boolean v12, v7;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = specialinvoke v0.<javax.net.ssl.SSLEngine: javax.net.ssl.SSLParameters getSSLParameters()>();
v2 = staticinvoke <io.netty.util.internal.PlatformDependent: int javaVersion()>();
if v2 < 7 goto label5;
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.String endPointIdentificationAlgorithm>;
virtualinvoke v1.<javax.net.ssl.SSLParameters: void setEndpointIdentificationAlgorithm(java.lang.String)>(v3);
v4 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.Object algorithmConstraints>;
staticinvoke <io.netty.handler.ssl.Java7SslParametersUtils: void setAlgorithmConstraints(javax.net.ssl.SSLParameters,java.lang.Object)>(v1, v4);
if v2 < 8 goto label5;
v5 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.util.List sniHostNames>;
if v5 == null goto label1;
v6 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.util.List sniHostNames>;
staticinvoke <io.netty.handler.ssl.Java8SslUtils: void setSniHostNames(javax.net.ssl.SSLParameters,java.util.List)>(v1, v6);
label1:
v7 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v7 != 0 goto label4;
v8 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v9 = staticinvoke <io.netty.internal.tcnative.SSL: int getOptions(long)>(v8);
v10 = <io.netty.internal.tcnative.SSL: int SSL_OP_CIPHER_SERVER_PREFERENCE>;
v11 = v9 & v10;
if v11 == 0 goto label2;
v12 = 1;
goto label3;
label2:
v12 = 0;
label3:
staticinvoke <io.netty.handler.ssl.Java8SslUtils: void setUseCipherSuitesOrder(javax.net.ssl.SSLParameters,boolean)>(v1, v12);
label4:
v13 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.util.Collection matchers>;
staticinvoke <io.netty.handler.ssl.Java8SslUtils: void setSNIMatchers(javax.net.ssl.SSLParameters,java.util.Collection)>(v1, v13);
label5:
return v1;
}
public final synchronized void setSSLParameters(javax.net.ssl.SSLParameters)
{
javax.net.ssl.SSLParameters v1;
long v11, v13, v15, v21;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
int v14, v16, v2, v22;
java.lang.String v18;
boolean v12, v19, v20, v5, v6, v9;
java.util.Iterator v8;
java.util.Collection v17;
java.lang.IllegalArgumentException v4;
java.util.List v7;
java.security.AlgorithmConstraints v23, v3;
java.lang.Object v10;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: javax.net.ssl.SSLParameters;
v2 = staticinvoke <io.netty.util.internal.PlatformDependent: int javaVersion()>();
if v2 < 7 goto label9;
v3 = virtualinvoke v1.<javax.net.ssl.SSLParameters: java.security.AlgorithmConstraints getAlgorithmConstraints()>();
if v3 == null goto label1;
v4 = new java.lang.IllegalArgumentException;
specialinvoke v4.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>("AlgorithmConstraints are not supported.");
throw v4;
label1:
v5 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isDestroyed()>();
if v2 < 8 goto label7;
if v5 != 0 goto label6;
v6 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean clientMode>;
if v6 == 0 goto label4;
v7 = staticinvoke <io.netty.handler.ssl.Java8SslUtils: java.util.List getSniHostNames(javax.net.ssl.SSLParameters)>(v1);
v8 = interfaceinvoke v7.<java.util.List: java.util.Iterator iterator()>();
label2:
v9 = interfaceinvoke v8.<java.util.Iterator: boolean hasNext()>();
if v9 == 0 goto label3;
v10 = interfaceinvoke v8.<java.util.Iterator: java.lang.Object next()>();
v11 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
staticinvoke <io.netty.internal.tcnative.SSL: void setTlsExtHostName(long,java.lang.String)>(v11, v10);
goto label2;
label3:
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.util.List sniHostNames> = v7;
label4:
v12 = staticinvoke <io.netty.handler.ssl.Java8SslUtils: boolean getUseCipherSuitesOrder(javax.net.ssl.SSLParameters)>(v1);
if v12 == 0 goto label5;
v13 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v14 = <io.netty.internal.tcnative.SSL: int SSL_OP_CIPHER_SERVER_PREFERENCE>;
staticinvoke <io.netty.internal.tcnative.SSL: void setOptions(long,int)>(v13, v14);
goto label6;
label5:
v15 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v16 = <io.netty.internal.tcnative.SSL: int SSL_OP_CIPHER_SERVER_PREFERENCE>;
staticinvoke <io.netty.internal.tcnative.SSL: void clearOptions(long,int)>(v15, v16);
label6:
v17 = virtualinvoke v1.<javax.net.ssl.SSLParameters: java.util.Collection getSNIMatchers()>();
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.util.Collection matchers> = v17;
label7:
v18 = virtualinvoke v1.<javax.net.ssl.SSLParameters: java.lang.String getEndpointIdentificationAlgorithm()>();
if v5 != 0 goto label8;
v19 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean clientMode>;
if v19 == 0 goto label8;
v20 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean isEndPointVerificationEnabled(java.lang.String)>(v18);
if v20 == 0 goto label8;
v21 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v22 = (int) -1;
staticinvoke <io.netty.internal.tcnative.SSL: void setVerify(long,int,int)>(v21, 2, v22);
label8:
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.String endPointIdentificationAlgorithm> = v18;
v23 = virtualinvoke v1.<javax.net.ssl.SSLParameters: java.security.AlgorithmConstraints getAlgorithmConstraints()>();
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.Object algorithmConstraints> = v23;
label9:
specialinvoke v0.<javax.net.ssl.SSLEngine: void setSSLParameters(javax.net.ssl.SSLParameters)>(v1);
return;
}
private static boolean isEndPointVerificationEnabled(java.lang.String)
{
java.lang.String v0;
boolean v1, v2;
v0 := @parameter0: java.lang.String;
if v0 == null goto label1;
v1 = virtualinvoke v0.<java.lang.String: boolean isEmpty()>();
if v1 != 0 goto label1;
v2 = 1;
goto label2;
label1:
v2 = 0;
label2:
return v2;
}
private boolean isDestroyed()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
boolean v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean destroyed>;
return v1;
}
final boolean checkSniHostnameMatch(byte[])
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
byte[] v1;
java.util.Collection v2;
boolean v3;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: byte[];
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.util.Collection matchers>;
v3 = staticinvoke <io.netty.handler.ssl.Java8SslUtils: boolean checkSniHostnameMatch(java.util.Collection,byte[])>(v2, v1);
return v3;
}
public java.lang.String getNegotiatedApplicationProtocol()
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.lang.String v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.String applicationProtocol>;
return v1;
}
private static long bufferAddress(java.nio.ByteBuffer)
{
long v5, v6;
java.lang.AssertionError v3;
java.nio.ByteBuffer v0;
boolean v1, v2, v4;
v0 := @parameter0: java.nio.ByteBuffer;
v1 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v1 != 0 goto label1;
v2 = virtualinvoke v0.<java.nio.ByteBuffer: boolean isDirect()>();
if v2 != 0 goto label1;
v3 = new java.lang.AssertionError;
specialinvoke v3.<java.lang.AssertionError: void <init>()>();
throw v3;
label1:
v4 = staticinvoke <io.netty.util.internal.PlatformDependent: boolean hasUnsafe()>();
if v4 == 0 goto label2;
v5 = staticinvoke <io.netty.util.internal.PlatformDependent: long directBufferAddress(java.nio.ByteBuffer)>(v0);
return v5;
label2:
v6 = staticinvoke <io.netty.internal.tcnative.Buffer: long address(java.nio.ByteBuffer)>(v0);
return v6;
}
private void selectApplicationProtocol() throws javax.net.ssl.SSLException
{
java.lang.Error v20;
long v10, v13, v16, v18;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
io.netty.handler.ssl.ApplicationProtocolConfig$Protocol v7;
io.netty.handler.ssl.ApplicationProtocolConfig$SelectedListenerFailureBehavior v2;
int[] v5;
int v8, v9;
java.lang.String v11, v12, v14, v15, v17, v19;
java.util.List v4;
io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator v1, v3, v6;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator apn>;
v2 = interfaceinvoke v1.<io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator: io.netty.handler.ssl.ApplicationProtocolConfig$SelectedListenerFailureBehavior selectedListenerFailureBehavior()>();
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator apn>;
v4 = interfaceinvoke v3.<io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator: java.util.List protocols()>();
v5 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine$3: int[] $SwitchMap$io$netty$handler$ssl$ApplicationProtocolConfig$Protocol>;
v6 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator apn>;
v7 = interfaceinvoke v6.<io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator: io.netty.handler.ssl.ApplicationProtocolConfig$Protocol protocol()>();
v8 = virtualinvoke v7.<io.netty.handler.ssl.ApplicationProtocolConfig$Protocol: int ordinal()>();
v9 = v5[v8];
tableswitch(v9)
{
case 1: goto label6;
case 2: goto label1;
case 3: goto label2;
case 4: goto label3;
default: goto label5;
};
label1:
v10 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v11 = staticinvoke <io.netty.internal.tcnative.SSL: java.lang.String getAlpnSelected(long)>(v10);
if v11 == null goto label6;
v12 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.String selectApplicationProtocol(java.util.List,io.netty.handler.ssl.ApplicationProtocolConfig$SelectedListenerFailureBehavior,java.lang.String)>(v4, v2, v11);
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.String applicationProtocol> = v12;
goto label6;
label2:
v13 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v14 = staticinvoke <io.netty.internal.tcnative.SSL: java.lang.String getNextProtoNegotiated(long)>(v13);
if v14 == null goto label6;
v15 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.String selectApplicationProtocol(java.util.List,io.netty.handler.ssl.ApplicationProtocolConfig$SelectedListenerFailureBehavior,java.lang.String)>(v4, v2, v14);
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.String applicationProtocol> = v15;
goto label6;
label3:
v16 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v17 = staticinvoke <io.netty.internal.tcnative.SSL: java.lang.String getAlpnSelected(long)>(v16);
if v17 != null goto label4;
v18 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: long ssl>;
v17 = staticinvoke <io.netty.internal.tcnative.SSL: java.lang.String getNextProtoNegotiated(long)>(v18);
label4:
if v17 == null goto label6;
v19 = specialinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.String selectApplicationProtocol(java.util.List,io.netty.handler.ssl.ApplicationProtocolConfig$SelectedListenerFailureBehavior,java.lang.String)>(v4, v2, v17);
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: java.lang.String applicationProtocol> = v19;
goto label6;
label5:
v20 = new java.lang.Error;
specialinvoke v20.<java.lang.Error: void <init>()>();
throw v20;
label6:
return;
}
private java.lang.String selectApplicationProtocol(java.util.List, io.netty.handler.ssl.ApplicationProtocolConfig$SelectedListenerFailureBehavior, java.lang.String) throws javax.net.ssl.SSLException
{
java.lang.AssertionError v7;
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
java.util.List v1;
javax.net.ssl.SSLException v12;
io.netty.handler.ssl.ApplicationProtocolConfig$SelectedListenerFailureBehavior v2, v4, v9;
int v10, v5;
java.lang.Object v11;
java.lang.String v13, v3;
boolean v6, v8;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: java.util.List;
v2 := @parameter1: io.netty.handler.ssl.ApplicationProtocolConfig$SelectedListenerFailureBehavior;
v3 := @parameter2: java.lang.String;
v4 = <io.netty.handler.ssl.ApplicationProtocolConfig$SelectedListenerFailureBehavior: io.netty.handler.ssl.ApplicationProtocolConfig$SelectedListenerFailureBehavior ACCEPT>;
if v2 != v4 goto label1;
return v3;
label1:
v5 = interfaceinvoke v1.<java.util.List: int size()>();
v6 = <io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled>;
if v6 != 0 goto label2;
if v5 > 0 goto label2;
v7 = new java.lang.AssertionError;
specialinvoke v7.<java.lang.AssertionError: void <init>()>();
throw v7;
label2:
v8 = interfaceinvoke v1.<java.util.List: boolean contains(java.lang.Object)>(v3);
if v8 == 0 goto label3;
return v3;
label3:
v9 = <io.netty.handler.ssl.ApplicationProtocolConfig$SelectedListenerFailureBehavior: io.netty.handler.ssl.ApplicationProtocolConfig$SelectedListenerFailureBehavior CHOOSE_MY_LAST_PROTOCOL>;
if v2 != v9 goto label4;
v10 = v5 - 1;
v11 = interfaceinvoke v1.<java.util.List: java.lang.Object get(int)>(v10);
return v11;
label4:
v12 = new javax.net.ssl.SSLException;
v13 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v3) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("unknown protocol \u0001");
specialinvoke v12.<javax.net.ssl.SSLException: void <init>(java.lang.String)>(v13);
throw v12;
}
final void setSessionId(io.netty.handler.ssl.OpenSslSessionId)
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v0;
io.netty.handler.ssl.OpenSslSessionId v1;
io.netty.handler.ssl.OpenSslSession v2;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
v1 := @parameter0: io.netty.handler.ssl.OpenSslSessionId;
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.handler.ssl.OpenSslSession session>;
interfaceinvoke v2.<io.netty.handler.ssl.OpenSslSession: void setSessionId(io.netty.handler.ssl.OpenSslSessionId)>(v1);
return;
}
static void <clinit>()
{
javax.net.ssl.SSLEngineResult$HandshakeStatus v17, v20, v23, v26, v29;
javax.net.ssl.SSLEngineResult v15, v18, v21, v24, v27;
int[] v6;
int v10, v11, v12, v13, v14, v7, v8, v9;
javax.net.ssl.SSLEngineResult$Status v16, v19, v22, v25, v28;
boolean v1, v2;
io.netty.util.ResourceLeakDetector v5;
io.netty.util.internal.logging.InternalLogger v3;
io.netty.util.ResourceLeakDetectorFactory v4;
java.lang.Class v0;
v0 = class "Lio/netty/handler/ssl/ReferenceCountedOpenSslEngine;";
v1 = virtualinvoke v0.<java.lang.Class: boolean desiredAssertionStatus()>();
if v1 != 0 goto label1;
v2 = 1;
goto label2;
label1:
v2 = 0;
label2:
<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: boolean $assertionsDisabled> = v2;
v3 = staticinvoke <io.netty.util.internal.logging.InternalLoggerFactory: io.netty.util.internal.logging.InternalLogger getInstance(java.lang.Class)>(class "Lio/netty/handler/ssl/ReferenceCountedOpenSslEngine;");
<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.util.internal.logging.InternalLogger logger> = v3;
v4 = staticinvoke <io.netty.util.ResourceLeakDetectorFactory: io.netty.util.ResourceLeakDetectorFactory instance()>();
v5 = virtualinvoke v4.<io.netty.util.ResourceLeakDetectorFactory: io.netty.util.ResourceLeakDetector newResourceLeakDetector(java.lang.Class)>(class "Lio/netty/handler/ssl/ReferenceCountedOpenSslEngine;");
<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: io.netty.util.ResourceLeakDetector leakDetector> = v5;
v6 = newarray (int)[6];
v7 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_SSLv2>;
v6[0] = v7;
v8 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_SSLv3>;
v6[1] = v8;
v9 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_TLSv1>;
v6[2] = v9;
v10 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_TLSv1_1>;
v6[3] = v10;
v11 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_TLSv1_2>;
v6[4] = v11;
v12 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_TLSv1_3>;
v6[5] = v12;
<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int[] OPENSSL_OP_NO_PROTOCOLS> = v6;
v13 = <io.netty.internal.tcnative.SSL: int SSL_MAX_PLAINTEXT_LENGTH>;
<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int MAX_PLAINTEXT_LENGTH> = v13;
v14 = <io.netty.internal.tcnative.SSL: int SSL_MAX_RECORD_LENGTH>;
<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: int MAX_RECORD_SIZE> = v14;
v15 = new javax.net.ssl.SSLEngineResult;
v16 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status OK>;
v17 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_UNWRAP>;
specialinvoke v15.<javax.net.ssl.SSLEngineResult: void <init>(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v16, v17, 0, 0);
<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult NEED_UNWRAP_OK> = v15;
v18 = new javax.net.ssl.SSLEngineResult;
v19 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status CLOSED>;
v20 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_UNWRAP>;
specialinvoke v18.<javax.net.ssl.SSLEngineResult: void <init>(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v19, v20, 0, 0);
<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult NEED_UNWRAP_CLOSED> = v18;
v21 = new javax.net.ssl.SSLEngineResult;
v22 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status OK>;
v23 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_WRAP>;
specialinvoke v21.<javax.net.ssl.SSLEngineResult: void <init>(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v22, v23, 0, 0);
<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult NEED_WRAP_OK> = v21;
v24 = new javax.net.ssl.SSLEngineResult;
v25 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status CLOSED>;
v26 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_WRAP>;
specialinvoke v24.<javax.net.ssl.SSLEngineResult: void <init>(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v25, v26, 0, 0);
<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult NEED_WRAP_CLOSED> = v24;
v27 = new javax.net.ssl.SSLEngineResult;
v28 = <javax.net.ssl.SSLEngineResult$Status: javax.net.ssl.SSLEngineResult$Status CLOSED>;
v29 = <javax.net.ssl.SSLEngineResult$HandshakeStatus: javax.net.ssl.SSLEngineResult$HandshakeStatus NOT_HANDSHAKING>;
specialinvoke v27.<javax.net.ssl.SSLEngineResult: void <init>(javax.net.ssl.SSLEngineResult$Status,javax.net.ssl.SSLEngineResult$HandshakeStatus,int,int)>(v28, v29, 0, 0);
<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: javax.net.ssl.SSLEngineResult CLOSED_NOT_HANDSHAKING> = v27;
return;
}
}