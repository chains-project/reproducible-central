public abstract class io.netty.handler.ssl.SslContext extends java.lang.Object
{
static final java.lang.String ALIAS;
static final java.security.cert.CertificateFactory X509_CERT_FACTORY;
private final boolean startTls;
private final io.netty.util.AttributeMap attributes;
public static io.netty.handler.ssl.SslProvider defaultServerProvider()
{
io.netty.handler.ssl.SslProvider v0;
v0 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslProvider defaultProvider()>();
return v0;
}
public static io.netty.handler.ssl.SslProvider defaultClientProvider()
{
io.netty.handler.ssl.SslProvider v0;
v0 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslProvider defaultProvider()>();
return v0;
}
private static io.netty.handler.ssl.SslProvider defaultProvider()
{
io.netty.handler.ssl.SslProvider v1, v2;
boolean v0;
v0 = staticinvoke <io.netty.handler.ssl.OpenSsl: boolean isAvailable()>();
if v0 == 0 goto label1;
v1 = <io.netty.handler.ssl.SslProvider: io.netty.handler.ssl.SslProvider OPENSSL>;
return v1;
label1:
v2 = <io.netty.handler.ssl.SslProvider: io.netty.handler.ssl.SslProvider JDK>;
return v2;
}
public static io.netty.handler.ssl.SslContext newServerContext(java.io.File, java.io.File) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.SslContext v2;
java.io.File v0, v1;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
v2 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newServerContext(java.io.File,java.io.File,java.lang.String)>(v0, v1, null);
return v2;
}
public static io.netty.handler.ssl.SslContext newServerContext(java.io.File, java.io.File, java.lang.String) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.SslContext v3;
java.lang.String v2;
java.io.File v0, v1;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
v2 := @parameter2: java.lang.String;
v3 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newServerContext(io.netty.handler.ssl.SslProvider,java.io.File,java.io.File,java.lang.String)>(null, v0, v1, v2);
return v3;
}
public static io.netty.handler.ssl.SslContext newServerContext(java.io.File, java.io.File, java.lang.String, java.lang.Iterable, java.lang.Iterable, long, long) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.SslContext v7;
long v5, v6;
java.io.File v0, v1;
java.lang.Iterable v3, v4;
java.lang.String v2;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
v2 := @parameter2: java.lang.String;
v3 := @parameter3: java.lang.Iterable;
v4 := @parameter4: java.lang.Iterable;
v5 := @parameter5: long;
v6 := @parameter6: long;
v7 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newServerContext(io.netty.handler.ssl.SslProvider,java.io.File,java.io.File,java.lang.String,java.lang.Iterable,java.lang.Iterable,long,long)>(null, v0, v1, v2, v3, v4, v5, v6);
return v7;
}
public static io.netty.handler.ssl.SslContext newServerContext(java.io.File, java.io.File, java.lang.String, java.lang.Iterable, io.netty.handler.ssl.CipherSuiteFilter, io.netty.handler.ssl.ApplicationProtocolConfig, long, long) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.SslContext v8;
long v6, v7;
java.io.File v0, v1;
java.lang.Iterable v3;
io.netty.handler.ssl.CipherSuiteFilter v4;
java.lang.String v2;
io.netty.handler.ssl.ApplicationProtocolConfig v5;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
v2 := @parameter2: java.lang.String;
v3 := @parameter3: java.lang.Iterable;
v4 := @parameter4: io.netty.handler.ssl.CipherSuiteFilter;
v5 := @parameter5: io.netty.handler.ssl.ApplicationProtocolConfig;
v6 := @parameter6: long;
v7 := @parameter7: long;
v8 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newServerContext(io.netty.handler.ssl.SslProvider,java.io.File,java.io.File,java.lang.String,java.lang.Iterable,io.netty.handler.ssl.CipherSuiteFilter,io.netty.handler.ssl.ApplicationProtocolConfig,long,long)>(null, v0, v1, v2, v3, v4, v5, v6, v7);
return v8;
}
public static io.netty.handler.ssl.SslContext newServerContext(io.netty.handler.ssl.SslProvider, java.io.File, java.io.File) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.SslProvider v0;
io.netty.handler.ssl.SslContext v3;
java.io.File v1, v2;
v0 := @parameter0: io.netty.handler.ssl.SslProvider;
v1 := @parameter1: java.io.File;
v2 := @parameter2: java.io.File;
v3 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newServerContext(io.netty.handler.ssl.SslProvider,java.io.File,java.io.File,java.lang.String)>(v0, v1, v2, null);
return v3;
}
public static io.netty.handler.ssl.SslContext newServerContext(io.netty.handler.ssl.SslProvider, java.io.File, java.io.File, java.lang.String) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.IdentityCipherSuiteFilter v4;
io.netty.handler.ssl.SslProvider v0;
io.netty.handler.ssl.SslContext v5;
java.lang.String v3;
java.io.File v1, v2;
v0 := @parameter0: io.netty.handler.ssl.SslProvider;
v1 := @parameter1: java.io.File;
v2 := @parameter2: java.io.File;
v3 := @parameter3: java.lang.String;
v4 = <io.netty.handler.ssl.IdentityCipherSuiteFilter: io.netty.handler.ssl.IdentityCipherSuiteFilter INSTANCE>;
v5 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newServerContext(io.netty.handler.ssl.SslProvider,java.io.File,java.io.File,java.lang.String,java.lang.Iterable,io.netty.handler.ssl.CipherSuiteFilter,io.netty.handler.ssl.ApplicationProtocolConfig,long,long)>(v0, v1, v2, v3, null, v4, null, 0L, 0L);
return v5;
}
public static io.netty.handler.ssl.SslContext newServerContext(io.netty.handler.ssl.SslProvider, java.io.File, java.io.File, java.lang.String, java.lang.Iterable, java.lang.Iterable, long, long) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.IdentityCipherSuiteFilter v8;
io.netty.handler.ssl.SslContext v10;
long v6, v7;
java.io.File v1, v2;
java.lang.Iterable v4, v5;
io.netty.handler.ssl.SslProvider v0;
java.lang.String v3;
io.netty.handler.ssl.ApplicationProtocolConfig v9;
v0 := @parameter0: io.netty.handler.ssl.SslProvider;
v1 := @parameter1: java.io.File;
v2 := @parameter2: java.io.File;
v3 := @parameter3: java.lang.String;
v4 := @parameter4: java.lang.Iterable;
v5 := @parameter5: java.lang.Iterable;
v6 := @parameter6: long;
v7 := @parameter7: long;
v8 = <io.netty.handler.ssl.IdentityCipherSuiteFilter: io.netty.handler.ssl.IdentityCipherSuiteFilter INSTANCE>;
v9 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.ApplicationProtocolConfig toApplicationProtocolConfig(java.lang.Iterable)>(v5);
v10 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newServerContext(io.netty.handler.ssl.SslProvider,java.io.File,java.io.File,java.lang.String,java.lang.Iterable,io.netty.handler.ssl.CipherSuiteFilter,io.netty.handler.ssl.ApplicationProtocolConfig,long,long)>(v0, v1, v2, v3, v4, v8, v9, v6, v7);
return v10;
}
public static io.netty.handler.ssl.SslContext newServerContext(io.netty.handler.ssl.SslProvider, java.io.File, java.io.File, java.lang.String, javax.net.ssl.TrustManagerFactory, java.lang.Iterable, java.lang.Iterable, long, long) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.IdentityCipherSuiteFilter v9;
io.netty.handler.ssl.SslContext v11;
javax.net.ssl.TrustManagerFactory v4;
long v7, v8;
java.io.File v1, v2;
java.lang.Iterable v5, v6;
io.netty.handler.ssl.SslProvider v0;
java.lang.String v3;
io.netty.handler.ssl.ApplicationProtocolConfig v10;
v0 := @parameter0: io.netty.handler.ssl.SslProvider;
v1 := @parameter1: java.io.File;
v2 := @parameter2: java.io.File;
v3 := @parameter3: java.lang.String;
v4 := @parameter4: javax.net.ssl.TrustManagerFactory;
v5 := @parameter5: java.lang.Iterable;
v6 := @parameter6: java.lang.Iterable;
v7 := @parameter7: long;
v8 := @parameter8: long;
v9 = <io.netty.handler.ssl.IdentityCipherSuiteFilter: io.netty.handler.ssl.IdentityCipherSuiteFilter INSTANCE>;
v10 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.ApplicationProtocolConfig toApplicationProtocolConfig(java.lang.Iterable)>(v6);
v11 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newServerContext(io.netty.handler.ssl.SslProvider,java.io.File,javax.net.ssl.TrustManagerFactory,java.io.File,java.io.File,java.lang.String,javax.net.ssl.KeyManagerFactory,java.lang.Iterable,io.netty.handler.ssl.CipherSuiteFilter,io.netty.handler.ssl.ApplicationProtocolConfig,long,long)>(v0, null, v4, v1, v2, v3, null, v5, v9, v10, v7, v8);
return v11;
}
public static io.netty.handler.ssl.SslContext newServerContext(io.netty.handler.ssl.SslProvider, java.io.File, java.io.File, java.lang.String, java.lang.Iterable, io.netty.handler.ssl.CipherSuiteFilter, io.netty.handler.ssl.ApplicationProtocolConfig, long, long) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.SslContext v10;
long v7, v8;
java.io.File v1, v2;
java.lang.Iterable v4;
io.netty.handler.ssl.CipherSuiteFilter v5;
io.netty.handler.ssl.SslProvider v0;
java.lang.String v3, v9;
io.netty.handler.ssl.ApplicationProtocolConfig v6;
v0 := @parameter0: io.netty.handler.ssl.SslProvider;
v1 := @parameter1: java.io.File;
v2 := @parameter2: java.io.File;
v3 := @parameter3: java.lang.String;
v4 := @parameter4: java.lang.Iterable;
v5 := @parameter5: io.netty.handler.ssl.CipherSuiteFilter;
v6 := @parameter6: io.netty.handler.ssl.ApplicationProtocolConfig;
v7 := @parameter7: long;
v8 := @parameter8: long;
v9 = staticinvoke <java.security.KeyStore: java.lang.String getDefaultType()>();
v10 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newServerContext(io.netty.handler.ssl.SslProvider,java.io.File,javax.net.ssl.TrustManagerFactory,java.io.File,java.io.File,java.lang.String,javax.net.ssl.KeyManagerFactory,java.lang.Iterable,io.netty.handler.ssl.CipherSuiteFilter,io.netty.handler.ssl.ApplicationProtocolConfig,long,long,java.lang.String)>(v0, null, null, v1, v2, v3, null, v4, v5, v6, v7, v8, v9);
return v10;
}
public static io.netty.handler.ssl.SslContext newServerContext(io.netty.handler.ssl.SslProvider, java.io.File, javax.net.ssl.TrustManagerFactory, java.io.File, java.io.File, java.lang.String, javax.net.ssl.KeyManagerFactory, java.lang.Iterable, io.netty.handler.ssl.CipherSuiteFilter, io.netty.handler.ssl.ApplicationProtocolConfig, long, long) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.SslContext v13;
javax.net.ssl.TrustManagerFactory v2;
javax.net.ssl.KeyManagerFactory v6;
long v10, v11;
java.io.File v1, v3, v4;
java.lang.Iterable v7;
io.netty.handler.ssl.CipherSuiteFilter v8;
io.netty.handler.ssl.SslProvider v0;
java.lang.String v12, v5;
io.netty.handler.ssl.ApplicationProtocolConfig v9;
v0 := @parameter0: io.netty.handler.ssl.SslProvider;
v1 := @parameter1: java.io.File;
v2 := @parameter2: javax.net.ssl.TrustManagerFactory;
v3 := @parameter3: java.io.File;
v4 := @parameter4: java.io.File;
v5 := @parameter5: java.lang.String;
v6 := @parameter6: javax.net.ssl.KeyManagerFactory;
v7 := @parameter7: java.lang.Iterable;
v8 := @parameter8: io.netty.handler.ssl.CipherSuiteFilter;
v9 := @parameter9: io.netty.handler.ssl.ApplicationProtocolConfig;
v10 := @parameter10: long;
v11 := @parameter11: long;
v12 = staticinvoke <java.security.KeyStore: java.lang.String getDefaultType()>();
v13 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newServerContext(io.netty.handler.ssl.SslProvider,java.io.File,javax.net.ssl.TrustManagerFactory,java.io.File,java.io.File,java.lang.String,javax.net.ssl.KeyManagerFactory,java.lang.Iterable,io.netty.handler.ssl.CipherSuiteFilter,io.netty.handler.ssl.ApplicationProtocolConfig,long,long,java.lang.String)>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12);
return v13;
}
static io.netty.handler.ssl.SslContext newServerContext(io.netty.handler.ssl.SslProvider, java.io.File, javax.net.ssl.TrustManagerFactory, java.io.File, java.io.File, java.lang.String, javax.net.ssl.KeyManagerFactory, java.lang.Iterable, io.netty.handler.ssl.CipherSuiteFilter, io.netty.handler.ssl.ApplicationProtocolConfig, long, long, java.lang.String) throws javax.net.ssl.SSLException
{
long v10, v11;
java.lang.Iterable v7;
io.netty.handler.ssl.CipherSuiteFilter v8;
io.netty.handler.ssl.ClientAuth v16;
java.lang.String v12, v5;
java.util.Map$Entry[] v17;
io.netty.handler.ssl.ApplicationProtocolConfig v9;
boolean v20;
io.netty.handler.ssl.SslContext v18;
javax.net.ssl.TrustManagerFactory v2;
javax.net.ssl.KeyManagerFactory v6;
java.io.File v1, v3, v4;
java.lang.Exception v19;
javax.net.ssl.SSLException v21;
io.netty.handler.ssl.SslProvider v0;
java.security.PrivateKey v15;
java.security.cert.X509Certificate[] v13, v14;
v0 := @parameter0: io.netty.handler.ssl.SslProvider;
v1 := @parameter1: java.io.File;
v2 := @parameter2: javax.net.ssl.TrustManagerFactory;
v3 := @parameter3: java.io.File;
v4 := @parameter4: java.io.File;
v5 := @parameter5: java.lang.String;
v6 := @parameter6: javax.net.ssl.KeyManagerFactory;
v7 := @parameter7: java.lang.Iterable;
v8 := @parameter8: io.netty.handler.ssl.CipherSuiteFilter;
v9 := @parameter9: io.netty.handler.ssl.ApplicationProtocolConfig;
v10 := @parameter10: long;
v11 := @parameter11: long;
v12 := @parameter12: java.lang.String;
label1:
v13 = staticinvoke <io.netty.handler.ssl.SslContext: java.security.cert.X509Certificate[] toX509Certificates(java.io.File)>(v1);
v14 = staticinvoke <io.netty.handler.ssl.SslContext: java.security.cert.X509Certificate[] toX509Certificates(java.io.File)>(v3);
v15 = staticinvoke <io.netty.handler.ssl.SslContext: java.security.PrivateKey toPrivateKey(java.io.File,java.lang.String)>(v4, v5);
v16 = <io.netty.handler.ssl.ClientAuth: io.netty.handler.ssl.ClientAuth NONE>;
v17 = newarray (java.util.Map$Entry)[0];
v18 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newServerContextInternal(io.netty.handler.ssl.SslProvider,java.security.Provider,java.security.cert.X509Certificate[],javax.net.ssl.TrustManagerFactory,java.security.cert.X509Certificate[],java.security.PrivateKey,java.lang.String,javax.net.ssl.KeyManagerFactory,java.lang.Iterable,io.netty.handler.ssl.CipherSuiteFilter,io.netty.handler.ssl.ApplicationProtocolConfig,long,long,io.netty.handler.ssl.ClientAuth,java.lang.String[],boolean,boolean,java.lang.String,java.util.Map$Entry[])>(v0, null, v13, v2, v14, v15, v5, v6, v7, v8, v9, v10, v11, v16, null, 0, 0, v12, v17);
label2:
return v18;
label3:
v19 := @caughtexception;
v20 = v19 instanceof javax.net.ssl.SSLException;
if v20 == 0 goto label4;
throw v19;
label4:
v21 = new javax.net.ssl.SSLException;
specialinvoke v21.<javax.net.ssl.SSLException: void <init>(java.lang.String,java.lang.Throwable)>("failed to initialize the server-side SSL context", v19);
throw v21;
catch java.lang.Exception from label1 to label2 with label3;
}
static transient io.netty.handler.ssl.SslContext newServerContextInternal(io.netty.handler.ssl.SslProvider, java.security.Provider, java.security.cert.X509Certificate[], javax.net.ssl.TrustManagerFactory, java.security.cert.X509Certificate[], java.security.PrivateKey, java.lang.String, javax.net.ssl.KeyManagerFactory, java.lang.Iterable, io.netty.handler.ssl.CipherSuiteFilter, io.netty.handler.ssl.ApplicationProtocolConfig, long, long, io.netty.handler.ssl.ClientAuth, java.lang.String[], boolean, boolean, java.lang.String, java.util.Map$Entry[]) throws javax.net.ssl.SSLException
{
java.lang.Error v27;
java.lang.String[] v14;
long v11, v12;
java.lang.Iterable v8;
io.netty.handler.ssl.CipherSuiteFilter v9;
io.netty.handler.ssl.ClientAuth v13;
int[] v19;
int v20, v21;
java.lang.String v17, v23, v28, v6;
java.util.Map$Entry[] v18;
io.netty.handler.ssl.ApplicationProtocolConfig v10;
boolean v15, v16;
javax.net.ssl.TrustManagerFactory v3;
javax.net.ssl.KeyManagerFactory v7;
java.lang.IllegalArgumentException v22;
java.security.Provider v1;
io.netty.handler.ssl.JdkSslServerContext v24;
io.netty.handler.ssl.OpenSslServerContext v25;
io.netty.handler.ssl.SslProvider v0;
io.netty.handler.ssl.ReferenceCountedOpenSslServerContext v26;
java.security.PrivateKey v5;
java.security.cert.X509Certificate[] v2, v4;
v0 := @parameter0: io.netty.handler.ssl.SslProvider;
v1 := @parameter1: java.security.Provider;
v2 := @parameter2: java.security.cert.X509Certificate[];
v3 := @parameter3: javax.net.ssl.TrustManagerFactory;
v4 := @parameter4: java.security.cert.X509Certificate[];
v5 := @parameter5: java.security.PrivateKey;
v6 := @parameter6: java.lang.String;
v7 := @parameter7: javax.net.ssl.KeyManagerFactory;
v8 := @parameter8: java.lang.Iterable;
v9 := @parameter9: io.netty.handler.ssl.CipherSuiteFilter;
v10 := @parameter10: io.netty.handler.ssl.ApplicationProtocolConfig;
v11 := @parameter11: long;
v12 := @parameter12: long;
v13 := @parameter13: io.netty.handler.ssl.ClientAuth;
v14 := @parameter14: java.lang.String[];
v15 := @parameter15: boolean;
v16 := @parameter16: boolean;
v17 := @parameter17: java.lang.String;
v18 := @parameter18: java.util.Map$Entry[];
if v0 != null goto label1;
v0 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslProvider defaultServerProvider()>();
label1:
v19 = <io.netty.handler.ssl.SslContext$1: int[] $SwitchMap$io$netty$handler$ssl$SslProvider>;
v20 = virtualinvoke v0.<io.netty.handler.ssl.SslProvider: int ordinal()>();
v21 = v19[v20];
tableswitch(v21)
{
case 1: goto label2;
case 2: goto label4;
case 3: goto label5;
default: goto label6;
};
label2:
if v16 == 0 goto label3;
v22 = new java.lang.IllegalArgumentException;
v23 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (io.netty.handler.ssl.SslProvider)>(v0) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("OCSP is not supported with this SslProvider: \u0001");
specialinvoke v22.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(v23);
throw v22;
label3:
v24 = new io.netty.handler.ssl.JdkSslServerContext;
specialinvoke v24.<io.netty.handler.ssl.JdkSslServerContext: void <init>(java.security.Provider,java.security.cert.X509Certificate[],javax.net.ssl.TrustManagerFactory,java.security.cert.X509Certificate[],java.security.PrivateKey,java.lang.String,javax.net.ssl.KeyManagerFactory,java.lang.Iterable,io.netty.handler.ssl.CipherSuiteFilter,io.netty.handler.ssl.ApplicationProtocolConfig,long,long,io.netty.handler.ssl.ClientAuth,java.lang.String[],boolean,java.lang.String)>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v17);
return v24;
label4:
staticinvoke <io.netty.handler.ssl.SslContext: void verifyNullSslContextProvider(io.netty.handler.ssl.SslProvider,java.security.Provider)>(v0, v1);
v25 = new io.netty.handler.ssl.OpenSslServerContext;
specialinvoke v25.<io.netty.handler.ssl.OpenSslServerContext: void <init>(java.security.cert.X509Certificate[],javax.net.ssl.TrustManagerFactory,java.security.cert.X509Certificate[],java.security.PrivateKey,java.lang.String,javax.net.ssl.KeyManagerFactory,java.lang.Iterable,io.netty.handler.ssl.CipherSuiteFilter,io.netty.handler.ssl.ApplicationProtocolConfig,long,long,io.netty.handler.ssl.ClientAuth,java.lang.String[],boolean,boolean,java.lang.String,java.util.Map$Entry[])>(v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18);
return v25;
label5:
staticinvoke <io.netty.handler.ssl.SslContext: void verifyNullSslContextProvider(io.netty.handler.ssl.SslProvider,java.security.Provider)>(v0, v1);
v26 = new io.netty.handler.ssl.ReferenceCountedOpenSslServerContext;
specialinvoke v26.<io.netty.handler.ssl.ReferenceCountedOpenSslServerContext: void <init>(java.security.cert.X509Certificate[],javax.net.ssl.TrustManagerFactory,java.security.cert.X509Certificate[],java.security.PrivateKey,java.lang.String,javax.net.ssl.KeyManagerFactory,java.lang.Iterable,io.netty.handler.ssl.CipherSuiteFilter,io.netty.handler.ssl.ApplicationProtocolConfig,long,long,io.netty.handler.ssl.ClientAuth,java.lang.String[],boolean,boolean,java.lang.String,java.util.Map$Entry[])>(v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18);
return v26;
label6:
v27 = new java.lang.Error;
v28 = virtualinvoke v0.<io.netty.handler.ssl.SslProvider: java.lang.String toString()>();
specialinvoke v27.<java.lang.Error: void <init>(java.lang.String)>(v28);
throw v27;
}
private static void verifyNullSslContextProvider(io.netty.handler.ssl.SslProvider, java.security.Provider)
{
io.netty.handler.ssl.SslProvider v0;
java.lang.String v3;
java.lang.IllegalArgumentException v2;
java.security.Provider v1;
v0 := @parameter0: io.netty.handler.ssl.SslProvider;
v1 := @parameter1: java.security.Provider;
if v1 == null goto label1;
v2 = new java.lang.IllegalArgumentException;
v3 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (io.netty.handler.ssl.SslProvider)>(v0) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Java Security Provider unsupported for SslProvider: \u0001");
specialinvoke v2.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(v3);
throw v2;
label1:
return;
}
public static io.netty.handler.ssl.SslContext newClientContext() throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.SslContext v0;
v0 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newClientContext(io.netty.handler.ssl.SslProvider,java.io.File,javax.net.ssl.TrustManagerFactory)>(null, null, null);
return v0;
}
public static io.netty.handler.ssl.SslContext newClientContext(java.io.File) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.SslContext v1;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newClientContext(io.netty.handler.ssl.SslProvider,java.io.File)>(null, v0);
return v1;
}
public static io.netty.handler.ssl.SslContext newClientContext(javax.net.ssl.TrustManagerFactory) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.SslContext v1;
javax.net.ssl.TrustManagerFactory v0;
v0 := @parameter0: javax.net.ssl.TrustManagerFactory;
v1 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newClientContext(io.netty.handler.ssl.SslProvider,java.io.File,javax.net.ssl.TrustManagerFactory)>(null, null, v0);
return v1;
}
public static io.netty.handler.ssl.SslContext newClientContext(java.io.File, javax.net.ssl.TrustManagerFactory) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.SslContext v2;
javax.net.ssl.TrustManagerFactory v1;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 := @parameter1: javax.net.ssl.TrustManagerFactory;
v2 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newClientContext(io.netty.handler.ssl.SslProvider,java.io.File,javax.net.ssl.TrustManagerFactory)>(null, v0, v1);
return v2;
}
public static io.netty.handler.ssl.SslContext newClientContext(java.io.File, javax.net.ssl.TrustManagerFactory, java.lang.Iterable, java.lang.Iterable, long, long) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.SslContext v6;
javax.net.ssl.TrustManagerFactory v1;
long v4, v5;
java.io.File v0;
java.lang.Iterable v2, v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: javax.net.ssl.TrustManagerFactory;
v2 := @parameter2: java.lang.Iterable;
v3 := @parameter3: java.lang.Iterable;
v4 := @parameter4: long;
v5 := @parameter5: long;
v6 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newClientContext(io.netty.handler.ssl.SslProvider,java.io.File,javax.net.ssl.TrustManagerFactory,java.lang.Iterable,java.lang.Iterable,long,long)>(null, v0, v1, v2, v3, v4, v5);
return v6;
}
public static io.netty.handler.ssl.SslContext newClientContext(java.io.File, javax.net.ssl.TrustManagerFactory, java.lang.Iterable, io.netty.handler.ssl.CipherSuiteFilter, io.netty.handler.ssl.ApplicationProtocolConfig, long, long) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.SslContext v7;
javax.net.ssl.TrustManagerFactory v1;
long v5, v6;
java.io.File v0;
java.lang.Iterable v2;
io.netty.handler.ssl.CipherSuiteFilter v3;
io.netty.handler.ssl.ApplicationProtocolConfig v4;
v0 := @parameter0: java.io.File;
v1 := @parameter1: javax.net.ssl.TrustManagerFactory;
v2 := @parameter2: java.lang.Iterable;
v3 := @parameter3: io.netty.handler.ssl.CipherSuiteFilter;
v4 := @parameter4: io.netty.handler.ssl.ApplicationProtocolConfig;
v5 := @parameter5: long;
v6 := @parameter6: long;
v7 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newClientContext(io.netty.handler.ssl.SslProvider,java.io.File,javax.net.ssl.TrustManagerFactory,java.lang.Iterable,io.netty.handler.ssl.CipherSuiteFilter,io.netty.handler.ssl.ApplicationProtocolConfig,long,long)>(null, v0, v1, v2, v3, v4, v5, v6);
return v7;
}
public static io.netty.handler.ssl.SslContext newClientContext(io.netty.handler.ssl.SslProvider) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.SslProvider v0;
io.netty.handler.ssl.SslContext v1;
v0 := @parameter0: io.netty.handler.ssl.SslProvider;
v1 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newClientContext(io.netty.handler.ssl.SslProvider,java.io.File,javax.net.ssl.TrustManagerFactory)>(v0, null, null);
return v1;
}
public static io.netty.handler.ssl.SslContext newClientContext(io.netty.handler.ssl.SslProvider, java.io.File) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.SslProvider v0;
io.netty.handler.ssl.SslContext v2;
java.io.File v1;
v0 := @parameter0: io.netty.handler.ssl.SslProvider;
v1 := @parameter1: java.io.File;
v2 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newClientContext(io.netty.handler.ssl.SslProvider,java.io.File,javax.net.ssl.TrustManagerFactory)>(v0, v1, null);
return v2;
}
public static io.netty.handler.ssl.SslContext newClientContext(io.netty.handler.ssl.SslProvider, javax.net.ssl.TrustManagerFactory) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.SslProvider v0;
io.netty.handler.ssl.SslContext v2;
javax.net.ssl.TrustManagerFactory v1;
v0 := @parameter0: io.netty.handler.ssl.SslProvider;
v1 := @parameter1: javax.net.ssl.TrustManagerFactory;
v2 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newClientContext(io.netty.handler.ssl.SslProvider,java.io.File,javax.net.ssl.TrustManagerFactory)>(v0, null, v1);
return v2;
}
public static io.netty.handler.ssl.SslContext newClientContext(io.netty.handler.ssl.SslProvider, java.io.File, javax.net.ssl.TrustManagerFactory) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.IdentityCipherSuiteFilter v3;
io.netty.handler.ssl.SslProvider v0;
io.netty.handler.ssl.SslContext v4;
javax.net.ssl.TrustManagerFactory v2;
java.io.File v1;
v0 := @parameter0: io.netty.handler.ssl.SslProvider;
v1 := @parameter1: java.io.File;
v2 := @parameter2: javax.net.ssl.TrustManagerFactory;
v3 = <io.netty.handler.ssl.IdentityCipherSuiteFilter: io.netty.handler.ssl.IdentityCipherSuiteFilter INSTANCE>;
v4 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newClientContext(io.netty.handler.ssl.SslProvider,java.io.File,javax.net.ssl.TrustManagerFactory,java.lang.Iterable,io.netty.handler.ssl.CipherSuiteFilter,io.netty.handler.ssl.ApplicationProtocolConfig,long,long)>(v0, v1, v2, null, v3, null, 0L, 0L);
return v4;
}
public static io.netty.handler.ssl.SslContext newClientContext(io.netty.handler.ssl.SslProvider, java.io.File, javax.net.ssl.TrustManagerFactory, java.lang.Iterable, java.lang.Iterable, long, long) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.IdentityCipherSuiteFilter v7;
io.netty.handler.ssl.SslContext v9;
javax.net.ssl.TrustManagerFactory v2;
long v5, v6;
java.io.File v1;
java.lang.Iterable v3, v4;
io.netty.handler.ssl.SslProvider v0;
io.netty.handler.ssl.ApplicationProtocolConfig v8;
v0 := @parameter0: io.netty.handler.ssl.SslProvider;
v1 := @parameter1: java.io.File;
v2 := @parameter2: javax.net.ssl.TrustManagerFactory;
v3 := @parameter3: java.lang.Iterable;
v4 := @parameter4: java.lang.Iterable;
v5 := @parameter5: long;
v6 := @parameter6: long;
v7 = <io.netty.handler.ssl.IdentityCipherSuiteFilter: io.netty.handler.ssl.IdentityCipherSuiteFilter INSTANCE>;
v8 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.ApplicationProtocolConfig toApplicationProtocolConfig(java.lang.Iterable)>(v4);
v9 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newClientContext(io.netty.handler.ssl.SslProvider,java.io.File,javax.net.ssl.TrustManagerFactory,java.io.File,java.io.File,java.lang.String,javax.net.ssl.KeyManagerFactory,java.lang.Iterable,io.netty.handler.ssl.CipherSuiteFilter,io.netty.handler.ssl.ApplicationProtocolConfig,long,long)>(v0, v1, v2, null, null, null, null, v3, v7, v8, v5, v6);
return v9;
}
public static io.netty.handler.ssl.SslContext newClientContext(io.netty.handler.ssl.SslProvider, java.io.File, javax.net.ssl.TrustManagerFactory, java.lang.Iterable, io.netty.handler.ssl.CipherSuiteFilter, io.netty.handler.ssl.ApplicationProtocolConfig, long, long) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.SslContext v8;
javax.net.ssl.TrustManagerFactory v2;
long v6, v7;
java.io.File v1;
java.lang.Iterable v3;
io.netty.handler.ssl.CipherSuiteFilter v4;
io.netty.handler.ssl.SslProvider v0;
io.netty.handler.ssl.ApplicationProtocolConfig v5;
v0 := @parameter0: io.netty.handler.ssl.SslProvider;
v1 := @parameter1: java.io.File;
v2 := @parameter2: javax.net.ssl.TrustManagerFactory;
v3 := @parameter3: java.lang.Iterable;
v4 := @parameter4: io.netty.handler.ssl.CipherSuiteFilter;
v5 := @parameter5: io.netty.handler.ssl.ApplicationProtocolConfig;
v6 := @parameter6: long;
v7 := @parameter7: long;
v8 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newClientContext(io.netty.handler.ssl.SslProvider,java.io.File,javax.net.ssl.TrustManagerFactory,java.io.File,java.io.File,java.lang.String,javax.net.ssl.KeyManagerFactory,java.lang.Iterable,io.netty.handler.ssl.CipherSuiteFilter,io.netty.handler.ssl.ApplicationProtocolConfig,long,long)>(v0, v1, v2, null, null, null, null, v3, v4, v5, v6, v7);
return v8;
}
public static io.netty.handler.ssl.SslContext newClientContext(io.netty.handler.ssl.SslProvider, java.io.File, javax.net.ssl.TrustManagerFactory, java.io.File, java.io.File, java.lang.String, javax.net.ssl.KeyManagerFactory, java.lang.Iterable, io.netty.handler.ssl.CipherSuiteFilter, io.netty.handler.ssl.ApplicationProtocolConfig, long, long) throws javax.net.ssl.SSLException
{
long v10, v11;
java.lang.Iterable v7;
io.netty.handler.ssl.CipherSuiteFilter v8;
java.lang.String v15, v5;
java.util.Map$Entry[] v16;
io.netty.handler.ssl.ApplicationProtocolConfig v9;
boolean v19;
io.netty.handler.ssl.SslContext v17;
javax.net.ssl.TrustManagerFactory v2;
javax.net.ssl.KeyManagerFactory v6;
java.io.File v1, v3, v4;
java.lang.Exception v18;
javax.net.ssl.SSLException v20;
io.netty.handler.ssl.SslProvider v0;
java.security.PrivateKey v14;
java.security.cert.X509Certificate[] v12, v13;
v0 := @parameter0: io.netty.handler.ssl.SslProvider;
v1 := @parameter1: java.io.File;
v2 := @parameter2: javax.net.ssl.TrustManagerFactory;
v3 := @parameter3: java.io.File;
v4 := @parameter4: java.io.File;
v5 := @parameter5: java.lang.String;
v6 := @parameter6: javax.net.ssl.KeyManagerFactory;
v7 := @parameter7: java.lang.Iterable;
v8 := @parameter8: io.netty.handler.ssl.CipherSuiteFilter;
v9 := @parameter9: io.netty.handler.ssl.ApplicationProtocolConfig;
v10 := @parameter10: long;
v11 := @parameter11: long;
label1:
v12 = staticinvoke <io.netty.handler.ssl.SslContext: java.security.cert.X509Certificate[] toX509Certificates(java.io.File)>(v1);
v13 = staticinvoke <io.netty.handler.ssl.SslContext: java.security.cert.X509Certificate[] toX509Certificates(java.io.File)>(v3);
v14 = staticinvoke <io.netty.handler.ssl.SslContext: java.security.PrivateKey toPrivateKey(java.io.File,java.lang.String)>(v4, v5);
v15 = staticinvoke <java.security.KeyStore: java.lang.String getDefaultType()>();
v16 = newarray (java.util.Map$Entry)[0];
v17 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslContext newClientContextInternal(io.netty.handler.ssl.SslProvider,java.security.Provider,java.security.cert.X509Certificate[],javax.net.ssl.TrustManagerFactory,java.security.cert.X509Certificate[],java.security.PrivateKey,java.lang.String,javax.net.ssl.KeyManagerFactory,java.lang.Iterable,io.netty.handler.ssl.CipherSuiteFilter,io.netty.handler.ssl.ApplicationProtocolConfig,java.lang.String[],long,long,boolean,java.lang.String,java.util.Map$Entry[])>(v0, null, v12, v2, v13, v14, v5, v6, v7, v8, v9, null, v10, v11, 0, v15, v16);
label2:
return v17;
label3:
v18 := @caughtexception;
v19 = v18 instanceof javax.net.ssl.SSLException;
if v19 == 0 goto label4;
throw v18;
label4:
v20 = new javax.net.ssl.SSLException;
specialinvoke v20.<javax.net.ssl.SSLException: void <init>(java.lang.String,java.lang.Throwable)>("failed to initialize the client-side SSL context", v18);
throw v20;
catch java.lang.Exception from label1 to label2 with label3;
}
static transient io.netty.handler.ssl.SslContext newClientContextInternal(io.netty.handler.ssl.SslProvider, java.security.Provider, java.security.cert.X509Certificate[], javax.net.ssl.TrustManagerFactory, java.security.cert.X509Certificate[], java.security.PrivateKey, java.lang.String, javax.net.ssl.KeyManagerFactory, java.lang.Iterable, io.netty.handler.ssl.CipherSuiteFilter, io.netty.handler.ssl.ApplicationProtocolConfig, java.lang.String[], long, long, boolean, java.lang.String, java.util.Map$Entry[]) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.JdkSslClientContext v22;
java.lang.Error v25;
java.lang.String[] v11;
long v12, v13;
java.lang.Iterable v8;
io.netty.handler.ssl.CipherSuiteFilter v9;
int[] v17;
int v18, v19;
java.lang.String v15, v21, v26, v6;
io.netty.handler.ssl.OpenSslClientContext v23;
java.util.Map$Entry[] v16;
io.netty.handler.ssl.ApplicationProtocolConfig v10;
boolean v14;
io.netty.handler.ssl.ReferenceCountedOpenSslClientContext v24;
javax.net.ssl.TrustManagerFactory v3;
javax.net.ssl.KeyManagerFactory v7;
java.lang.IllegalArgumentException v20;
java.security.Provider v1;
io.netty.handler.ssl.SslProvider v0;
java.security.PrivateKey v5;
java.security.cert.X509Certificate[] v2, v4;
v0 := @parameter0: io.netty.handler.ssl.SslProvider;
v1 := @parameter1: java.security.Provider;
v2 := @parameter2: java.security.cert.X509Certificate[];
v3 := @parameter3: javax.net.ssl.TrustManagerFactory;
v4 := @parameter4: java.security.cert.X509Certificate[];
v5 := @parameter5: java.security.PrivateKey;
v6 := @parameter6: java.lang.String;
v7 := @parameter7: javax.net.ssl.KeyManagerFactory;
v8 := @parameter8: java.lang.Iterable;
v9 := @parameter9: io.netty.handler.ssl.CipherSuiteFilter;
v10 := @parameter10: io.netty.handler.ssl.ApplicationProtocolConfig;
v11 := @parameter11: java.lang.String[];
v12 := @parameter12: long;
v13 := @parameter13: long;
v14 := @parameter14: boolean;
v15 := @parameter15: java.lang.String;
v16 := @parameter16: java.util.Map$Entry[];
if v0 != null goto label1;
v0 = staticinvoke <io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslProvider defaultClientProvider()>();
label1:
v17 = <io.netty.handler.ssl.SslContext$1: int[] $SwitchMap$io$netty$handler$ssl$SslProvider>;
v18 = virtualinvoke v0.<io.netty.handler.ssl.SslProvider: int ordinal()>();
v19 = v17[v18];
tableswitch(v19)
{
case 1: goto label2;
case 2: goto label4;
case 3: goto label5;
default: goto label6;
};
label2:
if v14 == 0 goto label3;
v20 = new java.lang.IllegalArgumentException;
v21 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (io.netty.handler.ssl.SslProvider)>(v0) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("OCSP is not supported with this SslProvider: \u0001");
specialinvoke v20.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(v21);
throw v20;
label3:
v22 = new io.netty.handler.ssl.JdkSslClientContext;
specialinvoke v22.<io.netty.handler.ssl.JdkSslClientContext: void <init>(java.security.Provider,java.security.cert.X509Certificate[],javax.net.ssl.TrustManagerFactory,java.security.cert.X509Certificate[],java.security.PrivateKey,java.lang.String,javax.net.ssl.KeyManagerFactory,java.lang.Iterable,io.netty.handler.ssl.CipherSuiteFilter,io.netty.handler.ssl.ApplicationProtocolConfig,java.lang.String[],long,long,java.lang.String)>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v15);
return v22;
label4:
staticinvoke <io.netty.handler.ssl.SslContext: void verifyNullSslContextProvider(io.netty.handler.ssl.SslProvider,java.security.Provider)>(v0, v1);
staticinvoke <io.netty.handler.ssl.OpenSsl: void ensureAvailability()>();
v23 = new io.netty.handler.ssl.OpenSslClientContext;
specialinvoke v23.<io.netty.handler.ssl.OpenSslClientContext: void <init>(java.security.cert.X509Certificate[],javax.net.ssl.TrustManagerFactory,java.security.cert.X509Certificate[],java.security.PrivateKey,java.lang.String,javax.net.ssl.KeyManagerFactory,java.lang.Iterable,io.netty.handler.ssl.CipherSuiteFilter,io.netty.handler.ssl.ApplicationProtocolConfig,java.lang.String[],long,long,boolean,java.lang.String,java.util.Map$Entry[])>(v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16);
return v23;
label5:
staticinvoke <io.netty.handler.ssl.SslContext: void verifyNullSslContextProvider(io.netty.handler.ssl.SslProvider,java.security.Provider)>(v0, v1);
staticinvoke <io.netty.handler.ssl.OpenSsl: void ensureAvailability()>();
v24 = new io.netty.handler.ssl.ReferenceCountedOpenSslClientContext;
specialinvoke v24.<io.netty.handler.ssl.ReferenceCountedOpenSslClientContext: void <init>(java.security.cert.X509Certificate[],javax.net.ssl.TrustManagerFactory,java.security.cert.X509Certificate[],java.security.PrivateKey,java.lang.String,javax.net.ssl.KeyManagerFactory,java.lang.Iterable,io.netty.handler.ssl.CipherSuiteFilter,io.netty.handler.ssl.ApplicationProtocolConfig,java.lang.String[],long,long,boolean,java.lang.String,java.util.Map$Entry[])>(v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16);
return v24;
label6:
v25 = new java.lang.Error;
v26 = virtualinvoke v0.<io.netty.handler.ssl.SslProvider: java.lang.String toString()>();
specialinvoke v25.<java.lang.Error: void <init>(java.lang.String)>(v26);
throw v25;
}
static io.netty.handler.ssl.ApplicationProtocolConfig toApplicationProtocolConfig(java.lang.Iterable)
{
io.netty.handler.ssl.ApplicationProtocolConfig$Protocol v3;
io.netty.handler.ssl.ApplicationProtocolConfig$SelectedListenerFailureBehavior v5;
io.netty.handler.ssl.ApplicationProtocolConfig$SelectorFailureBehavior v4;
io.netty.handler.ssl.ApplicationProtocolConfig v1, v2;
java.lang.Iterable v0;
v0 := @parameter0: java.lang.Iterable;
if v0 != null goto label1;
v1 = <io.netty.handler.ssl.ApplicationProtocolConfig: io.netty.handler.ssl.ApplicationProtocolConfig DISABLED>;
goto label2;
label1:
v2 = new io.netty.handler.ssl.ApplicationProtocolConfig;
v3 = <io.netty.handler.ssl.ApplicationProtocolConfig$Protocol: io.netty.handler.ssl.ApplicationProtocolConfig$Protocol NPN_AND_ALPN>;
v4 = <io.netty.handler.ssl.ApplicationProtocolConfig$SelectorFailureBehavior: io.netty.handler.ssl.ApplicationProtocolConfig$SelectorFailureBehavior CHOOSE_MY_LAST_PROTOCOL>;
v5 = <io.netty.handler.ssl.ApplicationProtocolConfig$SelectedListenerFailureBehavior: io.netty.handler.ssl.ApplicationProtocolConfig$SelectedListenerFailureBehavior ACCEPT>;
specialinvoke v2.<io.netty.handler.ssl.ApplicationProtocolConfig: void <init>(io.netty.handler.ssl.ApplicationProtocolConfig$Protocol,io.netty.handler.ssl.ApplicationProtocolConfig$SelectorFailureBehavior,io.netty.handler.ssl.ApplicationProtocolConfig$SelectedListenerFailureBehavior,java.lang.Iterable)>(v3, v4, v5, v0);
v1 = v2;
label2:
return v1;
}
protected void <init>()
{
io.netty.handler.ssl.SslContext v0;
v0 := @this: io.netty.handler.ssl.SslContext;
specialinvoke v0.<io.netty.handler.ssl.SslContext: void <init>(boolean)>(0);
return;
}
protected void <init>(boolean)
{
io.netty.handler.ssl.SslContext v0;
io.netty.util.DefaultAttributeMap v2;
boolean v1;
v0 := @this: io.netty.handler.ssl.SslContext;
v1 := @parameter0: boolean;
specialinvoke v0.<java.lang.Object: void <init>()>();
v2 = new io.netty.util.DefaultAttributeMap;
specialinvoke v2.<io.netty.util.DefaultAttributeMap: void <init>()>();
v0.<io.netty.handler.ssl.SslContext: io.netty.util.AttributeMap attributes> = v2;
v0.<io.netty.handler.ssl.SslContext: boolean startTls> = v1;
return;
}
public final io.netty.util.AttributeMap attributes()
{
io.netty.util.AttributeMap v1;
io.netty.handler.ssl.SslContext v0;
v0 := @this: io.netty.handler.ssl.SslContext;
v1 = v0.<io.netty.handler.ssl.SslContext: io.netty.util.AttributeMap attributes>;
return v1;
}
public final boolean isServer()
{
io.netty.handler.ssl.SslContext v0;
boolean v1, v2;
v0 := @this: io.netty.handler.ssl.SslContext;
v1 = virtualinvoke v0.<io.netty.handler.ssl.SslContext: boolean isClient()>();
if v1 != 0 goto label1;
v2 = 1;
goto label2;
label1:
v2 = 0;
label2:
return v2;
}
public abstract boolean isClient();
public abstract java.util.List cipherSuites();
public long sessionCacheSize()
{
int v2;
io.netty.handler.ssl.SslContext v0;
javax.net.ssl.SSLSessionContext v1;
v0 := @this: io.netty.handler.ssl.SslContext;
v1 = virtualinvoke v0.<io.netty.handler.ssl.SslContext: javax.net.ssl.SSLSessionContext sessionContext()>();
v2 = interfaceinvoke v1.<javax.net.ssl.SSLSessionContext: int getSessionCacheSize()>();
return v2;
}
public long sessionTimeout()
{
int v2;
io.netty.handler.ssl.SslContext v0;
javax.net.ssl.SSLSessionContext v1;
v0 := @this: io.netty.handler.ssl.SslContext;
v1 = virtualinvoke v0.<io.netty.handler.ssl.SslContext: javax.net.ssl.SSLSessionContext sessionContext()>();
v2 = interfaceinvoke v1.<javax.net.ssl.SSLSessionContext: int getSessionTimeout()>();
return v2;
}
public final java.util.List nextProtocols()
{
io.netty.handler.ssl.ApplicationProtocolNegotiator v1;
java.util.List v2;
io.netty.handler.ssl.SslContext v0;
v0 := @this: io.netty.handler.ssl.SslContext;
v1 = virtualinvoke v0.<io.netty.handler.ssl.SslContext: io.netty.handler.ssl.ApplicationProtocolNegotiator applicationProtocolNegotiator()>();
v2 = interfaceinvoke v1.<io.netty.handler.ssl.ApplicationProtocolNegotiator: java.util.List protocols()>();
return v2;
}
public abstract io.netty.handler.ssl.ApplicationProtocolNegotiator applicationProtocolNegotiator();
public abstract javax.net.ssl.SSLEngine newEngine(io.netty.buffer.ByteBufAllocator);
public abstract javax.net.ssl.SSLEngine newEngine(io.netty.buffer.ByteBufAllocator, java.lang.String, int);
public abstract javax.net.ssl.SSLSessionContext sessionContext();
public final io.netty.handler.ssl.SslHandler newHandler(io.netty.buffer.ByteBufAllocator)
{
io.netty.handler.ssl.SslContext v0;
io.netty.handler.ssl.SslHandler v3;
io.netty.buffer.ByteBufAllocator v1;
boolean v2;
v0 := @this: io.netty.handler.ssl.SslContext;
v1 := @parameter0: io.netty.buffer.ByteBufAllocator;
v2 = v0.<io.netty.handler.ssl.SslContext: boolean startTls>;
v3 = virtualinvoke v0.<io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslHandler newHandler(io.netty.buffer.ByteBufAllocator,boolean)>(v1, v2);
return v3;
}
protected io.netty.handler.ssl.SslHandler newHandler(io.netty.buffer.ByteBufAllocator, boolean)
{
io.netty.handler.ssl.SslContext v0;
io.netty.handler.ssl.SslHandler v3;
io.netty.buffer.ByteBufAllocator v1;
boolean v2;
javax.net.ssl.SSLEngine v4;
v0 := @this: io.netty.handler.ssl.SslContext;
v1 := @parameter0: io.netty.buffer.ByteBufAllocator;
v2 := @parameter1: boolean;
v3 = new io.netty.handler.ssl.SslHandler;
v4 = virtualinvoke v0.<io.netty.handler.ssl.SslContext: javax.net.ssl.SSLEngine newEngine(io.netty.buffer.ByteBufAllocator)>(v1);
specialinvoke v3.<io.netty.handler.ssl.SslHandler: void <init>(javax.net.ssl.SSLEngine,boolean)>(v4, v2);
return v3;
}
public io.netty.handler.ssl.SslHandler newHandler(io.netty.buffer.ByteBufAllocator, java.util.concurrent.Executor)
{
io.netty.handler.ssl.SslContext v0;
io.netty.handler.ssl.SslHandler v4;
java.util.concurrent.Executor v2;
io.netty.buffer.ByteBufAllocator v1;
boolean v3;
v0 := @this: io.netty.handler.ssl.SslContext;
v1 := @parameter0: io.netty.buffer.ByteBufAllocator;
v2 := @parameter1: java.util.concurrent.Executor;
v3 = v0.<io.netty.handler.ssl.SslContext: boolean startTls>;
v4 = virtualinvoke v0.<io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslHandler newHandler(io.netty.buffer.ByteBufAllocator,boolean,java.util.concurrent.Executor)>(v1, v3, v2);
return v4;
}
protected io.netty.handler.ssl.SslHandler newHandler(io.netty.buffer.ByteBufAllocator, boolean, java.util.concurrent.Executor)
{
io.netty.handler.ssl.SslContext v0;
io.netty.handler.ssl.SslHandler v4;
java.util.concurrent.Executor v3;
io.netty.buffer.ByteBufAllocator v1;
boolean v2;
javax.net.ssl.SSLEngine v5;
v0 := @this: io.netty.handler.ssl.SslContext;
v1 := @parameter0: io.netty.buffer.ByteBufAllocator;
v2 := @parameter1: boolean;
v3 := @parameter2: java.util.concurrent.Executor;
v4 = new io.netty.handler.ssl.SslHandler;
v5 = virtualinvoke v0.<io.netty.handler.ssl.SslContext: javax.net.ssl.SSLEngine newEngine(io.netty.buffer.ByteBufAllocator)>(v1);
specialinvoke v4.<io.netty.handler.ssl.SslHandler: void <init>(javax.net.ssl.SSLEngine,boolean,java.util.concurrent.Executor)>(v5, v2, v3);
return v4;
}
public final io.netty.handler.ssl.SslHandler newHandler(io.netty.buffer.ByteBufAllocator, java.lang.String, int)
{
io.netty.handler.ssl.SslContext v0;
io.netty.handler.ssl.SslHandler v5;
io.netty.buffer.ByteBufAllocator v1;
int v3;
java.lang.String v2;
boolean v4;
v0 := @this: io.netty.handler.ssl.SslContext;
v1 := @parameter0: io.netty.buffer.ByteBufAllocator;
v2 := @parameter1: java.lang.String;
v3 := @parameter2: int;
v4 = v0.<io.netty.handler.ssl.SslContext: boolean startTls>;
v5 = virtualinvoke v0.<io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslHandler newHandler(io.netty.buffer.ByteBufAllocator,java.lang.String,int,boolean)>(v1, v2, v3, v4);
return v5;
}
protected io.netty.handler.ssl.SslHandler newHandler(io.netty.buffer.ByteBufAllocator, java.lang.String, int, boolean)
{
io.netty.handler.ssl.SslContext v0;
io.netty.handler.ssl.SslHandler v5;
io.netty.buffer.ByteBufAllocator v1;
int v3;
java.lang.String v2;
boolean v4;
javax.net.ssl.SSLEngine v6;
v0 := @this: io.netty.handler.ssl.SslContext;
v1 := @parameter0: io.netty.buffer.ByteBufAllocator;
v2 := @parameter1: java.lang.String;
v3 := @parameter2: int;
v4 := @parameter3: boolean;
v5 = new io.netty.handler.ssl.SslHandler;
v6 = virtualinvoke v0.<io.netty.handler.ssl.SslContext: javax.net.ssl.SSLEngine newEngine(io.netty.buffer.ByteBufAllocator,java.lang.String,int)>(v1, v2, v3);
specialinvoke v5.<io.netty.handler.ssl.SslHandler: void <init>(javax.net.ssl.SSLEngine,boolean)>(v6, v4);
return v5;
}
public io.netty.handler.ssl.SslHandler newHandler(io.netty.buffer.ByteBufAllocator, java.lang.String, int, java.util.concurrent.Executor)
{
io.netty.handler.ssl.SslContext v0;
io.netty.handler.ssl.SslHandler v6;
java.util.concurrent.Executor v4;
io.netty.buffer.ByteBufAllocator v1;
int v3;
java.lang.String v2;
boolean v5;
v0 := @this: io.netty.handler.ssl.SslContext;
v1 := @parameter0: io.netty.buffer.ByteBufAllocator;
v2 := @parameter1: java.lang.String;
v3 := @parameter2: int;
v4 := @parameter3: java.util.concurrent.Executor;
v5 = v0.<io.netty.handler.ssl.SslContext: boolean startTls>;
v6 = virtualinvoke v0.<io.netty.handler.ssl.SslContext: io.netty.handler.ssl.SslHandler newHandler(io.netty.buffer.ByteBufAllocator,java.lang.String,int,boolean,java.util.concurrent.Executor)>(v1, v2, v3, v5, v4);
return v6;
}
protected io.netty.handler.ssl.SslHandler newHandler(io.netty.buffer.ByteBufAllocator, java.lang.String, int, boolean, java.util.concurrent.Executor)
{
io.netty.handler.ssl.SslContext v0;
java.util.concurrent.Executor v5;
io.netty.buffer.ByteBufAllocator v1;
javax.net.ssl.SSLEngine v7;
io.netty.handler.ssl.SslHandler v6;
int v3;
java.lang.String v2;
boolean v4;
v0 := @this: io.netty.handler.ssl.SslContext;
v1 := @parameter0: io.netty.buffer.ByteBufAllocator;
v2 := @parameter1: java.lang.String;
v3 := @parameter2: int;
v4 := @parameter3: boolean;
v5 := @parameter4: java.util.concurrent.Executor;
v6 = new io.netty.handler.ssl.SslHandler;
v7 = virtualinvoke v0.<io.netty.handler.ssl.SslContext: javax.net.ssl.SSLEngine newEngine(io.netty.buffer.ByteBufAllocator,java.lang.String,int)>(v1, v2, v3);
specialinvoke v6.<io.netty.handler.ssl.SslHandler: void <init>(javax.net.ssl.SSLEngine,boolean,java.util.concurrent.Executor)>(v7, v4, v5);
return v6;
}
protected static java.security.spec.PKCS8EncodedKeySpec generateKeySpec(char[], byte[]) throws java.io.IOException, java.security.NoSuchAlgorithmException, javax.crypto.NoSuchPaddingException, java.security.spec.InvalidKeySpecException, java.security.InvalidKeyException, java.security.InvalidAlgorithmParameterException
{
byte[] v1;
java.security.spec.PKCS8EncodedKeySpec v11, v2;
javax.crypto.Cipher v9;
java.security.AlgorithmParameters v10;
javax.crypto.SecretKeyFactory v5;
javax.crypto.EncryptedPrivateKeyInfo v3;
javax.crypto.spec.PBEKeySpec v6;
char[] v0;
java.lang.String v4, v8;
javax.crypto.SecretKey v7;
v0 := @parameter0: char[];
v1 := @parameter1: byte[];
if v0 != null goto label1;
v2 = new java.security.spec.PKCS8EncodedKeySpec;
specialinvoke v2.<java.security.spec.PKCS8EncodedKeySpec: void <init>(byte[])>(v1);
return v2;
label1:
v3 = new javax.crypto.EncryptedPrivateKeyInfo;
specialinvoke v3.<javax.crypto.EncryptedPrivateKeyInfo: void <init>(byte[])>(v1);
v4 = virtualinvoke v3.<javax.crypto.EncryptedPrivateKeyInfo: java.lang.String getAlgName()>();
v5 = staticinvoke <javax.crypto.SecretKeyFactory: javax.crypto.SecretKeyFactory getInstance(java.lang.String)>(v4);
v6 = new javax.crypto.spec.PBEKeySpec;
specialinvoke v6.<javax.crypto.spec.PBEKeySpec: void <init>(char[])>(v0);
v7 = virtualinvoke v5.<javax.crypto.SecretKeyFactory: javax.crypto.SecretKey generateSecret(java.security.spec.KeySpec)>(v6);
v8 = virtualinvoke v3.<javax.crypto.EncryptedPrivateKeyInfo: java.lang.String getAlgName()>();
v9 = staticinvoke <javax.crypto.Cipher: javax.crypto.Cipher getInstance(java.lang.String)>(v8);
v10 = virtualinvoke v3.<javax.crypto.EncryptedPrivateKeyInfo: java.security.AlgorithmParameters getAlgParameters()>();
virtualinvoke v9.<javax.crypto.Cipher: void init(int,java.security.Key,java.security.AlgorithmParameters)>(2, v7, v10);
v11 = virtualinvoke v3.<javax.crypto.EncryptedPrivateKeyInfo: java.security.spec.PKCS8EncodedKeySpec getKeySpec(javax.crypto.Cipher)>(v9);
return v11;
}
protected static java.security.KeyStore buildKeyStore(java.security.cert.X509Certificate[], java.security.PrivateKey, char[], java.lang.String) throws java.security.KeyStoreException, java.security.NoSuchAlgorithmException, java.security.cert.CertificateException, java.io.IOException
{
java.security.PrivateKey v1;
char[] v2;
java.security.KeyStore v4;
java.lang.String v3;
java.security.cert.X509Certificate[] v0;
v0 := @parameter0: java.security.cert.X509Certificate[];
v1 := @parameter1: java.security.PrivateKey;
v2 := @parameter2: char[];
v3 := @parameter3: java.lang.String;
if v3 != null goto label1;
v3 = staticinvoke <java.security.KeyStore: java.lang.String getDefaultType()>();
label1:
v4 = staticinvoke <java.security.KeyStore: java.security.KeyStore getInstance(java.lang.String)>(v3);
virtualinvoke v4.<java.security.KeyStore: void load(java.io.InputStream,char[])>(null, null);
virtualinvoke v4.<java.security.KeyStore: void setKeyEntry(java.lang.String,java.security.Key,char[],java.security.cert.Certificate[])>("key", v1, v2, v0);
return v4;
}
protected static java.security.PrivateKey toPrivateKey(java.io.File, java.lang.String) throws java.security.NoSuchAlgorithmException, javax.crypto.NoSuchPaddingException, java.security.spec.InvalidKeySpecException, java.security.InvalidAlgorithmParameterException, java.security.KeyException, java.io.IOException
{
io.netty.buffer.ByteBuf v4;
java.security.PrivateKey v3, v5;
java.lang.String v1;
java.io.File v0;
boolean v2;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
if v0 != null goto label1;
return null;
label1:
v2 = staticinvoke <io.netty.handler.ssl.BouncyCastlePemReader: boolean isAvailable()>();
if v2 == 0 goto label2;
v3 = staticinvoke <io.netty.handler.ssl.BouncyCastlePemReader: java.security.PrivateKey getPrivateKey(java.io.File,java.lang.String)>(v0, v1);
if v3 == null goto label2;
return v3;
label2:
v4 = staticinvoke <io.netty.handler.ssl.PemReader: io.netty.buffer.ByteBuf readPrivateKey(java.io.File)>(v0);
v5 = staticinvoke <io.netty.handler.ssl.SslContext: java.security.PrivateKey getPrivateKeyFromByteBuffer(io.netty.buffer.ByteBuf,java.lang.String)>(v4, v1);
return v5;
}
protected static java.security.PrivateKey toPrivateKey(java.io.InputStream, java.lang.String) throws java.security.NoSuchAlgorithmException, javax.crypto.NoSuchPaddingException, java.security.spec.InvalidKeySpecException, java.security.InvalidAlgorithmParameterException, java.security.KeyException, java.io.IOException
{
java.io.BufferedInputStream v4;
io.netty.buffer.ByteBuf v6;
java.security.PrivateKey v5, v7;
java.lang.String v1;
boolean v2, v3;
java.io.InputStream v0;
v0 := @parameter0: java.io.InputStream;
v1 := @parameter1: java.lang.String;
if v0 != null goto label1;
return null;
label1:
v2 = staticinvoke <io.netty.handler.ssl.BouncyCastlePemReader: boolean isAvailable()>();
if v2 == 0 goto label4;
v3 = virtualinvoke v0.<java.io.InputStream: boolean markSupported()>();
if v3 != 0 goto label2;
v4 = new java.io.BufferedInputStream;
specialinvoke v4.<java.io.BufferedInputStream: void <init>(java.io.InputStream)>(v0);
v0 = v4;
label2:
virtualinvoke v0.<java.io.InputStream: void mark(int)>(1048576);
v5 = staticinvoke <io.netty.handler.ssl.BouncyCastlePemReader: java.security.PrivateKey getPrivateKey(java.io.InputStream,java.lang.String)>(v0, v1);
if v5 == null goto label3;
return v5;
label3:
virtualinvoke v0.<java.io.InputStream: void reset()>();
label4:
v6 = staticinvoke <io.netty.handler.ssl.PemReader: io.netty.buffer.ByteBuf readPrivateKey(java.io.InputStream)>(v0);
v7 = staticinvoke <io.netty.handler.ssl.SslContext: java.security.PrivateKey getPrivateKeyFromByteBuffer(io.netty.buffer.ByteBuf,java.lang.String)>(v6, v1);
return v7;
}
private static java.security.PrivateKey getPrivateKeyFromByteBuffer(io.netty.buffer.ByteBuf, java.lang.String) throws java.security.NoSuchAlgorithmException, javax.crypto.NoSuchPaddingException, java.security.spec.InvalidKeySpecException, java.security.InvalidAlgorithmParameterException, java.security.KeyException, java.io.IOException
{
byte[] v3;
java.security.spec.InvalidKeySpecException v12, v15, v16, v9;
io.netty.buffer.ByteBuf v0, v4;
int v2;
java.lang.String v1;
java.security.spec.PKCS8EncodedKeySpec v6;
java.security.KeyFactory v10, v13, v7;
java.security.PrivateKey v11, v14, v8;
char[] v5;
v0 := @parameter0: io.netty.buffer.ByteBuf;
v1 := @parameter1: java.lang.String;
v2 = virtualinvoke v0.<io.netty.buffer.ByteBuf: int readableBytes()>();
v3 = newarray (byte)[v2];
v4 = virtualinvoke v0.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf readBytes(byte[])>(v3);
virtualinvoke v4.<io.netty.buffer.ByteBuf: boolean release()>();
if v1 != null goto label01;
v5 = null;
goto label02;
label01:
v5 = virtualinvoke v1.<java.lang.String: char[] toCharArray()>();
label02:
v6 = staticinvoke <io.netty.handler.ssl.SslContext: java.security.spec.PKCS8EncodedKeySpec generateKeySpec(char[],byte[])>(v5, v3);
label03:
v7 = staticinvoke <java.security.KeyFactory: java.security.KeyFactory getInstance(java.lang.String)>("RSA");
v8 = virtualinvoke v7.<java.security.KeyFactory: java.security.PrivateKey generatePrivate(java.security.spec.KeySpec)>(v6);
label04:
return v8;
label05:
v9 := @caughtexception;
label06:
v10 = staticinvoke <java.security.KeyFactory: java.security.KeyFactory getInstance(java.lang.String)>("DSA");
v11 = virtualinvoke v10.<java.security.KeyFactory: java.security.PrivateKey generatePrivate(java.security.spec.KeySpec)>(v6);
label07:
return v11;
label08:
v12 := @caughtexception;
label09:
v13 = staticinvoke <java.security.KeyFactory: java.security.KeyFactory getInstance(java.lang.String)>("EC");
v14 = virtualinvoke v13.<java.security.KeyFactory: java.security.PrivateKey generatePrivate(java.security.spec.KeySpec)>(v6);
label10:
return v14;
label11:
v15 := @caughtexception;
v16 = new java.security.spec.InvalidKeySpecException;
specialinvoke v16.<java.security.spec.InvalidKeySpecException: void <init>(java.lang.String,java.lang.Throwable)>("Neither RSA, DSA nor EC worked", v15);
throw v16;
catch java.security.spec.InvalidKeySpecException from label03 to label04 with label05;
catch java.security.spec.InvalidKeySpecException from label06 to label07 with label08;
catch java.security.spec.InvalidKeySpecException from label09 to label10 with label11;
}
protected static javax.net.ssl.TrustManagerFactory buildTrustManagerFactory(java.io.File, javax.net.ssl.TrustManagerFactory) throws java.security.NoSuchAlgorithmException, java.security.cert.CertificateException, java.security.KeyStoreException, java.io.IOException
{
javax.net.ssl.TrustManagerFactory v1, v2;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 := @parameter1: javax.net.ssl.TrustManagerFactory;
v2 = staticinvoke <io.netty.handler.ssl.SslContext: javax.net.ssl.TrustManagerFactory buildTrustManagerFactory(java.io.File,javax.net.ssl.TrustManagerFactory,java.lang.String)>(v0, v1, null);
return v2;
}
protected static javax.net.ssl.TrustManagerFactory buildTrustManagerFactory(java.io.File, javax.net.ssl.TrustManagerFactory, java.lang.String) throws java.security.NoSuchAlgorithmException, java.security.cert.CertificateException, java.security.KeyStoreException, java.io.IOException
{
javax.net.ssl.TrustManagerFactory v1, v4;
java.lang.String v2;
java.security.cert.X509Certificate[] v3;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 := @parameter1: javax.net.ssl.TrustManagerFactory;
v2 := @parameter2: java.lang.String;
v3 = staticinvoke <io.netty.handler.ssl.SslContext: java.security.cert.X509Certificate[] toX509Certificates(java.io.File)>(v0);
v4 = staticinvoke <io.netty.handler.ssl.SslContext: javax.net.ssl.TrustManagerFactory buildTrustManagerFactory(java.security.cert.X509Certificate[],javax.net.ssl.TrustManagerFactory,java.lang.String)>(v3, v1, v2);
return v4;
}
protected static java.security.cert.X509Certificate[] toX509Certificates(java.io.File) throws java.security.cert.CertificateException
{
io.netty.buffer.ByteBuf[] v1;
java.security.cert.X509Certificate[] v2;
java.io.File v0;
v0 := @parameter0: java.io.File;
if v0 != null goto label1;
return null;
label1:
v1 = staticinvoke <io.netty.handler.ssl.PemReader: io.netty.buffer.ByteBuf[] readCertificates(java.io.File)>(v0);
v2 = staticinvoke <io.netty.handler.ssl.SslContext: java.security.cert.X509Certificate[] getCertificatesFromBuffers(io.netty.buffer.ByteBuf[])>(v1);
return v2;
}
protected static java.security.cert.X509Certificate[] toX509Certificates(java.io.InputStream) throws java.security.cert.CertificateException
{
io.netty.buffer.ByteBuf[] v1;
java.security.cert.X509Certificate[] v2;
java.io.InputStream v0;
v0 := @parameter0: java.io.InputStream;
if v0 != null goto label1;
return null;
label1:
v1 = staticinvoke <io.netty.handler.ssl.PemReader: io.netty.buffer.ByteBuf[] readCertificates(java.io.InputStream)>(v0);
v2 = staticinvoke <io.netty.handler.ssl.SslContext: java.security.cert.X509Certificate[] getCertificatesFromBuffers(io.netty.buffer.ByteBuf[])>(v1);
return v2;
}
private static java.security.cert.X509Certificate[] getCertificatesFromBuffers(io.netty.buffer.ByteBuf[]) throws java.security.cert.CertificateException
{
java.lang.Throwable v13, v9;
java.security.cert.CertificateFactory v1;
io.netty.buffer.ByteBuf v12, v16, v7;
int v10, v11, v14, v15, v2, v4, v5;
io.netty.buffer.ByteBufInputStream v6;
io.netty.buffer.ByteBuf[] v0;
java.security.cert.Certificate v8;
java.security.cert.X509Certificate[] v3;
v0 := @parameter0: io.netty.buffer.ByteBuf[];
v1 = staticinvoke <java.security.cert.CertificateFactory: java.security.cert.CertificateFactory getInstance(java.lang.String)>("X.509");
v2 = lengthof v0;
v3 = newarray (java.security.cert.X509Certificate)[v2];
label01:
v4 = 0;
label02:
v5 = lengthof v0;
if v4 >= v5 goto label07;
v6 = new io.netty.buffer.ByteBufInputStream;
v7 = v0[v4];
specialinvoke v6.<io.netty.buffer.ByteBufInputStream: void <init>(io.netty.buffer.ByteBuf,boolean)>(v7, 0);
label03:
v8 = virtualinvoke v1.<java.security.cert.CertificateFactory: java.security.cert.Certificate generateCertificate(java.io.InputStream)>(v6);
v3[v4] = v8;
label04:
goto label06;
label05:
v9 := @caughtexception;
throw v9;
label06:
v4 = v4 + 1;
goto label02;
label07:
v10 = lengthof v0;
v11 = 0;
label08:
if v11 >= v10 goto label12;
v12 = v0[v11];
virtualinvoke v12.<io.netty.buffer.ByteBuf: boolean release()>();
v11 = v11 + 1;
goto label08;
label09:
v13 := @caughtexception;
v14 = lengthof v0;
v15 = 0;
label10:
if v15 >= v14 goto label11;
v16 = v0[v15];
virtualinvoke v16.<io.netty.buffer.ByteBuf: boolean release()>();
v15 = v15 + 1;
goto label10;
label11:
throw v13;
label12:
return v3;
catch java.lang.Throwable from label03 to label04 with label05;
catch java.lang.Throwable from label01 to label07 with label09;
}
protected static javax.net.ssl.TrustManagerFactory buildTrustManagerFactory(java.security.cert.X509Certificate[], javax.net.ssl.TrustManagerFactory, java.lang.String) throws java.security.NoSuchAlgorithmException, java.security.cert.CertificateException, java.security.KeyStoreException, java.io.IOException
{
java.security.cert.X509Certificate v7;
javax.net.ssl.TrustManagerFactory v1;
java.security.KeyStore v3;
int v4, v5, v6;
java.lang.String v2, v8, v9;
java.security.cert.X509Certificate[] v0;
v0 := @parameter0: java.security.cert.X509Certificate[];
v1 := @parameter1: javax.net.ssl.TrustManagerFactory;
v2 := @parameter2: java.lang.String;
if v2 != null goto label1;
v2 = staticinvoke <java.security.KeyStore: java.lang.String getDefaultType()>();
label1:
v3 = staticinvoke <java.security.KeyStore: java.security.KeyStore getInstance(java.lang.String)>(v2);
virtualinvoke v3.<java.security.KeyStore: void load(java.io.InputStream,char[])>(null, null);
v4 = 1;
v5 = lengthof v0;
v6 = 0;
label2:
if v6 >= v5 goto label3;
v7 = v0[v6];
v8 = staticinvoke <java.lang.Integer: java.lang.String toString(int)>(v4);
virtualinvoke v3.<java.security.KeyStore: void setCertificateEntry(java.lang.String,java.security.cert.Certificate)>(v8, v7);
v4 = v4 + 1;
v6 = v6 + 1;
goto label2;
label3:
if v1 != null goto label4;
v9 = staticinvoke <javax.net.ssl.TrustManagerFactory: java.lang.String getDefaultAlgorithm()>();
v1 = staticinvoke <javax.net.ssl.TrustManagerFactory: javax.net.ssl.TrustManagerFactory getInstance(java.lang.String)>(v9);
label4:
virtualinvoke v1.<javax.net.ssl.TrustManagerFactory: void init(java.security.KeyStore)>(v3);
return v1;
}
static java.security.PrivateKey toPrivateKeyInternal(java.io.File, java.lang.String) throws javax.net.ssl.SSLException
{
javax.net.ssl.SSLException v4;
java.security.PrivateKey v2;
java.lang.String v1;
java.io.File v0;
java.lang.Exception v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
label1:
v2 = staticinvoke <io.netty.handler.ssl.SslContext: java.security.PrivateKey toPrivateKey(java.io.File,java.lang.String)>(v0, v1);
label2:
return v2;
label3:
v3 := @caughtexception;
v4 = new javax.net.ssl.SSLException;
specialinvoke v4.<javax.net.ssl.SSLException: void <init>(java.lang.Throwable)>(v3);
throw v4;
catch java.lang.Exception from label1 to label2 with label3;
}
static java.security.cert.X509Certificate[] toX509CertificatesInternal(java.io.File) throws javax.net.ssl.SSLException
{
javax.net.ssl.SSLException v3;
java.security.cert.CertificateException v2;
java.security.cert.X509Certificate[] v1;
java.io.File v0;
v0 := @parameter0: java.io.File;
label1:
v1 = staticinvoke <io.netty.handler.ssl.SslContext: java.security.cert.X509Certificate[] toX509Certificates(java.io.File)>(v0);
label2:
return v1;
label3:
v2 := @caughtexception;
v3 = new javax.net.ssl.SSLException;
specialinvoke v3.<javax.net.ssl.SSLException: void <init>(java.lang.Throwable)>(v2);
throw v3;
catch java.security.cert.CertificateException from label1 to label2 with label3;
}
protected static javax.net.ssl.KeyManagerFactory buildKeyManagerFactory(java.security.cert.X509Certificate[], java.lang.String, java.security.PrivateKey, java.lang.String, javax.net.ssl.KeyManagerFactory, java.lang.String) throws java.security.KeyStoreException, java.security.NoSuchAlgorithmException, java.io.IOException, java.security.cert.CertificateException, java.security.UnrecoverableKeyException
{
javax.net.ssl.KeyManagerFactory v4, v8;
java.security.KeyStore v7;
java.security.PrivateKey v2;
char[] v6;
java.lang.String v1, v3, v5;
java.security.cert.X509Certificate[] v0;
v0 := @parameter0: java.security.cert.X509Certificate[];
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.security.PrivateKey;
v3 := @parameter3: java.lang.String;
v4 := @parameter4: javax.net.ssl.KeyManagerFactory;
v5 := @parameter5: java.lang.String;
if v1 != null goto label1;
v1 = staticinvoke <javax.net.ssl.KeyManagerFactory: java.lang.String getDefaultAlgorithm()>();
label1:
v6 = staticinvoke <io.netty.handler.ssl.SslContext: char[] keyStorePassword(java.lang.String)>(v3);
v7 = staticinvoke <io.netty.handler.ssl.SslContext: java.security.KeyStore buildKeyStore(java.security.cert.X509Certificate[],java.security.PrivateKey,char[],java.lang.String)>(v0, v2, v6, v5);
v8 = staticinvoke <io.netty.handler.ssl.SslContext: javax.net.ssl.KeyManagerFactory buildKeyManagerFactory(java.security.KeyStore,java.lang.String,char[],javax.net.ssl.KeyManagerFactory)>(v7, v1, v6, v4);
return v8;
}
static javax.net.ssl.KeyManagerFactory buildKeyManagerFactory(java.security.KeyStore, java.lang.String, char[], javax.net.ssl.KeyManagerFactory) throws java.security.KeyStoreException, java.security.NoSuchAlgorithmException, java.security.UnrecoverableKeyException
{
char[] v2;
javax.net.ssl.KeyManagerFactory v3;
java.security.KeyStore v0;
java.lang.String v1;
v0 := @parameter0: java.security.KeyStore;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: char[];
v3 := @parameter3: javax.net.ssl.KeyManagerFactory;
if v3 != null goto label2;
if v1 != null goto label1;
v1 = staticinvoke <javax.net.ssl.KeyManagerFactory: java.lang.String getDefaultAlgorithm()>();
label1:
v3 = staticinvoke <javax.net.ssl.KeyManagerFactory: javax.net.ssl.KeyManagerFactory getInstance(java.lang.String)>(v1);
label2:
virtualinvoke v3.<javax.net.ssl.KeyManagerFactory: void init(java.security.KeyStore,char[])>(v0, v2);
return v3;
}
static char[] keyStorePassword(java.lang.String)
{
char[] v1;
java.lang.String v0;
v0 := @parameter0: java.lang.String;
if v0 != null goto label1;
v1 = <io.netty.util.internal.EmptyArrays: char[] EMPTY_CHARS>;
goto label2;
label1:
v1 = virtualinvoke v0.<java.lang.String: char[] toCharArray()>();
label2:
return v1;
}
static void <clinit>()
{
java.lang.IllegalStateException v2;
java.security.cert.CertificateException v1;
java.security.cert.CertificateFactory v0;
label1:
v0 = staticinvoke <java.security.cert.CertificateFactory: java.security.cert.CertificateFactory getInstance(java.lang.String)>("X.509");
<io.netty.handler.ssl.SslContext: java.security.cert.CertificateFactory X509_CERT_FACTORY> = v0;
label2:
goto label4;
label3:
v1 := @caughtexception;
v2 = new java.lang.IllegalStateException;
specialinvoke v2.<java.lang.IllegalStateException: void <init>(java.lang.String,java.lang.Throwable)>("unable to instance X.509 CertificateFactory", v1);
throw v2;
label4:
return;
catch java.security.cert.CertificateException from label1 to label2 with label3;
}
}