public final class io.smallrye.config.ConfigMappingInterface extends java.lang.Object implements io.smallrye.config.ConfigMappingMetadata
{
static final io.smallrye.config.ConfigMappingInterface[] NO_TYPES;
static final io.smallrye.config.ConfigMappingInterface$Property[] NO_PROPERTIES;
static final java.lang.ClassValue cv;
private final java.lang.Class interfaceType;
private final java.lang.String className;
private final io.smallrye.config.ConfigMappingInterface[] superTypes;
private final io.smallrye.config.ConfigMappingInterface$Property[] properties;
private final java.util.Map propertiesByName;
private final io.smallrye.config.ConfigMappingInterface$NamingStrategy namingStrategy;
private final io.smallrye.config.ConfigMappingInterface$ToStringMethod toStringMethod;
private static final io.smallrye.config.ConfigMappingInterface$NamingStrategy DEFAULT_NAMING_STRATEGY;
private static final io.smallrye.config.ConfigMappingInterface$NamingStrategy VERBATIM_NAMING_STRATEGY;
private static final io.smallrye.config.ConfigMappingInterface$NamingStrategy KEBAB_CASE_NAMING_STRATEGY;
private static final io.smallrye.config.ConfigMappingInterface$NamingStrategy SNAKE_CASE_NAMING_STRATEGY;
void <init>(java.lang.Class, io.smallrye.config.ConfigMappingInterface[], io.smallrye.config.ConfigMappingInterface$Property[])
{
java.lang.Object[] v17;
io.smallrye.config.ConfigMappingInterface$Property v12;
io.smallrye.config.ConfigMappingInterface v0;
java.util.HashMap v9;
io.smallrye.config.ConfigMappingInterface$NamingStrategy v18;
java.util.ArrayList v8;
int v10, v11, v6;
java.lang.String v15, v4, v5, v7;
java.lang.reflect.Method v14;
boolean v13;
io.smallrye.config.ConfigMappingInterface$Property[] v16, v3;
io.smallrye.config.ConfigMappingInterface[] v2;
java.lang.Class v1;
v0 := @this: io.smallrye.config.ConfigMappingInterface;
v1 := @parameter0: java.lang.Class;
v2 := @parameter1: io.smallrye.config.ConfigMappingInterface[];
v3 := @parameter2: io.smallrye.config.ConfigMappingInterface$Property[];
specialinvoke v0.<java.lang.Object: void <init>()>();
v0.<io.smallrye.config.ConfigMappingInterface: java.lang.Class interfaceType> = v1;
v4 = virtualinvoke v1.<java.lang.Class: java.lang.String getName()>();
v5 = virtualinvoke v1.<java.lang.Class: java.lang.String getName()>();
v6 = virtualinvoke v5.<java.lang.String: int hashCode()>();
v7 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,int)>(v4, v6) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001\u0001Impl");
v0.<io.smallrye.config.ConfigMappingInterface: java.lang.String className> = v7;
v0.<io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface[] superTypes> = v2;
v8 = new java.util.ArrayList;
specialinvoke v8.<java.util.ArrayList: void <init>()>();
v9 = new java.util.HashMap;
specialinvoke v9.<java.util.HashMap: void <init>()>();
v10 = lengthof v3;
v11 = 0;
label1:
if v11 >= v10 goto label3;
v12 = v3[v11];
v13 = virtualinvoke v12.<io.smallrye.config.ConfigMappingInterface$Property: boolean isToStringMethod()>();
if v13 != 0 goto label2;
interfaceinvoke v8.<java.util.List: boolean add(java.lang.Object)>(v12);
v14 = virtualinvoke v12.<io.smallrye.config.ConfigMappingInterface$Property: java.lang.reflect.Method getMethod()>();
v15 = virtualinvoke v14.<java.lang.reflect.Method: java.lang.String getName()>();
interfaceinvoke v9.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>(v15, v12);
label2:
v11 = v11 + 1;
goto label1;
label3:
v16 = newarray (io.smallrye.config.ConfigMappingInterface$Property)[0];
v17 = interfaceinvoke v8.<java.util.List: java.lang.Object[] toArray(java.lang.Object[])>(v16);
v0.<io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$Property[] properties> = v17;
v0.<io.smallrye.config.ConfigMappingInterface: java.util.Map propertiesByName> = v9;
v18 = staticinvoke <io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$NamingStrategy getNamingStrategy(java.lang.Class)>(v1);
v0.<io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$NamingStrategy namingStrategy> = v18;
v0.<io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$ToStringMethod toStringMethod> = v12;
return;
}
public static io.smallrye.config.ConfigMappingInterface getConfigurationInterface(java.lang.Class)
{
java.lang.Class v0;
java.lang.Object v2;
java.lang.ClassValue v1;
v0 := @parameter0: java.lang.Class;
staticinvoke <io.smallrye.common.constraint.Assert: java.lang.Object checkNotNullParam(java.lang.String,java.lang.Object)>("interfaceType", v0);
v1 = <io.smallrye.config.ConfigMappingInterface: java.lang.ClassValue cv>;
v2 = virtualinvoke v1.<java.lang.ClassValue: java.lang.Object get(java.lang.Class)>(v0);
return v2;
}
public java.lang.Class getInterfaceType()
{
io.smallrye.config.ConfigMappingInterface v0;
java.lang.Class v1;
v0 := @this: io.smallrye.config.ConfigMappingInterface;
v1 = v0.<io.smallrye.config.ConfigMappingInterface: java.lang.Class interfaceType>;
return v1;
}
int getSuperTypeCount()
{
int v2;
io.smallrye.config.ConfigMappingInterface v0;
io.smallrye.config.ConfigMappingInterface[] v1;
v0 := @this: io.smallrye.config.ConfigMappingInterface;
v1 = v0.<io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface[] superTypes>;
v2 = lengthof v1;
return v2;
}
io.smallrye.config.ConfigMappingInterface[] getSuperTypes()
{
io.smallrye.config.ConfigMappingInterface v0;
io.smallrye.config.ConfigMappingInterface[] v1;
v0 := @this: io.smallrye.config.ConfigMappingInterface;
v1 = v0.<io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface[] superTypes>;
return v1;
}
io.smallrye.config.ConfigMappingInterface getSuperType(int) throws java.lang.IndexOutOfBoundsException
{
java.lang.IndexOutOfBoundsException v4;
int v1, v3;
io.smallrye.config.ConfigMappingInterface v0, v6;
io.smallrye.config.ConfigMappingInterface[] v2, v5;
v0 := @this: io.smallrye.config.ConfigMappingInterface;
v1 := @parameter0: int;
if v1 < 0 goto label1;
v2 = v0.<io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface[] superTypes>;
v3 = lengthof v2;
if v1 < v3 goto label2;
label1:
v4 = new java.lang.IndexOutOfBoundsException;
specialinvoke v4.<java.lang.IndexOutOfBoundsException: void <init>()>();
throw v4;
label2:
v5 = v0.<io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface[] superTypes>;
v6 = v5[v1];
return v6;
}
public io.smallrye.config.ConfigMappingInterface$Property[] getProperties()
{
io.smallrye.config.ConfigMappingInterface v0;
io.smallrye.config.ConfigMappingInterface$Property[] v1;
v0 := @this: io.smallrye.config.ConfigMappingInterface;
v1 = v0.<io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$Property[] properties>;
return v1;
}
int getPropertyCount()
{
int v2;
io.smallrye.config.ConfigMappingInterface v0;
io.smallrye.config.ConfigMappingInterface$Property[] v1;
v0 := @this: io.smallrye.config.ConfigMappingInterface;
v1 = v0.<io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$Property[] properties>;
v2 = lengthof v1;
return v2;
}
io.smallrye.config.ConfigMappingInterface$Property getProperty(int) throws java.lang.IndexOutOfBoundsException
{
java.lang.IndexOutOfBoundsException v4;
io.smallrye.config.ConfigMappingInterface$Property v6;
io.smallrye.config.ConfigMappingInterface$Property[] v2, v5;
int v1, v3;
io.smallrye.config.ConfigMappingInterface v0;
v0 := @this: io.smallrye.config.ConfigMappingInterface;
v1 := @parameter0: int;
if v1 < 0 goto label1;
v2 = v0.<io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$Property[] properties>;
v3 = lengthof v2;
if v1 < v3 goto label2;
label1:
v4 = new java.lang.IndexOutOfBoundsException;
specialinvoke v4.<java.lang.IndexOutOfBoundsException: void <init>()>();
throw v4;
label2:
v5 = v0.<io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$Property[] properties>;
v6 = v5[v1];
return v6;
}
io.smallrye.config.ConfigMappingInterface$Property getProperty(java.lang.String)
{
java.util.Map v2;
io.smallrye.config.ConfigMappingInterface v0;
java.lang.Object v3;
java.lang.String v1;
v0 := @this: io.smallrye.config.ConfigMappingInterface;
v1 := @parameter0: java.lang.String;
v2 = v0.<io.smallrye.config.ConfigMappingInterface: java.util.Map propertiesByName>;
v3 = interfaceinvoke v2.<java.util.Map: java.lang.Object get(java.lang.Object)>(v1);
return v3;
}
public io.smallrye.config.ConfigMappingInterface$NamingStrategy getNamingStrategy()
{
io.smallrye.config.ConfigMappingInterface v0;
io.smallrye.config.ConfigMappingInterface$NamingStrategy v1;
v0 := @this: io.smallrye.config.ConfigMappingInterface;
v1 = v0.<io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$NamingStrategy namingStrategy>;
return v1;
}
io.smallrye.config.ConfigMappingInterface$ToStringMethod getToStringMethod()
{
io.smallrye.config.ConfigMappingInterface v0;
io.smallrye.config.ConfigMappingInterface$ToStringMethod v1;
v0 := @this: io.smallrye.config.ConfigMappingInterface;
v1 = v0.<io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$ToStringMethod toStringMethod>;
return v1;
}
public java.lang.String getClassName()
{
io.smallrye.config.ConfigMappingInterface v0;
java.lang.String v1;
v0 := @this: io.smallrye.config.ConfigMappingInterface;
v1 = v0.<io.smallrye.config.ConfigMappingInterface: java.lang.String className>;
return v1;
}
java.lang.String getClassInternalName()
{
io.smallrye.config.ConfigMappingInterface v0;
java.lang.String v1, v2;
v0 := @this: io.smallrye.config.ConfigMappingInterface;
v1 = v0.<io.smallrye.config.ConfigMappingInterface: java.lang.String className>;
v2 = virtualinvoke v1.<java.lang.String: java.lang.String replace(char,char)>(46, 47);
return v2;
}
java.util.List getNested()
{
io.smallrye.config.ConfigMappingInterface v0;
io.smallrye.config.ConfigMappingInterface$Property[] v2;
java.util.ArrayList v1;
v0 := @this: io.smallrye.config.ConfigMappingInterface;
v1 = new java.util.ArrayList;
specialinvoke v1.<java.util.ArrayList: void <init>()>();
v2 = v0.<io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$Property[] properties>;
staticinvoke <io.smallrye.config.ConfigMappingInterface: void getNested(io.smallrye.config.ConfigMappingInterface$Property[],java.util.List)>(v2, v1);
return v1;
}
public byte[] getClassBytes()
{
byte[] v1;
io.smallrye.config.ConfigMappingInterface v0;
v0 := @this: io.smallrye.config.ConfigMappingInterface;
v1 = staticinvoke <io.smallrye.config.ConfigMappingGenerator: byte[] generate(io.smallrye.config.ConfigMappingInterface)>(v0);
return v1;
}
private static io.smallrye.config.ConfigMappingInterface createConfigurationInterface(java.lang.Class)
{
io.smallrye.config.ConfigMappingInterface$Property[] v9;
io.smallrye.config.ConfigMappingInterface v10;
java.lang.Class[] v6;
java.lang.reflect.Method[] v8;
java.lang.reflect.TypeVariable[] v2;
int v3;
io.smallrye.config.ConfigMappingInterface[] v7;
java.lang.Class v0;
java.lang.String v4;
boolean v1, v5;
v0 := @parameter0: java.lang.Class;
v1 = virtualinvoke v0.<java.lang.Class: boolean isInterface()>();
if v1 == 0 goto label1;
v2 = virtualinvoke v0.<java.lang.Class: java.lang.reflect.TypeVariable[] getTypeParameters()>();
v3 = lengthof v2;
if v3 == 0 goto label2;
label1:
return null;
label2:
v4 = virtualinvoke v0.<java.lang.Class: java.lang.String getName()>();
v5 = virtualinvoke v4.<java.lang.String: boolean startsWith(java.lang.String)>("java");
if v5 == 0 goto label3;
return null;
label3:
v6 = virtualinvoke v0.<java.lang.Class: java.lang.Class[] getInterfaces()>();
v7 = staticinvoke <io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface[] getSuperTypes(java.lang.Class[],int,int)>(v6, 0, 0);
v8 = virtualinvoke v0.<java.lang.Class: java.lang.reflect.Method[] getDeclaredMethods()>();
v9 = staticinvoke <io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$Property[] getProperties(java.lang.reflect.Method[],int,int)>(v8, 0, 0);
v10 = new io.smallrye.config.ConfigMappingInterface;
specialinvoke v10.<io.smallrye.config.ConfigMappingInterface: void <init>(java.lang.Class,io.smallrye.config.ConfigMappingInterface[],io.smallrye.config.ConfigMappingInterface$Property[])>(v0, v7, v9);
return v10;
}
private static io.smallrye.config.ConfigMappingInterface[] getSuperTypes(java.lang.Class[], int, int)
{
io.smallrye.config.ConfigMappingInterface v7;
java.lang.Class[] v0;
int v1, v11, v2, v3, v8, v9;
io.smallrye.config.ConfigMappingInterface[] v10, v12, v4, v5;
java.lang.Class v6;
v0 := @parameter0: java.lang.Class[];
v1 := @parameter1: int;
v2 := @parameter2: int;
v3 = lengthof v0;
if v1 != v3 goto label2;
if v2 != 0 goto label1;
v4 = <io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface[] NO_TYPES>;
return v4;
label1:
v5 = newarray (io.smallrye.config.ConfigMappingInterface)[v2];
return v5;
label2:
v6 = v0[v1];
v7 = staticinvoke <io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface getConfigurationInterface(java.lang.Class)>(v6);
if v7 == null goto label3;
v8 = v1 + 1;
v9 = v2 + 1;
v10 = staticinvoke <io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface[] getSuperTypes(java.lang.Class[],int,int)>(v0, v8, v9);
v10[v2] = v7;
return v10;
label3:
v11 = v1 + 1;
v12 = staticinvoke <io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface[] getSuperTypes(java.lang.Class[],int,int)>(v0, v11, v2);
return v12;
}
static io.smallrye.config.ConfigMappingInterface$Property[] getProperties(java.lang.reflect.Method[], int, int)
{
io.smallrye.config.ConfigMappingInterface$Property v19;
java.lang.reflect.Method[] v0;
int v1, v11, v13, v2, v20, v21, v3, v7;
java.lang.reflect.Method v6;
boolean v10, v8, v9;
io.smallrye.config.ConfigMappingInterface$Property[] v12, v22, v4, v5;
java.lang.reflect.AnnotatedType v18;
java.lang.IllegalArgumentException v14, v17;
java.lang.Class v15, v16;
v0 := @parameter0: java.lang.reflect.Method[];
v1 := @parameter1: int;
v2 := @parameter2: int;
v3 = lengthof v0;
if v1 != v3 goto label2;
if v2 != 0 goto label1;
v4 = <io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$Property[] NO_PROPERTIES>;
return v4;
label1:
v5 = newarray (io.smallrye.config.ConfigMappingInterface$Property)[v2];
return v5;
label2:
v6 = v0[v1];
v7 = virtualinvoke v6.<java.lang.reflect.Method: int getModifiers()>();
v8 = staticinvoke <java.lang.reflect.Modifier: boolean isPublic(int)>(v7);
if v8 == 0 goto label3;
v9 = staticinvoke <java.lang.reflect.Modifier: boolean isStatic(int)>(v7);
if v9 != 0 goto label3;
v10 = staticinvoke <java.lang.reflect.Modifier: boolean isAbstract(int)>(v7);
if v10 != 0 goto label4;
label3:
v11 = v1 + 1;
v12 = staticinvoke <io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$Property[] getProperties(java.lang.reflect.Method[],int,int)>(v0, v11, v2);
return v12;
label4:
v13 = virtualinvoke v6.<java.lang.reflect.Method: int getParameterCount()>();
if v13 <= 0 goto label5;
v14 = new java.lang.IllegalArgumentException;
specialinvoke v14.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>("Configuration methods cannot accept parameters");
throw v14;
label5:
v15 = virtualinvoke v6.<java.lang.reflect.Method: java.lang.Class getReturnType()>();
v16 = <java.lang.Void: java.lang.Class TYPE>;
if v15 != v16 goto label6;
v17 = new java.lang.IllegalArgumentException;
specialinvoke v17.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>("Void config methods are not allowed");
throw v17;
label6:
v18 = virtualinvoke v6.<java.lang.reflect.Method: java.lang.reflect.AnnotatedType getAnnotatedReturnType()>();
v19 = staticinvoke <io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$Property getPropertyDef(java.lang.reflect.Method,java.lang.reflect.AnnotatedType)>(v6, v18);
v20 = v1 + 1;
v21 = v2 + 1;
v22 = staticinvoke <io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$Property[] getProperties(java.lang.reflect.Method[],int,int)>(v0, v20, v21);
v22[v2] = v19;
return v22;
}
private static io.smallrye.config.ConfigMappingInterface$Property getPropertyDef(java.lang.reflect.Method, java.lang.reflect.AnnotatedType)
{
io.smallrye.config.ConfigMappingInterface$DefaultMethodProperty v5;
io.smallrye.config.ConfigMappingInterface$MayBeOptionalProperty v19;
java.lang.reflect.Method v0, v4;
boolean v11, v17, v2;
io.smallrye.config.ConfigMappingInterface$GroupProperty v37, v44;
io.smallrye.config.ConfigMappingInterface$LeafProperty v40, v51, v53, v55;
java.lang.reflect.AnnotatedType v1, v15, v22, v24, v28;
io.smallrye.config.ConfigMappingInterface$OptionalProperty v18, v52;
java.lang.reflect.Type v26, v29, v33, v41, v48, v49, v54, v56, v9;
java.lang.'annotation'.Annotation v12, v38, v45;
io.smallrye.config.ConfigMappingInterface$PrimitiveProperty v13;
io.smallrye.config.ConfigMappingInterface$Property v16, v27, v32, v6;
io.smallrye.config.ConfigMappingInterface v35, v43;
java.lang.String v14, v21, v42, v46, v47, v8;
io.smallrye.config.ConfigMappingInterface$CollectionProperty v31, v36, v39, v50;
io.smallrye.config.ConfigMappingInterface$MapProperty v25;
java.lang.IllegalArgumentException v20;
io.smallrye.config.ConfigMappingInterface$ToStringMethod v3;
java.lang.Class v10, v23, v30, v34, v7;
v0 := @parameter0: java.lang.reflect.Method;
v1 := @parameter1: java.lang.reflect.AnnotatedType;
v2 = staticinvoke <io.smallrye.config.ConfigMappingInterface: boolean isToStringMethod(java.lang.reflect.Method)>(v0);
if v2 == 0 goto label01;
v3 = new io.smallrye.config.ConfigMappingInterface$ToStringMethod;
specialinvoke v3.<io.smallrye.config.ConfigMappingInterface$ToStringMethod: void <init>(java.lang.reflect.Method)>(v0);
return v3;
label01:
v4 = staticinvoke <io.smallrye.config.ConfigMappingInterface: java.lang.reflect.Method hasDefaultMethodImplementation(java.lang.reflect.Method)>(v0);
if v4 == null goto label02;
v5 = new io.smallrye.config.ConfigMappingInterface$DefaultMethodProperty;
v6 = staticinvoke <io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$Property getPropertyDef(java.lang.reflect.Method,java.lang.reflect.AnnotatedType)>(v4, v1);
specialinvoke v5.<io.smallrye.config.ConfigMappingInterface$DefaultMethodProperty: void <init>(java.lang.reflect.Method,java.lang.reflect.Method,io.smallrye.config.ConfigMappingInterface$Property)>(v0, v4, v6);
return v5;
label02:
v7 = staticinvoke <io.smallrye.config.ConfigMappingInterface: java.lang.Class getConvertWith(java.lang.reflect.AnnotatedType,java.lang.reflect.Method)>(v1, v0);
v8 = staticinvoke <io.smallrye.config.ConfigMappingInterface: java.lang.String getPropertyName(java.lang.reflect.AnnotatedElement)>(v0);
v9 = interfaceinvoke v1.<java.lang.reflect.AnnotatedType: java.lang.reflect.Type getType()>();
v10 = staticinvoke <io.smallrye.config.ConfigMappingInterface: java.lang.Class rawTypeOf(java.lang.reflect.Type)>(v9);
v11 = virtualinvoke v10.<java.lang.Class: boolean isPrimitive()>();
if v11 == 0 goto label05;
v12 = virtualinvoke v0.<java.lang.reflect.Method: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Lio/smallrye/config/WithDefault;");
v13 = new io.smallrye.config.ConfigMappingInterface$PrimitiveProperty;
if v12 != null goto label03;
v14 = null;
goto label04;
label03:
v14 = interfaceinvoke v12.<io.smallrye.config.WithDefault: java.lang.String value()>();
label04:
specialinvoke v13.<io.smallrye.config.ConfigMappingInterface$PrimitiveProperty: void <init>(java.lang.reflect.Method,java.lang.String,java.lang.Class,java.lang.Class,java.lang.String)>(v0, v8, v10, v7, v14);
return v13;
label05:
if v7 != null goto label15;
if v10 != class "Ljava/util/Optional;" goto label07;
v15 = staticinvoke <io.smallrye.config.ConfigMappingInterface: java.lang.reflect.AnnotatedType typeOfParameter(java.lang.reflect.AnnotatedType,int)>(v1, 0);
v16 = staticinvoke <io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$Property getPropertyDef(java.lang.reflect.Method,java.lang.reflect.AnnotatedType)>(v0, v15);
v17 = virtualinvoke v16.<io.smallrye.config.ConfigMappingInterface$Property: boolean isMayBeOptional()>();
if v17 == 0 goto label06;
v18 = new io.smallrye.config.ConfigMappingInterface$OptionalProperty;
v19 = virtualinvoke v16.<io.smallrye.config.ConfigMappingInterface$Property: io.smallrye.config.ConfigMappingInterface$MayBeOptionalProperty asMayBeOptional()>();
specialinvoke v18.<io.smallrye.config.ConfigMappingInterface$OptionalProperty: void <init>(java.lang.reflect.Method,java.lang.String,io.smallrye.config.ConfigMappingInterface$MayBeOptionalProperty)>(v0, v8, v19);
return v18;
label06:
v20 = new java.lang.IllegalArgumentException;
v21 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.reflect.AnnotatedType)>(v1) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Property type \u0001 cannot be optional");
specialinvoke v20.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(v21);
throw v20;
label07:
if v10 != class "Ljava/util/Map;" goto label08;
v22 = staticinvoke <io.smallrye.config.ConfigMappingInterface: java.lang.reflect.AnnotatedType typeOfParameter(java.lang.reflect.AnnotatedType,int)>(v1, 0);
v23 = staticinvoke <io.smallrye.config.ConfigMappingInterface: java.lang.Class getConvertWith(java.lang.reflect.AnnotatedType,java.lang.reflect.Method)>(v22, v0);
v24 = staticinvoke <io.smallrye.config.ConfigMappingInterface: java.lang.reflect.AnnotatedType typeOfParameter(java.lang.reflect.AnnotatedType,int)>(v1, 1);
v25 = new io.smallrye.config.ConfigMappingInterface$MapProperty;
v26 = interfaceinvoke v22.<java.lang.reflect.AnnotatedType: java.lang.reflect.Type getType()>();
v27 = staticinvoke <io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$Property getPropertyDef(java.lang.reflect.Method,java.lang.reflect.AnnotatedType)>(v0, v24);
specialinvoke v25.<io.smallrye.config.ConfigMappingInterface$MapProperty: void <init>(java.lang.reflect.Method,java.lang.String,java.lang.reflect.Type,java.lang.Class,io.smallrye.config.ConfigMappingInterface$Property)>(v0, v8, v26, v23, v27);
return v25;
label08:
if v10 == class "Ljava/util/List;" goto label09;
if v10 != class "Ljava/util/Set;" goto label14;
label09:
v28 = staticinvoke <io.smallrye.config.ConfigMappingInterface: java.lang.reflect.AnnotatedType typeOfParameter(java.lang.reflect.AnnotatedType,int)>(v1, 0);
v29 = interfaceinvoke v28.<java.lang.reflect.AnnotatedType: java.lang.reflect.Type getType()>();
v30 = staticinvoke <io.smallrye.config.ConfigMappingInterface: java.lang.Class rawTypeOf(java.lang.reflect.Type)>(v29);
if v30 != class "Ljava/util/Map;" goto label10;
v31 = new io.smallrye.config.ConfigMappingInterface$CollectionProperty;
v32 = staticinvoke <io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$Property getPropertyDef(java.lang.reflect.Method,java.lang.reflect.AnnotatedType)>(v0, v28);
specialinvoke v31.<io.smallrye.config.ConfigMappingInterface$CollectionProperty: void <init>(java.lang.Class,io.smallrye.config.ConfigMappingInterface$Property)>(v10, v32);
return v31;
label10:
v33 = interfaceinvoke v28.<java.lang.reflect.AnnotatedType: java.lang.reflect.Type getType()>();
v34 = staticinvoke <io.smallrye.config.ConfigMappingInterface: java.lang.Class rawTypeOf(java.lang.reflect.Type)>(v33);
v35 = staticinvoke <io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface getConfigurationInterface(java.lang.Class)>(v34);
if v35 == null goto label11;
v36 = new io.smallrye.config.ConfigMappingInterface$CollectionProperty;
v37 = new io.smallrye.config.ConfigMappingInterface$GroupProperty;
specialinvoke v37.<io.smallrye.config.ConfigMappingInterface$GroupProperty: void <init>(java.lang.reflect.Method,java.lang.String,io.smallrye.config.ConfigMappingInterface)>(v0, v8, v35);
specialinvoke v36.<io.smallrye.config.ConfigMappingInterface$CollectionProperty: void <init>(java.lang.Class,io.smallrye.config.ConfigMappingInterface$Property)>(v10, v37);
return v36;
label11:
v38 = virtualinvoke v0.<java.lang.reflect.Method: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Lio/smallrye/config/WithDefault;");
v39 = new io.smallrye.config.ConfigMappingInterface$CollectionProperty;
v40 = new io.smallrye.config.ConfigMappingInterface$LeafProperty;
v41 = interfaceinvoke v28.<java.lang.reflect.AnnotatedType: java.lang.reflect.Type getType()>();
if v38 != null goto label12;
v42 = null;
goto label13;
label12:
v42 = interfaceinvoke v38.<io.smallrye.config.WithDefault: java.lang.String value()>();
label13:
specialinvoke v40.<io.smallrye.config.ConfigMappingInterface$LeafProperty: void <init>(java.lang.reflect.Method,java.lang.String,java.lang.reflect.Type,java.lang.Class,java.lang.String)>(v0, v8, v41, null, v42);
specialinvoke v39.<io.smallrye.config.ConfigMappingInterface$CollectionProperty: void <init>(java.lang.Class,io.smallrye.config.ConfigMappingInterface$Property)>(v10, v40);
return v39;
label14:
v43 = staticinvoke <io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface getConfigurationInterface(java.lang.Class)>(v10);
if v43 == null goto label15;
v44 = new io.smallrye.config.ConfigMappingInterface$GroupProperty;
specialinvoke v44.<io.smallrye.config.ConfigMappingInterface$GroupProperty: void <init>(java.lang.reflect.Method,java.lang.String,io.smallrye.config.ConfigMappingInterface)>(v0, v8, v43);
return v44;
label15:
v45 = virtualinvoke v0.<java.lang.reflect.Method: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Lio/smallrye/config/WithDefault;");
if v45 != null goto label16;
v46 = null;
goto label17;
label16:
v46 = interfaceinvoke v45.<io.smallrye.config.WithDefault: java.lang.String value()>();
label17:
v47 = v46;
if v10 == class "Ljava/util/List;" goto label18;
if v10 != class "Ljava/util/Set;" goto label19;
label18:
v48 = interfaceinvoke v1.<java.lang.reflect.AnnotatedType: java.lang.reflect.Type getType()>();
v49 = staticinvoke <io.smallrye.config.ConfigMappingInterface: java.lang.reflect.Type typeOfParameter(java.lang.reflect.Type,int)>(v48, 0);
v50 = new io.smallrye.config.ConfigMappingInterface$CollectionProperty;
v51 = new io.smallrye.config.ConfigMappingInterface$LeafProperty;
specialinvoke v51.<io.smallrye.config.ConfigMappingInterface$LeafProperty: void <init>(java.lang.reflect.Method,java.lang.String,java.lang.reflect.Type,java.lang.Class,java.lang.String)>(v0, v8, v49, v7, v47);
specialinvoke v50.<io.smallrye.config.ConfigMappingInterface$CollectionProperty: void <init>(java.lang.Class,io.smallrye.config.ConfigMappingInterface$Property)>(v10, v51);
return v50;
label19:
if v10 != class "Ljava/util/Optional;" goto label20;
v52 = new io.smallrye.config.ConfigMappingInterface$OptionalProperty;
v53 = new io.smallrye.config.ConfigMappingInterface$LeafProperty;
v54 = interfaceinvoke v1.<java.lang.reflect.AnnotatedType: java.lang.reflect.Type getType()>();
specialinvoke v53.<io.smallrye.config.ConfigMappingInterface$LeafProperty: void <init>(java.lang.reflect.Method,java.lang.String,java.lang.reflect.Type,java.lang.Class,java.lang.String)>(v0, v8, v54, v7, v46);
specialinvoke v52.<io.smallrye.config.ConfigMappingInterface$OptionalProperty: void <init>(java.lang.reflect.Method,java.lang.String,io.smallrye.config.ConfigMappingInterface$MayBeOptionalProperty)>(v0, v8, v53);
return v52;
label20:
v55 = new io.smallrye.config.ConfigMappingInterface$LeafProperty;
v56 = interfaceinvoke v1.<java.lang.reflect.AnnotatedType: java.lang.reflect.Type getType()>();
specialinvoke v55.<io.smallrye.config.ConfigMappingInterface$LeafProperty: void <init>(java.lang.reflect.Method,java.lang.String,java.lang.reflect.Type,java.lang.Class,java.lang.String)>(v0, v8, v56, v7, v46);
return v55;
}
private static boolean isToStringMethod(java.lang.reflect.Method)
{
int v3;
java.lang.Class v4;
java.lang.String v1;
java.lang.reflect.Method v0;
boolean v2, v5, v6, v7;
v0 := @parameter0: java.lang.reflect.Method;
v1 = virtualinvoke v0.<java.lang.reflect.Method: java.lang.String getName()>();
v2 = virtualinvoke v1.<java.lang.String: boolean equals(java.lang.Object)>("toString");
if v2 == 0 goto label1;
v3 = virtualinvoke v0.<java.lang.reflect.Method: int getParameterCount()>();
if v3 != 0 goto label1;
v4 = virtualinvoke v0.<java.lang.reflect.Method: java.lang.Class getReturnType()>();
v5 = virtualinvoke v4.<java.lang.Object: boolean equals(java.lang.Object)>(class "Ljava/lang/String;");
if v5 == 0 goto label1;
v6 = virtualinvoke v0.<java.lang.reflect.Method: boolean isDefault()>();
if v6 != 0 goto label1;
v7 = 1;
goto label2;
label1:
v7 = 0;
label2:
return v7;
}
private static java.lang.reflect.Method hasDefaultMethodImplementation(java.lang.reflect.Method)
{
java.lang.NoSuchMethodException v11;
java.lang.Class[] v2, v9;
int v3, v4;
java.lang.Class v1, v12, v13, v5;
java.lang.String v6, v8;
java.lang.reflect.Method v0, v10;
boolean v14, v7;
v0 := @parameter0: java.lang.reflect.Method;
v1 = virtualinvoke v0.<java.lang.reflect.Method: java.lang.Class getDeclaringClass()>();
v2 = virtualinvoke v1.<java.lang.Class: java.lang.Class[] getClasses()>();
v3 = lengthof v2;
v4 = 0;
label1:
if v4 >= v3 goto label7;
v5 = v2[v4];
v6 = virtualinvoke v5.<java.lang.Class: java.lang.String getSimpleName()>();
v7 = virtualinvoke v6.<java.lang.String: boolean equals(java.lang.Object)>("DefaultImpls");
if v7 == 0 goto label6;
label2:
v8 = virtualinvoke v0.<java.lang.reflect.Method: java.lang.String getName()>();
v9 = newarray (java.lang.Class)[1];
v9[0] = v1;
v10 = virtualinvoke v5.<java.lang.Class: java.lang.reflect.Method getMethod(java.lang.String,java.lang.Class[])>(v8, v9);
label3:
goto label5;
label4:
v11 := @caughtexception;
return null;
label5:
v12 = virtualinvoke v10.<java.lang.reflect.Method: java.lang.Class getReturnType()>();
v13 = virtualinvoke v0.<java.lang.reflect.Method: java.lang.Class getReturnType()>();
v14 = virtualinvoke v12.<java.lang.Object: boolean equals(java.lang.Object)>(v13);
if v14 == 0 goto label6;
return v10;
label6:
v4 = v4 + 1;
goto label1;
label7:
return null;
catch java.lang.NoSuchMethodException from label2 to label3 with label4;
}
private static java.lang.Class getConvertWith(java.lang.reflect.AnnotatedType, java.lang.reflect.Method)
{
java.lang.reflect.Type v4;
java.lang.'annotation'.Annotation v2;
java.lang.reflect.AnnotatedType v0;
java.lang.Class v3;
java.lang.reflect.Method v1;
v0 := @parameter0: java.lang.reflect.AnnotatedType;
v1 := @parameter1: java.lang.reflect.Method;
v2 = interfaceinvoke v0.<java.lang.reflect.AnnotatedType: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Lio/smallrye/config/WithConverter;");
if v2 != null goto label1;
virtualinvoke v1.<java.lang.reflect.Method: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Lio/smallrye/config/WithConverter;");
label1:
if v2 == null goto label2;
v3 = interfaceinvoke v2.<io.smallrye.config.WithConverter: java.lang.Class value()>();
v4 = interfaceinvoke v0.<java.lang.reflect.AnnotatedType: java.lang.reflect.Type getType()>();
staticinvoke <io.smallrye.config.ConfigMappingInterface: void validateConverter(java.lang.reflect.Type,java.lang.Class)>(v4, v3);
return v3;
label2:
return null;
}
private static void validateConverter(java.lang.reflect.Type, java.lang.Class)
{
java.lang.NoSuchMethodException v11;
java.lang.Class[] v6;
java.lang.IllegalArgumentException v10;
java.lang.reflect.Type v0;
java.util.Map v4;
java.lang.Class v1, v8;
java.lang.Object v5;
java.lang.reflect.Method v7;
boolean v2, v3, v9;
v0 := @parameter0: java.lang.reflect.Type;
v1 := @parameter1: java.lang.Class;
v2 = v0 instanceof java.lang.Class;
if v2 == 0 goto label5;
label1:
v3 = virtualinvoke v0.<java.lang.Class: boolean isPrimitive()>();
if v3 == 0 goto label2;
v4 = <io.smallrye.config.ConfigMappingInterface$PrimitiveProperty: java.util.Map boxTypes>;
v5 = interfaceinvoke v4.<java.util.Map: java.lang.Object get(java.lang.Object)>(v0);
goto label3;
label2:
v5 = v0;
label3:
v6 = newarray (java.lang.Class)[1];
v6[0] = class "Ljava/lang/String;";
v7 = virtualinvoke v1.<java.lang.Class: java.lang.reflect.Method getMethod(java.lang.String,java.lang.Class[])>("convert", v6);
v8 = virtualinvoke v7.<java.lang.reflect.Method: java.lang.Class getReturnType()>();
v9 = virtualinvoke v5.<java.lang.Class: boolean isAssignableFrom(java.lang.Class)>(v8);
if v9 != 0 goto label5;
v10 = new java.lang.IllegalArgumentException;
specialinvoke v10.<java.lang.IllegalArgumentException: void <init>()>();
throw v10;
label4:
v11 := @caughtexception;
label5:
return;
catch java.lang.NoSuchMethodException from label1 to label4 with label4;
}
private static java.lang.String getPropertyName(java.lang.reflect.AnnotatedElement)
{
java.lang.IllegalArgumentException v4, v7;
java.lang.'annotation'.Annotation v1, v3;
java.lang.String v5;
boolean v2, v6;
java.lang.reflect.AnnotatedElement v0;
v0 := @parameter0: java.lang.reflect.AnnotatedElement;
v1 = interfaceinvoke v0.<java.lang.reflect.AnnotatedElement: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Lio/smallrye/config/WithParentName;");
if v1 == null goto label1;
v2 = 1;
goto label2;
label1:
v2 = 0;
label2:
v3 = interfaceinvoke v0.<java.lang.reflect.AnnotatedElement: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Lio/smallrye/config/WithName;");
if v3 == null goto label5;
if v2 == 0 goto label3;
v4 = new java.lang.IllegalArgumentException;
specialinvoke v4.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>("Cannot specify both @ParentConfigName and @ConfigName");
throw v4;
label3:
v5 = interfaceinvoke v3.<io.smallrye.config.WithName: java.lang.String value()>();
v6 = virtualinvoke v5.<java.lang.String: boolean isEmpty()>();
if v6 != 0 goto label4;
return v5;
label4:
v7 = new java.lang.IllegalArgumentException;
specialinvoke v7.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>("Property name is empty");
throw v7;
label5:
if v2 == 0 goto label6;
return "";
label6:
return null;
}
private static void getNested(io.smallrye.config.ConfigMappingInterface$Property[], java.util.List)
{
io.smallrye.config.ConfigMappingInterface$Property v18, v21, v24, v4;
io.smallrye.config.ConfigMappingInterface v12, v6;
io.smallrye.config.ConfigMappingInterface$MayBeOptionalProperty v11, v14, v16, v9;
int v2, v3;
boolean v10, v15, v19, v22, v5, v8;
io.smallrye.config.ConfigMappingInterface$Property[] v0, v13, v17, v20, v23, v7;
java.util.List v1;
v0 := @parameter0: io.smallrye.config.ConfigMappingInterface$Property[];
v1 := @parameter1: java.util.List;
v2 = lengthof v0;
v3 = 0;
label1:
if v3 >= v2 goto label7;
v4 = v0[v3];
v5 = v4 instanceof io.smallrye.config.ConfigMappingInterface$GroupProperty;
if v5 == 0 goto label2;
v6 = virtualinvoke v4.<io.smallrye.config.ConfigMappingInterface$GroupProperty: io.smallrye.config.ConfigMappingInterface getGroupType()>();
interfaceinvoke v1.<java.util.List: boolean add(java.lang.Object)>(v6);
v7 = v6.<io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$Property[] properties>;
staticinvoke <io.smallrye.config.ConfigMappingInterface: void getNested(io.smallrye.config.ConfigMappingInterface$Property[],java.util.List)>(v7, v1);
label2:
v8 = v4 instanceof io.smallrye.config.ConfigMappingInterface$OptionalProperty;
if v8 == 0 goto label4;
v9 = virtualinvoke v4.<io.smallrye.config.ConfigMappingInterface$OptionalProperty: io.smallrye.config.ConfigMappingInterface$MayBeOptionalProperty getNestedProperty()>();
v10 = v9 instanceof io.smallrye.config.ConfigMappingInterface$GroupProperty;
if v10 == 0 goto label3;
v11 = virtualinvoke v4.<io.smallrye.config.ConfigMappingInterface$OptionalProperty: io.smallrye.config.ConfigMappingInterface$MayBeOptionalProperty getNestedProperty()>();
v12 = virtualinvoke v11.<io.smallrye.config.ConfigMappingInterface$GroupProperty: io.smallrye.config.ConfigMappingInterface getGroupType()>();
interfaceinvoke v1.<java.util.List: boolean add(java.lang.Object)>(v12);
v13 = v12.<io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$Property[] properties>;
staticinvoke <io.smallrye.config.ConfigMappingInterface: void getNested(io.smallrye.config.ConfigMappingInterface$Property[],java.util.List)>(v13, v1);
goto label4;
label3:
v14 = virtualinvoke v4.<io.smallrye.config.ConfigMappingInterface$OptionalProperty: io.smallrye.config.ConfigMappingInterface$MayBeOptionalProperty getNestedProperty()>();
v15 = v14 instanceof io.smallrye.config.ConfigMappingInterface$CollectionProperty;
if v15 == 0 goto label4;
v16 = virtualinvoke v4.<io.smallrye.config.ConfigMappingInterface$OptionalProperty: io.smallrye.config.ConfigMappingInterface$MayBeOptionalProperty getNestedProperty()>();
v17 = newarray (io.smallrye.config.ConfigMappingInterface$Property)[1];
v18 = v16.<io.smallrye.config.ConfigMappingInterface$CollectionProperty: io.smallrye.config.ConfigMappingInterface$Property element>;
v17[0] = v18;
staticinvoke <io.smallrye.config.ConfigMappingInterface: void getNested(io.smallrye.config.ConfigMappingInterface$Property[],java.util.List)>(v17, v1);
label4:
v19 = v4 instanceof io.smallrye.config.ConfigMappingInterface$MapProperty;
if v19 == 0 goto label5;
v20 = newarray (io.smallrye.config.ConfigMappingInterface$Property)[1];
v21 = v4.<io.smallrye.config.ConfigMappingInterface$MapProperty: io.smallrye.config.ConfigMappingInterface$Property valueProperty>;
v20[0] = v21;
staticinvoke <io.smallrye.config.ConfigMappingInterface: void getNested(io.smallrye.config.ConfigMappingInterface$Property[],java.util.List)>(v20, v1);
label5:
v22 = v4 instanceof io.smallrye.config.ConfigMappingInterface$CollectionProperty;
if v22 == 0 goto label6;
v23 = newarray (io.smallrye.config.ConfigMappingInterface$Property)[1];
v24 = v4.<io.smallrye.config.ConfigMappingInterface$CollectionProperty: io.smallrye.config.ConfigMappingInterface$Property element>;
v23[0] = v24;
staticinvoke <io.smallrye.config.ConfigMappingInterface: void getNested(io.smallrye.config.ConfigMappingInterface$Property[],java.util.List)>(v23, v1);
label6:
v3 = v3 + 1;
goto label1;
label7:
return;
}
static java.lang.reflect.AnnotatedType typeOfParameter(java.lang.reflect.AnnotatedType, int)
{
int v1;
java.lang.reflect.AnnotatedType v0, v4;
java.lang.reflect.AnnotatedType[] v3;
boolean v2;
v0 := @parameter0: java.lang.reflect.AnnotatedType;
v1 := @parameter1: int;
v2 = v0 instanceof java.lang.reflect.AnnotatedParameterizedType;
if v2 == 0 goto label1;
v3 = interfaceinvoke v0.<java.lang.reflect.AnnotatedParameterizedType: java.lang.reflect.AnnotatedType[] getAnnotatedActualTypeArguments()>();
v4 = v3[v1];
return v4;
label1:
return v0;
}
static java.lang.reflect.Type typeOfParameter(java.lang.reflect.Type, int)
{
java.lang.reflect.Type v0, v4;
int v1;
java.lang.reflect.Type[] v3;
boolean v2;
v0 := @parameter0: java.lang.reflect.Type;
v1 := @parameter1: int;
v2 = v0 instanceof java.lang.reflect.ParameterizedType;
if v2 == 0 goto label1;
v3 = interfaceinvoke v0.<java.lang.reflect.ParameterizedType: java.lang.reflect.Type[] getActualTypeArguments()>();
v4 = v3[v1];
return v4;
label1:
return v0;
}
static java.lang.Class rawTypeOf(java.lang.reflect.Type)
{
io.smallrye.config.ConfigMessages v14;
boolean v1, v10, v2, v5;
java.lang.IllegalArgumentException v15;
java.lang.reflect.Type v0, v12, v3, v6;
java.lang.reflect.Type[] v11;
java.lang.Class v13, v4, v7, v9;
java.lang.Object v8;
v0 := @parameter0: java.lang.reflect.Type;
v1 = v0 instanceof java.lang.Class;
if v1 == 0 goto label1;
return v0;
label1:
v2 = v0 instanceof java.lang.reflect.ParameterizedType;
if v2 == 0 goto label2;
v3 = interfaceinvoke v0.<java.lang.reflect.ParameterizedType: java.lang.reflect.Type getRawType()>();
v4 = staticinvoke <io.smallrye.config.ConfigMappingInterface: java.lang.Class rawTypeOf(java.lang.reflect.Type)>(v3);
return v4;
label2:
v5 = v0 instanceof java.lang.reflect.GenericArrayType;
if v5 == 0 goto label3;
v6 = interfaceinvoke v0.<java.lang.reflect.GenericArrayType: java.lang.reflect.Type getGenericComponentType()>();
v7 = staticinvoke <io.smallrye.config.ConfigMappingInterface: java.lang.Class rawTypeOf(java.lang.reflect.Type)>(v6);
v8 = staticinvoke <java.lang.reflect.Array: java.lang.Object newInstance(java.lang.Class,int)>(v7, 0);
v9 = virtualinvoke v8.<java.lang.Object: java.lang.Class getClass()>();
return v9;
label3:
v10 = v0 instanceof java.lang.reflect.WildcardType;
if v10 == 0 goto label5;
v11 = interfaceinvoke v0.<java.lang.reflect.WildcardType: java.lang.reflect.Type[] getUpperBounds()>();
if v11 == null goto label4;
v12 = v11[0];
v13 = staticinvoke <io.smallrye.config.ConfigMappingInterface: java.lang.Class rawTypeOf(java.lang.reflect.Type)>(v12);
return v13;
label4:
return class "Ljava/lang/Object;";
label5:
v14 = <io.smallrye.config.ConfigMessages: io.smallrye.config.ConfigMessages msg>;
v15 = interfaceinvoke v14.<io.smallrye.config.ConfigMessages: java.lang.IllegalArgumentException noRawType(java.lang.reflect.Type)>(v0);
throw v15;
}
private static io.smallrye.config.ConfigMappingInterface$NamingStrategy getNamingStrategy(java.lang.Class)
{
io.smallrye.config.ConfigMapping$NamingStrategy v3;
io.smallrye.config.ConfigMappingInterface$NamingStrategy v6, v7, v8, v9;
int[] v2;
int v4, v5;
java.lang.'annotation'.Annotation v1;
java.lang.Class v0;
v0 := @parameter0: java.lang.Class;
v1 = virtualinvoke v0.<java.lang.Class: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Lio/smallrye/config/ConfigMapping;");
if v1 == null goto label4;
v2 = <io.smallrye.config.ConfigMappingInterface$2: int[] $SwitchMap$io$smallrye$config$ConfigMapping$NamingStrategy>;
v3 = interfaceinvoke v1.<io.smallrye.config.ConfigMapping: io.smallrye.config.ConfigMapping$NamingStrategy namingStrategy()>();
v4 = virtualinvoke v3.<io.smallrye.config.ConfigMapping$NamingStrategy: int ordinal()>();
v5 = v2[v4];
tableswitch(v5)
{
case 1: goto label1;
case 2: goto label2;
case 3: goto label3;
default: goto label4;
};
label1:
v6 = <io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$NamingStrategy VERBATIM_NAMING_STRATEGY>;
return v6;
label2:
v7 = <io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$NamingStrategy KEBAB_CASE_NAMING_STRATEGY>;
return v7;
label3:
v8 = <io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$NamingStrategy SNAKE_CASE_NAMING_STRATEGY>;
return v8;
label4:
v9 = <io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$NamingStrategy DEFAULT_NAMING_STRATEGY>;
return v9;
}
static void <clinit>()
{
io.smallrye.config.ConfigMappingInterface$VerbatimNamingStrategy v4;
io.smallrye.config.ConfigMappingInterface$KebabNamingStrategy v3, v5;
io.smallrye.config.ConfigMappingInterface$Property[] v1;
io.smallrye.config.ConfigMappingInterface$SnakeNamingStrategy v6;
io.smallrye.config.ConfigMappingInterface[] v0;
io.smallrye.config.ConfigMappingInterface$1 v2;
v0 = newarray (io.smallrye.config.ConfigMappingInterface)[0];
<io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface[] NO_TYPES> = v0;
v1 = newarray (io.smallrye.config.ConfigMappingInterface$Property)[0];
<io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$Property[] NO_PROPERTIES> = v1;
v2 = new io.smallrye.config.ConfigMappingInterface$1;
specialinvoke v2.<io.smallrye.config.ConfigMappingInterface$1: void <init>()>();
<io.smallrye.config.ConfigMappingInterface: java.lang.ClassValue cv> = v2;
v3 = new io.smallrye.config.ConfigMappingInterface$KebabNamingStrategy;
specialinvoke v3.<io.smallrye.config.ConfigMappingInterface$KebabNamingStrategy: void <init>()>();
<io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$NamingStrategy DEFAULT_NAMING_STRATEGY> = v3;
v4 = new io.smallrye.config.ConfigMappingInterface$VerbatimNamingStrategy;
specialinvoke v4.<io.smallrye.config.ConfigMappingInterface$VerbatimNamingStrategy: void <init>()>();
<io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$NamingStrategy VERBATIM_NAMING_STRATEGY> = v4;
v5 = new io.smallrye.config.ConfigMappingInterface$KebabNamingStrategy;
specialinvoke v5.<io.smallrye.config.ConfigMappingInterface$KebabNamingStrategy: void <init>()>();
<io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$NamingStrategy KEBAB_CASE_NAMING_STRATEGY> = v5;
v6 = new io.smallrye.config.ConfigMappingInterface$SnakeNamingStrategy;
specialinvoke v6.<io.smallrye.config.ConfigMappingInterface$SnakeNamingStrategy: void <init>()>();
<io.smallrye.config.ConfigMappingInterface: io.smallrye.config.ConfigMappingInterface$NamingStrategy SNAKE_CASE_NAMING_STRATEGY> = v6;
return;
}
}