public final class io.vertx.ext.auth.impl.jose.JWK extends java.lang.Object
{
private static final io.vertx.core.impl.logging.Logger LOG;
private static final java.util.Map ALG_ALIAS;
private final java.lang.String kid;
private final java.lang.String alg;
private final java.lang.String kty;
private final java.lang.String use;
private final java.lang.String label;
private java.security.PrivateKey privateKey;
private java.security.PublicKey publicKey;
private javax.crypto.Mac mac;
private static boolean validAlgAlias(java.lang.String, java.lang.String)
{
java.util.Iterator v4;
java.util.Map v2;
java.lang.Object v3, v6;
java.lang.String v0, v1;
boolean v5, v7;
v0 := @parameter0: java.lang.String;
v1 := @parameter1: java.lang.String;
v2 = <io.vertx.ext.auth.impl.jose.JWK: java.util.Map ALG_ALIAS>;
v3 = interfaceinvoke v2.<java.util.Map: java.lang.Object get(java.lang.Object)>(v1);
v4 = interfaceinvoke v3.<java.util.List: java.util.Iterator iterator()>();
label1:
v5 = interfaceinvoke v4.<java.util.Iterator: boolean hasNext()>();
if v5 == 0 goto label2;
v6 = interfaceinvoke v4.<java.util.Iterator: java.lang.Object next()>();
v7 = virtualinvoke v0.<java.lang.String: boolean equalsIgnoreCase(java.lang.String)>(v6);
if v7 == 0 goto label1;
return 1;
label2:
return 0;
}
public static java.util.List load(java.security.KeyStore, java.lang.String, java.util.Map)
{
io.vertx.ext.auth.impl.jose.JWK v17, v34;
java.security.GeneralSecurityException v18;
java.util.Map v2;
boolean v13, v24, v28, v7;
io.vertx.core.impl.logging.Logger v14, v19, v29, v36;
javax.crypto.Mac v16;
java.security.KeyStore v0;
java.lang.Exception v35;
java.security.Key v11, v33;
java.util.List v22, v5;
java.security.cert.Certificate v26;
java.lang.String[] v21, v4;
java.util.ArrayList v3;
java.lang.String v1, v12, v15, v20, v27, v30, v37;
java.util.Iterator v23, v6;
char[] v31, v9;
java.lang.Object v10, v25, v32, v8;
v0 := @parameter0: java.security.KeyStore;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.util.Map;
v3 = new java.util.ArrayList;
specialinvoke v3.<java.util.ArrayList: void <init>()>();
v4 = newarray (java.lang.String)[3];
v4[0] = "HS256";
v4[1] = "HS384";
v4[2] = "HS512";
v5 = staticinvoke <java.util.Arrays: java.util.List asList(java.lang.Object[])>(v4);
v6 = interfaceinvoke v5.<java.util.List: java.util.Iterator iterator()>();
label01:
v7 = interfaceinvoke v6.<java.util.Iterator: boolean hasNext()>();
if v7 == 0 goto label10;
v8 = interfaceinvoke v6.<java.util.Iterator: java.lang.Object next()>();
label02:
if v2 != null goto label03;
v9 = virtualinvoke v1.<java.lang.String: char[] toCharArray()>();
goto label04;
label03:
v10 = interfaceinvoke v2.<java.util.Map: java.lang.Object get(java.lang.Object)>(v8);
v9 = virtualinvoke v10.<java.lang.String: char[] toCharArray()>();
label04:
v11 = virtualinvoke v0.<java.security.KeyStore: java.security.Key getKey(java.lang.String,char[])>(v8, v9);
if v11 == null goto label01;
label05:
v12 = interfaceinvoke v11.<java.security.Key: java.lang.String getAlgorithm()>();
v13 = staticinvoke <io.vertx.ext.auth.impl.jose.JWK: boolean validAlgAlias(java.lang.String,java.lang.String)>(v12, v8);
if v13 != 0 goto label07;
v14 = <io.vertx.ext.auth.impl.jose.JWK: io.vertx.core.impl.logging.Logger LOG>;
v15 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v8, v12) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The key algorithm does not match: {\u0001: \u0001}");
interfaceinvoke v14.<io.vertx.core.impl.logging.Logger: void warn(java.lang.Object)>(v15);
label06:
goto label01;
label07:
v16 = staticinvoke <javax.crypto.Mac: javax.crypto.Mac getInstance(java.lang.String)>(v12);
virtualinvoke v16.<javax.crypto.Mac: void init(java.security.Key)>(v11);
v17 = new io.vertx.ext.auth.impl.jose.JWK;
specialinvoke v17.<io.vertx.ext.auth.impl.jose.JWK: void <init>(java.lang.String,javax.crypto.Mac)>(v8, v16);
interfaceinvoke v3.<java.util.List: boolean add(java.lang.Object)>(v17);
label08:
goto label01;
label09:
v18 := @caughtexception;
v19 = <io.vertx.ext.auth.impl.jose.JWK: io.vertx.core.impl.logging.Logger LOG>;
v20 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v8) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Failed to load key for algorithm: \u0001");
interfaceinvoke v19.<io.vertx.core.impl.logging.Logger: void warn(java.lang.Object,java.lang.Throwable)>(v20, v18);
goto label01;
label10:
v21 = newarray (java.lang.String)[7];
v21[0] = "RS256";
v21[1] = "RS384";
v21[2] = "RS512";
v21[3] = "ES256K";
v21[4] = "ES256";
v21[5] = "ES384";
v21[6] = "ES512";
v22 = staticinvoke <java.util.Arrays: java.util.List asList(java.lang.Object[])>(v21);
v23 = interfaceinvoke v22.<java.util.List: java.util.Iterator iterator()>();
label11:
v24 = interfaceinvoke v23.<java.util.Iterator: boolean hasNext()>();
if v24 == 0 goto label20;
v25 = interfaceinvoke v23.<java.util.Iterator: java.lang.Object next()>();
label12:
v26 = virtualinvoke v0.<java.security.KeyStore: java.security.cert.Certificate getCertificate(java.lang.String)>(v25);
if v26 == null goto label11;
label13:
virtualinvoke v26.<java.security.cert.X509Certificate: void checkValidity()>();
v27 = virtualinvoke v26.<java.security.cert.X509Certificate: java.lang.String getSigAlgName()>();
v28 = staticinvoke <io.vertx.ext.auth.impl.jose.JWK: boolean validAlgAlias(java.lang.String,java.lang.String)>(v27, v25);
if v28 != 0 goto label15;
v29 = <io.vertx.ext.auth.impl.jose.JWK: io.vertx.core.impl.logging.Logger LOG>;
v30 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v25, v27) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The key algorithm does not match: {\u0001: \u0001}");
interfaceinvoke v29.<io.vertx.core.impl.logging.Logger: void warn(java.lang.Object)>(v30);
label14:
goto label11;
label15:
if v2 != null goto label16;
v31 = virtualinvoke v1.<java.lang.String: char[] toCharArray()>();
goto label17;
label16:
v32 = interfaceinvoke v2.<java.util.Map: java.lang.Object get(java.lang.Object)>(v25);
v31 = virtualinvoke v32.<java.lang.String: char[] toCharArray()>();
label17:
v33 = virtualinvoke v0.<java.security.KeyStore: java.security.Key getKey(java.lang.String,char[])>(v25, v31);
v34 = new io.vertx.ext.auth.impl.jose.JWK;
specialinvoke v34.<io.vertx.ext.auth.impl.jose.JWK: void <init>(java.lang.String,java.security.cert.X509Certificate,java.security.PrivateKey)>(v25, v26, v33);
interfaceinvoke v3.<java.util.List: boolean add(java.lang.Object)>(v34);
label18:
goto label11;
label19:
v35 := @caughtexception;
v36 = <io.vertx.ext.auth.impl.jose.JWK: io.vertx.core.impl.logging.Logger LOG>;
v37 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v25) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Failed to load key for algorithm: \u0001");
interfaceinvoke v36.<io.vertx.core.impl.logging.Logger: void warn(java.lang.Object,java.lang.Throwable)>(v37, v35);
goto label11;
label20:
return v3;
catch java.security.KeyStoreException from label02 to label05 with label09;
catch java.security.NoSuchAlgorithmException from label02 to label05 with label09;
catch java.security.UnrecoverableKeyException from label02 to label05 with label09;
catch java.security.InvalidKeyException from label02 to label05 with label09;
catch java.security.KeyStoreException from label05 to label06 with label09;
catch java.security.NoSuchAlgorithmException from label05 to label06 with label09;
catch java.security.UnrecoverableKeyException from label05 to label06 with label09;
catch java.security.InvalidKeyException from label05 to label06 with label09;
catch java.security.KeyStoreException from label07 to label08 with label09;
catch java.security.NoSuchAlgorithmException from label07 to label08 with label09;
catch java.security.UnrecoverableKeyException from label07 to label08 with label09;
catch java.security.InvalidKeyException from label07 to label08 with label09;
catch java.lang.ClassCastException from label12 to label13 with label19;
catch java.security.KeyStoreException from label12 to label13 with label19;
catch java.security.cert.CertificateExpiredException from label12 to label13 with label19;
catch java.security.cert.CertificateNotYetValidException from label12 to label13 with label19;
catch java.security.NoSuchAlgorithmException from label12 to label13 with label19;
catch java.security.UnrecoverableKeyException from label12 to label13 with label19;
catch java.lang.ClassCastException from label13 to label14 with label19;
catch java.security.KeyStoreException from label13 to label14 with label19;
catch java.security.cert.CertificateExpiredException from label13 to label14 with label19;
catch java.security.cert.CertificateNotYetValidException from label13 to label14 with label19;
catch java.security.NoSuchAlgorithmException from label13 to label14 with label19;
catch java.security.UnrecoverableKeyException from label13 to label14 with label19;
catch java.lang.ClassCastException from label15 to label18 with label19;
catch java.security.KeyStoreException from label15 to label18 with label19;
catch java.security.cert.CertificateExpiredException from label15 to label18 with label19;
catch java.security.cert.CertificateNotYetValidException from label15 to label18 with label19;
catch java.security.NoSuchAlgorithmException from label15 to label18 with label19;
catch java.security.UnrecoverableKeyException from label15 to label18 with label19;
}
public void <init>(io.vertx.ext.auth.PubSecKeyOptions)
{
byte[] v19, v25, v31;
javax.crypto.spec.SecretKeySpec v18, v24, v30;
java.security.GeneralSecurityException v20, v26, v32, v63;
byte v11, v35;
javax.crypto.Mac v16, v17, v22, v23, v28, v29;
java.lang.String v10, v2, v3, v34, v50, v53, v56, v59, v6, v61, v62, v7, v9;
java.lang.RuntimeException v21, v27, v33, v64;
io.vertx.ext.auth.impl.jose.JWK v0;
boolean v13, v14, v15, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47;
java.security.KeyFactory v48, v51, v54, v57;
io.vertx.core.buffer.Buffer v4;
io.vertx.ext.auth.PubSecKeyOptions v1;
java.nio.charset.Charset v49, v52, v55, v58;
int v12, v36, v8;
java.lang.IllegalArgumentException v60;
java.lang.Object v5;
v0 := @this: io.vertx.ext.auth.impl.jose.JWK;
v1 := @parameter0: io.vertx.ext.auth.PubSecKeyOptions;
specialinvoke v0.<java.lang.Object: void <init>()>();
v2 = virtualinvoke v1.<io.vertx.ext.auth.PubSecKeyOptions: java.lang.String getAlgorithm()>();
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String alg> = v2;
v3 = virtualinvoke v1.<io.vertx.ext.auth.PubSecKeyOptions: java.lang.String getId()>();
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kid> = v3;
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String use> = null;
v4 = virtualinvoke v1.<io.vertx.ext.auth.PubSecKeyOptions: io.vertx.core.buffer.Buffer getBuffer()>();
v5 = staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object)>(v4);
v6 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kid>;
if v6 != null goto label01;
v7 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String alg>;
v8 = virtualinvoke v5.<java.lang.Object: int hashCode()>();
v9 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,int)>(v7, v8) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001#\u0001");
goto label02;
label01:
v9 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kid>;
label02:
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String label> = v9;
v10 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String alg>;
v11 = -1;
v12 = virtualinvoke v10.<java.lang.String: int hashCode()>();
lookupswitch(v12)
{
case 69015912: goto label03;
case 69016964: goto label04;
case 69018667: goto label05;
default: goto label06;
};
label03:
v13 = virtualinvoke v10.<java.lang.String: boolean equals(java.lang.Object)>("HS256");
if v13 == 0 goto label06;
v11 = 0;
goto label06;
label04:
v14 = virtualinvoke v10.<java.lang.String: boolean equals(java.lang.Object)>("HS384");
if v14 == 0 goto label06;
v11 = 1;
goto label06;
label05:
v15 = virtualinvoke v10.<java.lang.String: boolean equals(java.lang.Object)>("HS512");
if v15 == 0 goto label06;
v11 = 2;
label06:
tableswitch(v11)
{
case 0: goto label07;
case 1: goto label11;
case 2: goto label15;
default: goto label19;
};
label07:
v16 = staticinvoke <javax.crypto.Mac: javax.crypto.Mac getInstance(java.lang.String)>("HMacSHA256");
v0.<io.vertx.ext.auth.impl.jose.JWK: javax.crypto.Mac mac> = v16;
v17 = v0.<io.vertx.ext.auth.impl.jose.JWK: javax.crypto.Mac mac>;
v18 = new javax.crypto.spec.SecretKeySpec;
v19 = interfaceinvoke v5.<io.vertx.core.buffer.Buffer: byte[] getBytes()>();
specialinvoke v18.<javax.crypto.spec.SecretKeySpec: void <init>(byte[],java.lang.String)>(v19, "HMacSHA256");
virtualinvoke v17.<javax.crypto.Mac: void init(java.security.Key)>(v18);
label08:
goto label10;
label09:
v20 := @caughtexception;
v21 = new java.lang.RuntimeException;
specialinvoke v21.<java.lang.RuntimeException: void <init>(java.lang.Throwable)>(v20);
throw v21;
label10:
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kty> = "oct";
return;
label11:
v22 = staticinvoke <javax.crypto.Mac: javax.crypto.Mac getInstance(java.lang.String)>("HMacSHA384");
v0.<io.vertx.ext.auth.impl.jose.JWK: javax.crypto.Mac mac> = v22;
v23 = v0.<io.vertx.ext.auth.impl.jose.JWK: javax.crypto.Mac mac>;
v24 = new javax.crypto.spec.SecretKeySpec;
v25 = interfaceinvoke v5.<io.vertx.core.buffer.Buffer: byte[] getBytes()>();
specialinvoke v24.<javax.crypto.spec.SecretKeySpec: void <init>(byte[],java.lang.String)>(v25, "HMacSHA384");
virtualinvoke v23.<javax.crypto.Mac: void init(java.security.Key)>(v24);
label12:
goto label14;
label13:
v26 := @caughtexception;
v27 = new java.lang.RuntimeException;
specialinvoke v27.<java.lang.RuntimeException: void <init>(java.lang.Throwable)>(v26);
throw v27;
label14:
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kty> = "oct";
return;
label15:
v28 = staticinvoke <javax.crypto.Mac: javax.crypto.Mac getInstance(java.lang.String)>("HMacSHA512");
v0.<io.vertx.ext.auth.impl.jose.JWK: javax.crypto.Mac mac> = v28;
v29 = v0.<io.vertx.ext.auth.impl.jose.JWK: javax.crypto.Mac mac>;
v30 = new javax.crypto.spec.SecretKeySpec;
v31 = interfaceinvoke v5.<io.vertx.core.buffer.Buffer: byte[] getBytes()>();
specialinvoke v30.<javax.crypto.spec.SecretKeySpec: void <init>(byte[],java.lang.String)>(v31, "HMacSHA512");
virtualinvoke v29.<javax.crypto.Mac: void init(java.security.Key)>(v30);
label16:
goto label18;
label17:
v32 := @caughtexception;
v33 = new java.lang.RuntimeException;
specialinvoke v33.<java.lang.RuntimeException: void <init>(java.lang.Throwable)>(v32);
throw v33;
label18:
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kty> = "oct";
return;
label19:
v34 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String alg>;
v35 = -1;
v36 = virtualinvoke v34.<java.lang.String: int hashCode()>();
lookupswitch(v36)
{
case 66245349: goto label26;
case 66246401: goto label27;
case 66248104: goto label28;
case 66770035: goto label30;
case 76404080: goto label23;
case 76405132: goto label24;
case 76406835: goto label25;
case 78251122: goto label20;
case 78252174: goto label21;
case 78253877: goto label22;
case 2053605894: goto label29;
default: goto label31;
};
label20:
v37 = virtualinvoke v34.<java.lang.String: boolean equals(java.lang.Object)>("RS256");
if v37 == 0 goto label31;
v35 = 0;
goto label31;
label21:
v38 = virtualinvoke v34.<java.lang.String: boolean equals(java.lang.Object)>("RS384");
if v38 == 0 goto label31;
v35 = 1;
goto label31;
label22:
v39 = virtualinvoke v34.<java.lang.String: boolean equals(java.lang.Object)>("RS512");
if v39 == 0 goto label31;
v35 = 2;
goto label31;
label23:
v40 = virtualinvoke v34.<java.lang.String: boolean equals(java.lang.Object)>("PS256");
if v40 == 0 goto label31;
v35 = 3;
goto label31;
label24:
v41 = virtualinvoke v34.<java.lang.String: boolean equals(java.lang.Object)>("PS384");
if v41 == 0 goto label31;
v35 = 4;
goto label31;
label25:
v42 = virtualinvoke v34.<java.lang.String: boolean equals(java.lang.Object)>("PS512");
if v42 == 0 goto label31;
v35 = 5;
goto label31;
label26:
v43 = virtualinvoke v34.<java.lang.String: boolean equals(java.lang.Object)>("ES256");
if v43 == 0 goto label31;
v35 = 6;
goto label31;
label27:
v44 = virtualinvoke v34.<java.lang.String: boolean equals(java.lang.Object)>("ES384");
if v44 == 0 goto label31;
v35 = 7;
goto label31;
label28:
v45 = virtualinvoke v34.<java.lang.String: boolean equals(java.lang.Object)>("ES512");
if v45 == 0 goto label31;
v35 = 8;
goto label31;
label29:
v46 = virtualinvoke v34.<java.lang.String: boolean equals(java.lang.Object)>("ES256K");
if v46 == 0 goto label31;
v35 = 9;
goto label31;
label30:
v47 = virtualinvoke v34.<java.lang.String: boolean equals(java.lang.Object)>("EdDSA");
if v47 == 0 goto label31;
v35 = 10;
label31:
tableswitch(v35)
{
case 0: goto label32;
case 1: goto label32;
case 2: goto label32;
case 3: goto label33;
case 4: goto label33;
case 5: goto label33;
case 6: goto label34;
case 7: goto label34;
case 8: goto label34;
case 9: goto label34;
case 10: goto label35;
default: goto label36;
};
label32:
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kty> = "RSA";
v48 = staticinvoke <java.security.KeyFactory: java.security.KeyFactory getInstance(java.lang.String)>("RSA");
v49 = <java.nio.charset.StandardCharsets: java.nio.charset.Charset US_ASCII>;
v50 = interfaceinvoke v5.<io.vertx.core.buffer.Buffer: java.lang.String toString(java.nio.charset.Charset)>(v49);
specialinvoke v0.<io.vertx.ext.auth.impl.jose.JWK: void parsePEM(java.security.KeyFactory,java.lang.String)>(v48, v50);
goto label38;
label33:
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kty> = "RSASSA";
v51 = staticinvoke <java.security.KeyFactory: java.security.KeyFactory getInstance(java.lang.String)>("RSA");
v52 = <java.nio.charset.StandardCharsets: java.nio.charset.Charset US_ASCII>;
v53 = interfaceinvoke v5.<io.vertx.core.buffer.Buffer: java.lang.String toString(java.nio.charset.Charset)>(v52);
specialinvoke v0.<io.vertx.ext.auth.impl.jose.JWK: void parsePEM(java.security.KeyFactory,java.lang.String)>(v51, v53);
goto label38;
label34:
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kty> = "EC";
v54 = staticinvoke <java.security.KeyFactory: java.security.KeyFactory getInstance(java.lang.String)>("EC");
v55 = <java.nio.charset.StandardCharsets: java.nio.charset.Charset US_ASCII>;
v56 = interfaceinvoke v5.<io.vertx.core.buffer.Buffer: java.lang.String toString(java.nio.charset.Charset)>(v55);
specialinvoke v0.<io.vertx.ext.auth.impl.jose.JWK: void parsePEM(java.security.KeyFactory,java.lang.String)>(v54, v56);
goto label38;
label35:
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kty> = "EdDSA";
v57 = staticinvoke <java.security.KeyFactory: java.security.KeyFactory getInstance(java.lang.String)>("EdDSA");
v58 = <java.nio.charset.StandardCharsets: java.nio.charset.Charset US_ASCII>;
v59 = interfaceinvoke v5.<io.vertx.core.buffer.Buffer: java.lang.String toString(java.nio.charset.Charset)>(v58);
specialinvoke v0.<io.vertx.ext.auth.impl.jose.JWK: void parsePEM(java.security.KeyFactory,java.lang.String)>(v57, v59);
goto label38;
label36:
v60 = new java.lang.IllegalArgumentException;
v61 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String alg>;
v62 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v61) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Unknown algorithm: \u0001");
specialinvoke v60.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(v62);
throw v60;
label37:
v63 := @caughtexception;
v64 = new java.lang.RuntimeException;
specialinvoke v64.<java.lang.RuntimeException: void <init>(java.lang.Throwable)>(v63);
throw v64;
label38:
return;
catch java.security.NoSuchAlgorithmException from label07 to label08 with label09;
catch java.security.InvalidKeyException from label07 to label08 with label09;
catch java.security.NoSuchAlgorithmException from label11 to label12 with label13;
catch java.security.InvalidKeyException from label11 to label12 with label13;
catch java.security.NoSuchAlgorithmException from label15 to label16 with label17;
catch java.security.InvalidKeyException from label15 to label16 with label17;
catch java.security.spec.InvalidKeySpecException from label19 to label37 with label37;
catch java.security.cert.CertificateException from label19 to label37 with label37;
catch java.security.NoSuchAlgorithmException from label19 to label37 with label37;
}
private void parsePEM(java.security.KeyFactory, java.lang.String) throws java.security.cert.CertificateException, java.security.spec.InvalidKeySpecException
{
byte[] v40, v44, v45, v48, v49;
java.lang.IllegalStateException v51;
io.vertx.ext.auth.impl.jose.JWK v0;
java.security.cert.CertificateFactory v37;
java.util.regex.Matcher v21, v9;
byte v28;
java.io.ByteArrayInputStream v38;
boolean v10, v14, v19, v22, v24, v30, v31, v32, v33, v34, v35, v36;
java.security.spec.X509EncodedKeySpec v43;
java.security.KeyFactory v1;
java.security.cert.Certificate v41;
io.vertx.core.buffer.Buffer v13;
java.security.PrivateKey v50;
java.util.regex.Pattern v6, v7;
java.lang.String[] v3;
java.nio.charset.Charset v39;
int v15, v16, v29, v4;
java.lang.String v12, v17, v18, v2, v20, v23, v26, v52, v8;
java.security.spec.PKCS8EncodedKeySpec v47;
java.security.PublicKey v42, v46;
java.lang.IllegalArgumentException v11, v25, v27, v5;
v0 := @this: io.vertx.ext.auth.impl.jose.JWK;
v1 := @parameter0: java.security.KeyFactory;
v2 := @parameter1: java.lang.String;
v3 = virtualinvoke v2.<java.lang.String: java.lang.String[] split(java.lang.String)>("\r?\n");
v4 = lengthof v3;
if v4 > 2 goto label01;
v5 = new java.lang.IllegalArgumentException;
specialinvoke v5.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>("PEM contains not enough lines");
throw v5;
label01:
v6 = staticinvoke <java.util.regex.Pattern: java.util.regex.Pattern compile(java.lang.String)>("-----BEGIN (.+?)-----");
v7 = staticinvoke <java.util.regex.Pattern: java.util.regex.Pattern compile(java.lang.String)>("-----END (.+?)-----");
v8 = v3[0];
v9 = virtualinvoke v6.<java.util.regex.Pattern: java.util.regex.Matcher matcher(java.lang.CharSequence)>(v8);
v10 = virtualinvoke v9.<java.util.regex.Matcher: boolean matches()>();
if v10 != 0 goto label02;
v11 = new java.lang.IllegalArgumentException;
specialinvoke v11.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>("PEM first line does not match a BEGIN line");
throw v11;
label02:
v12 = virtualinvoke v9.<java.util.regex.Matcher: java.lang.String group(int)>(1);
v13 = staticinvoke <io.vertx.core.buffer.Buffer: io.vertx.core.buffer.Buffer buffer()>();
v14 = 0;
v15 = 1;
label03:
v16 = lengthof v3;
if v15 >= v16 goto label06;
v17 = "";
v18 = v3[v15];
v19 = virtualinvoke v17.<java.lang.String: boolean equals(java.lang.Object)>(v18);
if v19 != 0 goto label05;
v20 = v3[v15];
v21 = virtualinvoke v7.<java.util.regex.Pattern: java.util.regex.Matcher matcher(java.lang.CharSequence)>(v20);
v22 = virtualinvoke v21.<java.util.regex.Matcher: boolean matches()>();
if v22 == 0 goto label04;
v14 = 1;
v23 = virtualinvoke v21.<java.util.regex.Matcher: java.lang.String group(int)>(1);
v24 = virtualinvoke v12.<java.lang.String: boolean equals(java.lang.Object)>(v23);
if v24 != 0 goto label06;
v25 = new java.lang.IllegalArgumentException;
specialinvoke v25.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>("PEM END line does not match start");
throw v25;
label04:
v26 = v3[v15];
interfaceinvoke v13.<io.vertx.core.buffer.Buffer: io.vertx.core.buffer.Buffer appendString(java.lang.String)>(v26);
label05:
v15 = v15 + 1;
goto label03;
label06:
if v14 != 0 goto label07;
v27 = new java.lang.IllegalArgumentException;
specialinvoke v27.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>("PEM END line not found");
throw v27;
label07:
v28 = -1;
v29 = virtualinvoke v12.<java.lang.String: int hashCode()>();
lookupswitch(v29)
{
case -1905985528: goto label09;
case -862192120: goto label11;
case -326720120: goto label10;
case -189606537: goto label08;
case -170985982: goto label12;
case 1919751810: goto label13;
case 2121838594: goto label14;
default: goto label15;
};
label08:
v30 = virtualinvoke v12.<java.lang.String: boolean equals(java.lang.Object)>("CERTIFICATE");
if v30 == 0 goto label15;
v28 = 0;
goto label15;
label09:
v31 = virtualinvoke v12.<java.lang.String: boolean equals(java.lang.Object)>("PUBLIC KEY");
if v31 == 0 goto label15;
v28 = 1;
goto label15;
label10:
v32 = virtualinvoke v12.<java.lang.String: boolean equals(java.lang.Object)>("PUBLIC RSA KEY");
if v32 == 0 goto label15;
v28 = 2;
goto label15;
label11:
v33 = virtualinvoke v12.<java.lang.String: boolean equals(java.lang.Object)>("RSA PUBLIC KEY");
if v33 == 0 goto label15;
v28 = 3;
goto label15;
label12:
v34 = virtualinvoke v12.<java.lang.String: boolean equals(java.lang.Object)>("PRIVATE KEY");
if v34 == 0 goto label15;
v28 = 4;
goto label15;
label13:
v35 = virtualinvoke v12.<java.lang.String: boolean equals(java.lang.Object)>("PRIVATE RSA KEY");
if v35 == 0 goto label15;
v28 = 5;
goto label15;
label14:
v36 = virtualinvoke v12.<java.lang.String: boolean equals(java.lang.Object)>("RSA PRIVATE KEY");
if v36 == 0 goto label15;
v28 = 6;
label15:
tableswitch(v28)
{
case 0: goto label16;
case 1: goto label17;
case 2: goto label17;
case 3: goto label17;
case 4: goto label18;
case 5: goto label18;
case 6: goto label18;
default: goto label19;
};
label16:
v37 = staticinvoke <java.security.cert.CertificateFactory: java.security.cert.CertificateFactory getInstance(java.lang.String)>("X.509");
v38 = new java.io.ByteArrayInputStream;
v39 = <java.nio.charset.StandardCharsets: java.nio.charset.Charset US_ASCII>;
v40 = virtualinvoke v2.<java.lang.String: byte[] getBytes(java.nio.charset.Charset)>(v39);
specialinvoke v38.<java.io.ByteArrayInputStream: void <init>(byte[])>(v40);
v41 = virtualinvoke v37.<java.security.cert.CertificateFactory: java.security.cert.Certificate generateCertificate(java.io.InputStream)>(v38);
v42 = virtualinvoke v41.<java.security.cert.Certificate: java.security.PublicKey getPublicKey()>();
v0.<io.vertx.ext.auth.impl.jose.JWK: java.security.PublicKey publicKey> = v42;
return;
label17:
v43 = new java.security.spec.X509EncodedKeySpec;
v44 = interfaceinvoke v13.<io.vertx.core.buffer.Buffer: byte[] getBytes()>();
v45 = staticinvoke <io.vertx.ext.auth.impl.Codec: byte[] base64MimeDecode(byte[])>(v44);
specialinvoke v43.<java.security.spec.X509EncodedKeySpec: void <init>(byte[])>(v45);
v46 = virtualinvoke v1.<java.security.KeyFactory: java.security.PublicKey generatePublic(java.security.spec.KeySpec)>(v43);
v0.<io.vertx.ext.auth.impl.jose.JWK: java.security.PublicKey publicKey> = v46;
return;
label18:
v47 = new java.security.spec.PKCS8EncodedKeySpec;
v48 = interfaceinvoke v13.<io.vertx.core.buffer.Buffer: byte[] getBytes()>();
v49 = staticinvoke <io.vertx.ext.auth.impl.Codec: byte[] base64MimeDecode(byte[])>(v48);
specialinvoke v47.<java.security.spec.PKCS8EncodedKeySpec: void <init>(byte[])>(v49);
v50 = virtualinvoke v1.<java.security.KeyFactory: java.security.PrivateKey generatePrivate(java.security.spec.KeySpec)>(v47);
v0.<io.vertx.ext.auth.impl.jose.JWK: java.security.PrivateKey privateKey> = v50;
return;
label19:
v51 = new java.lang.IllegalStateException;
v52 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v12) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Invalid PEM content: \u0001");
specialinvoke v51.<java.lang.IllegalStateException: void <init>(java.lang.String)>(v52);
throw v51;
}
private void <init>(java.lang.String, javax.crypto.Mac) throws java.security.NoSuchAlgorithmException
{
io.vertx.ext.auth.impl.jose.JWK v0;
javax.crypto.Mac v2;
byte v7;
java.security.NoSuchAlgorithmException v12;
int v4, v8;
java.lang.String v1, v13, v3, v5, v6;
boolean v10, v11, v9;
v0 := @this: io.vertx.ext.auth.impl.jose.JWK;
v1 := @parameter0: java.lang.String;
v2 := @parameter1: javax.crypto.Mac;
specialinvoke v0.<java.lang.Object: void <init>()>();
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String alg> = v1;
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kid> = null;
v3 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String alg>;
v4 = virtualinvoke v2.<java.lang.Object: int hashCode()>();
v5 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,int)>(v3, v4) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001#\u0001");
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String label> = v5;
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String use> = null;
v6 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String alg>;
v7 = -1;
v8 = virtualinvoke v6.<java.lang.String: int hashCode()>();
lookupswitch(v8)
{
case 69015912: goto label1;
case 69016964: goto label2;
case 69018667: goto label3;
default: goto label4;
};
label1:
v9 = virtualinvoke v6.<java.lang.String: boolean equals(java.lang.Object)>("HS256");
if v9 == 0 goto label4;
v7 = 0;
goto label4;
label2:
v10 = virtualinvoke v6.<java.lang.String: boolean equals(java.lang.Object)>("HS384");
if v10 == 0 goto label4;
v7 = 1;
goto label4;
label3:
v11 = virtualinvoke v6.<java.lang.String: boolean equals(java.lang.Object)>("HS512");
if v11 == 0 goto label4;
v7 = 2;
label4:
tableswitch(v7)
{
case 0: goto label5;
case 1: goto label5;
case 2: goto label5;
default: goto label6;
};
label5:
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kty> = "oct";
v0.<io.vertx.ext.auth.impl.jose.JWK: javax.crypto.Mac mac> = v2;
goto label7;
label6:
v12 = new java.security.NoSuchAlgorithmException;
v13 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v1) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Unknown algorithm: \u0001");
specialinvoke v12.<java.security.NoSuchAlgorithmException: void <init>(java.lang.String)>(v13);
throw v12;
label7:
return;
}
private void <init>(java.lang.String, java.security.cert.X509Certificate, java.security.PrivateKey) throws java.security.NoSuchAlgorithmException
{
java.security.cert.X509Certificate v2;
io.vertx.ext.auth.impl.jose.JWK v0;
byte v9;
int v10, v4, v5, v7;
java.lang.String v1, v22, v6;
boolean v11, v12, v13, v14, v15, v16, v17, v18, v19, v20;
java.security.PublicKey v8;
java.security.PrivateKey v3;
java.security.NoSuchAlgorithmException v21;
v0 := @this: io.vertx.ext.auth.impl.jose.JWK;
v1 := @parameter0: java.lang.String;
v2 := @parameter1: java.security.cert.X509Certificate;
v3 := @parameter2: java.security.PrivateKey;
specialinvoke v0.<java.lang.Object: void <init>()>();
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String alg> = v1;
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kid> = null;
if v3 == null goto label01;
v4 = virtualinvoke v2.<java.security.cert.X509Certificate: int hashCode()>();
v5 = virtualinvoke v3.<java.lang.Object: int hashCode()>();
v6 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,int,int)>(v1, v4, v5) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001#\u0001-\u0001");
goto label02;
label01:
v7 = virtualinvoke v2.<java.security.cert.X509Certificate: int hashCode()>();
v6 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,int)>(v1, v7) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001#\u0001");
label02:
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String label> = v6;
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String use> = null;
v8 = virtualinvoke v2.<java.security.cert.X509Certificate: java.security.PublicKey getPublicKey()>();
v0.<io.vertx.ext.auth.impl.jose.JWK: java.security.PublicKey publicKey> = v8;
v0.<io.vertx.ext.auth.impl.jose.JWK: java.security.PrivateKey privateKey> = v3;
v9 = -1;
v10 = virtualinvoke v1.<java.lang.String: int hashCode()>();
lookupswitch(v10)
{
case 66245349: goto label09;
case 66246401: goto label10;
case 66248104: goto label11;
case 76404080: goto label06;
case 76405132: goto label07;
case 76406835: goto label08;
case 78251122: goto label03;
case 78252174: goto label04;
case 78253877: goto label05;
case 2053605894: goto label12;
default: goto label13;
};
label03:
v11 = virtualinvoke v1.<java.lang.String: boolean equals(java.lang.Object)>("RS256");
if v11 == 0 goto label13;
v9 = 0;
goto label13;
label04:
v12 = virtualinvoke v1.<java.lang.String: boolean equals(java.lang.Object)>("RS384");
if v12 == 0 goto label13;
v9 = 1;
goto label13;
label05:
v13 = virtualinvoke v1.<java.lang.String: boolean equals(java.lang.Object)>("RS512");
if v13 == 0 goto label13;
v9 = 2;
goto label13;
label06:
v14 = virtualinvoke v1.<java.lang.String: boolean equals(java.lang.Object)>("PS256");
if v14 == 0 goto label13;
v9 = 3;
goto label13;
label07:
v15 = virtualinvoke v1.<java.lang.String: boolean equals(java.lang.Object)>("PS384");
if v15 == 0 goto label13;
v9 = 4;
goto label13;
label08:
v16 = virtualinvoke v1.<java.lang.String: boolean equals(java.lang.Object)>("PS512");
if v16 == 0 goto label13;
v9 = 5;
goto label13;
label09:
v17 = virtualinvoke v1.<java.lang.String: boolean equals(java.lang.Object)>("ES256");
if v17 == 0 goto label13;
v9 = 6;
goto label13;
label10:
v18 = virtualinvoke v1.<java.lang.String: boolean equals(java.lang.Object)>("ES384");
if v18 == 0 goto label13;
v9 = 7;
goto label13;
label11:
v19 = virtualinvoke v1.<java.lang.String: boolean equals(java.lang.Object)>("ES512");
if v19 == 0 goto label13;
v9 = 8;
goto label13;
label12:
v20 = virtualinvoke v1.<java.lang.String: boolean equals(java.lang.Object)>("ES256K");
if v20 == 0 goto label13;
v9 = 9;
label13:
tableswitch(v9)
{
case 0: goto label14;
case 1: goto label14;
case 2: goto label14;
case 3: goto label15;
case 4: goto label15;
case 5: goto label15;
case 6: goto label16;
case 7: goto label16;
case 8: goto label16;
case 9: goto label16;
default: goto label17;
};
label14:
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kty> = "RSA";
goto label18;
label15:
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kty> = "RSASSA";
goto label18;
label16:
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kty> = "EC";
goto label18;
label17:
v21 = new java.security.NoSuchAlgorithmException;
v22 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v1) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Unknown algorithm: \u0001");
specialinvoke v21.<java.security.NoSuchAlgorithmException: void <init>(java.lang.String)>(v22);
throw v21;
label18:
return;
}
public void <init>(io.vertx.core.json.JsonObject)
{
io.vertx.ext.auth.impl.jose.JWK v0;
java.security.GeneralSecurityException v56;
byte v15, v29, v42, v5;
io.vertx.core.json.JsonObject v1;
boolean v10, v11, v17, v18, v19, v20, v21, v22, v23, v31, v32, v33, v34, v44, v45, v46, v7, v8, v9;
java.security.NoSuchAlgorithmException v24, v35, v47;
int v16, v30, v43, v55, v6;
java.lang.String v12, v13, v14, v2, v25, v26, v27, v28, v3, v36, v37, v38, v39, v4, v40, v41, v48, v50, v51, v52, v53, v54;
java.lang.RuntimeException v49, v57;
v0 := @this: io.vertx.ext.auth.impl.jose.JWK;
v1 := @parameter0: io.vertx.core.json.JsonObject;
specialinvoke v0.<java.lang.Object: void <init>()>();
v2 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("kid");
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kid> = v2;
v3 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("use");
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String use> = v3;
label01:
v4 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("kty");
v5 = -1;
v6 = virtualinvoke v4.<java.lang.String: int hashCode()>();
lookupswitch(v6)
{
case -1868705855: goto label03;
case 2206: goto label04;
case 78324: goto label05;
case 81440: goto label02;
case 109856: goto label06;
default: goto label07;
};
label02:
v7 = virtualinvoke v4.<java.lang.String: boolean equals(java.lang.Object)>("RSA");
if v7 == 0 goto label07;
v5 = 0;
goto label07;
label03:
v8 = virtualinvoke v4.<java.lang.String: boolean equals(java.lang.Object)>("RSASSA");
if v8 == 0 goto label07;
v5 = 1;
goto label07;
label04:
v9 = virtualinvoke v4.<java.lang.String: boolean equals(java.lang.Object)>("EC");
if v9 == 0 goto label07;
v5 = 2;
goto label07;
label05:
v10 = virtualinvoke v4.<java.lang.String: boolean equals(java.lang.Object)>("OKP");
if v10 == 0 goto label07;
v5 = 3;
goto label07;
label06:
v11 = virtualinvoke v4.<java.lang.String: boolean equals(java.lang.Object)>("oct");
if v11 == 0 goto label07;
v5 = 4;
label07:
tableswitch(v5)
{
case 0: goto label08;
case 1: goto label08;
case 2: goto label19;
case 3: goto label27;
case 4: goto label28;
default: goto label37;
};
label08:
v12 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("kty");
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kty> = v12;
v13 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String,java.lang.String)>("alg", "RS256");
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String alg> = v13;
v14 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String alg>;
v15 = -1;
v16 = virtualinvoke v14.<java.lang.String: int hashCode()>();
lookupswitch(v16)
{
case 81424: goto label09;
case 76404080: goto label13;
case 76405132: goto label14;
case 76406835: goto label15;
case 78251122: goto label10;
case 78252174: goto label11;
case 78253877: goto label12;
default: goto label16;
};
label09:
v17 = virtualinvoke v14.<java.lang.String: boolean equals(java.lang.Object)>("RS1");
if v17 == 0 goto label16;
v15 = 0;
goto label16;
label10:
v18 = virtualinvoke v14.<java.lang.String: boolean equals(java.lang.Object)>("RS256");
if v18 == 0 goto label16;
v15 = 1;
goto label16;
label11:
v19 = virtualinvoke v14.<java.lang.String: boolean equals(java.lang.Object)>("RS384");
if v19 == 0 goto label16;
v15 = 2;
goto label16;
label12:
v20 = virtualinvoke v14.<java.lang.String: boolean equals(java.lang.Object)>("RS512");
if v20 == 0 goto label16;
v15 = 3;
goto label16;
label13:
v21 = virtualinvoke v14.<java.lang.String: boolean equals(java.lang.Object)>("PS256");
if v21 == 0 goto label16;
v15 = 4;
goto label16;
label14:
v22 = virtualinvoke v14.<java.lang.String: boolean equals(java.lang.Object)>("PS384");
if v22 == 0 goto label16;
v15 = 5;
goto label16;
label15:
v23 = virtualinvoke v14.<java.lang.String: boolean equals(java.lang.Object)>("PS512");
if v23 == 0 goto label16;
v15 = 6;
label16:
tableswitch(v15)
{
case 0: goto label17;
case 1: goto label17;
case 2: goto label17;
case 3: goto label17;
case 4: goto label17;
case 5: goto label17;
case 6: goto label17;
default: goto label18;
};
label17:
specialinvoke v0.<io.vertx.ext.auth.impl.jose.JWK: void createRSA(io.vertx.core.json.JsonObject)>(v1);
goto label38;
label18:
v24 = new java.security.NoSuchAlgorithmException;
v25 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String alg>;
specialinvoke v24.<java.security.NoSuchAlgorithmException: void <init>(java.lang.String)>(v25);
throw v24;
label19:
v26 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("kty");
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kty> = v26;
v27 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String,java.lang.String)>("alg", "ES256");
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String alg> = v27;
v28 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String alg>;
v29 = -1;
v30 = virtualinvoke v28.<java.lang.String: int hashCode()>();
lookupswitch(v30)
{
case 66245349: goto label20;
case 66246401: goto label23;
case 66248104: goto label22;
case 2053605894: goto label21;
default: goto label24;
};
label20:
v31 = virtualinvoke v28.<java.lang.String: boolean equals(java.lang.Object)>("ES256");
if v31 == 0 goto label24;
v29 = 0;
goto label24;
label21:
v32 = virtualinvoke v28.<java.lang.String: boolean equals(java.lang.Object)>("ES256K");
if v32 == 0 goto label24;
v29 = 1;
goto label24;
label22:
v33 = virtualinvoke v28.<java.lang.String: boolean equals(java.lang.Object)>("ES512");
if v33 == 0 goto label24;
v29 = 2;
goto label24;
label23:
v34 = virtualinvoke v28.<java.lang.String: boolean equals(java.lang.Object)>("ES384");
if v34 == 0 goto label24;
v29 = 3;
label24:
tableswitch(v29)
{
case 0: goto label25;
case 1: goto label25;
case 2: goto label25;
case 3: goto label25;
default: goto label26;
};
label25:
specialinvoke v0.<io.vertx.ext.auth.impl.jose.JWK: void createEC(io.vertx.core.json.JsonObject)>(v1);
goto label38;
label26:
v35 = new java.security.NoSuchAlgorithmException;
v36 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String alg>;
specialinvoke v35.<java.security.NoSuchAlgorithmException: void <init>(java.lang.String)>(v36);
throw v35;
label27:
v37 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("kty");
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kty> = v37;
v38 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String,java.lang.String)>("alg", "EdDSA");
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String alg> = v38;
specialinvoke v0.<io.vertx.ext.auth.impl.jose.JWK: void createOKP(io.vertx.core.json.JsonObject)>(v1);
goto label38;
label28:
v39 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("kty");
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kty> = v39;
v40 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String,java.lang.String)>("alg", "HS256");
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String alg> = v40;
v41 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String alg>;
v42 = -1;
v43 = virtualinvoke v41.<java.lang.String: int hashCode()>();
lookupswitch(v43)
{
case 69015912: goto label29;
case 69016964: goto label30;
case 69018667: goto label31;
default: goto label32;
};
label29:
v44 = virtualinvoke v41.<java.lang.String: boolean equals(java.lang.Object)>("HS256");
if v44 == 0 goto label32;
v42 = 0;
goto label32;
label30:
v45 = virtualinvoke v41.<java.lang.String: boolean equals(java.lang.Object)>("HS384");
if v45 == 0 goto label32;
v42 = 1;
goto label32;
label31:
v46 = virtualinvoke v41.<java.lang.String: boolean equals(java.lang.Object)>("HS512");
if v46 == 0 goto label32;
v42 = 2;
label32:
tableswitch(v42)
{
case 0: goto label33;
case 1: goto label34;
case 2: goto label35;
default: goto label36;
};
label33:
specialinvoke v0.<io.vertx.ext.auth.impl.jose.JWK: void createOCT(java.lang.String,io.vertx.core.json.JsonObject)>("HMacSHA256", v1);
goto label38;
label34:
specialinvoke v0.<io.vertx.ext.auth.impl.jose.JWK: void createOCT(java.lang.String,io.vertx.core.json.JsonObject)>("HMacSHA384", v1);
goto label38;
label35:
specialinvoke v0.<io.vertx.ext.auth.impl.jose.JWK: void createOCT(java.lang.String,io.vertx.core.json.JsonObject)>("HMacSHA512", v1);
goto label38;
label36:
v47 = new java.security.NoSuchAlgorithmException;
v48 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String alg>;
specialinvoke v47.<java.security.NoSuchAlgorithmException: void <init>(java.lang.String)>(v48);
throw v47;
label37:
v49 = new java.lang.RuntimeException;
v50 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("kty");
v51 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v50) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Unsupported key type: \u0001");
specialinvoke v49.<java.lang.RuntimeException: void <init>(java.lang.String)>(v51);
throw v49;
label38:
v52 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kid>;
if v52 == null goto label39;
v53 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kid>;
goto label40;
label39:
v54 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String alg>;
v55 = virtualinvoke v1.<io.vertx.core.json.JsonObject: int hashCode()>();
v53 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,int)>(v54, v55) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001#\u0001");
label40:
v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String label> = v53;
label41:
goto label43;
label42:
v56 := @caughtexception;
v57 = new java.lang.RuntimeException;
specialinvoke v57.<java.lang.RuntimeException: void <init>(java.lang.Throwable)>(v56);
throw v57;
label43:
return;
catch java.security.NoSuchAlgorithmException from label01 to label41 with label42;
catch java.security.InvalidKeyException from label01 to label41 with label42;
catch java.security.spec.InvalidKeySpecException from label01 to label41 with label42;
catch java.security.spec.InvalidParameterSpecException from label01 to label41 with label42;
catch java.security.cert.CertificateException from label01 to label41 with label42;
catch java.security.NoSuchProviderException from label01 to label41 with label42;
catch java.security.SignatureException from label01 to label41 with label42;
}
private void createRSA(io.vertx.core.json.JsonObject) throws java.security.NoSuchAlgorithmException, java.security.spec.InvalidKeySpecException, java.security.cert.CertificateException, java.security.InvalidKeyException, java.security.NoSuchProviderException, java.security.SignatureException
{
java.security.cert.X509Certificate v42;
byte[] v17, v20, v23, v26, v29, v32, v6, v9;
io.vertx.ext.auth.impl.jose.JWK v0;
java.security.spec.RSAPublicKeySpec v11;
io.vertx.core.json.JsonObject v1;
java.math.BigInteger v15, v18, v21, v24, v27, v30, v4, v7;
boolean v14, v3, v36;
java.security.KeyFactory v10, v33;
java.security.PrivateKey v35;
java.security.spec.RSAPrivateCrtKeySpec v34;
java.lang.String[] v13, v2;
java.util.ArrayList v38;
int v39, v40;
java.lang.String v16, v19, v22, v25, v28, v31, v41, v5, v8;
java.security.PublicKey v12, v44;
io.vertx.core.json.JsonArray v37;
java.lang.Object v43;
v0 := @this: io.vertx.ext.auth.impl.jose.JWK;
v1 := @parameter0: io.vertx.core.json.JsonObject;
v2 = newarray (java.lang.String)[2];
v2[0] = "n";
v2[1] = "e";
v3 = staticinvoke <io.vertx.ext.auth.impl.jose.JWK: boolean jsonHasProperties(io.vertx.core.json.JsonObject,java.lang.String[])>(v1, v2);
if v3 == 0 goto label1;
v4 = new java.math.BigInteger;
v5 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("n");
v6 = staticinvoke <io.vertx.ext.auth.impl.Codec: byte[] base64UrlDecode(java.lang.String)>(v5);
specialinvoke v4.<java.math.BigInteger: void <init>(int,byte[])>(1, v6);
v7 = new java.math.BigInteger;
v8 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("e");
v9 = staticinvoke <io.vertx.ext.auth.impl.Codec: byte[] base64UrlDecode(java.lang.String)>(v8);
specialinvoke v7.<java.math.BigInteger: void <init>(int,byte[])>(1, v9);
v10 = staticinvoke <java.security.KeyFactory: java.security.KeyFactory getInstance(java.lang.String)>("RSA");
v11 = new java.security.spec.RSAPublicKeySpec;
specialinvoke v11.<java.security.spec.RSAPublicKeySpec: void <init>(java.math.BigInteger,java.math.BigInteger)>(v4, v7);
v12 = virtualinvoke v10.<java.security.KeyFactory: java.security.PublicKey generatePublic(java.security.spec.KeySpec)>(v11);
v0.<io.vertx.ext.auth.impl.jose.JWK: java.security.PublicKey publicKey> = v12;
v13 = newarray (java.lang.String)[6];
v13[0] = "d";
v13[1] = "p";
v13[2] = "q";
v13[3] = "dp";
v13[4] = "dq";
v13[5] = "qi";
v14 = staticinvoke <io.vertx.ext.auth.impl.jose.JWK: boolean jsonHasProperties(io.vertx.core.json.JsonObject,java.lang.String[])>(v1, v13);
if v14 == 0 goto label1;
v15 = new java.math.BigInteger;
v16 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("d");
v17 = staticinvoke <io.vertx.ext.auth.impl.Codec: byte[] base64UrlDecode(java.lang.String)>(v16);
specialinvoke v15.<java.math.BigInteger: void <init>(int,byte[])>(1, v17);
v18 = new java.math.BigInteger;
v19 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("p");
v20 = staticinvoke <io.vertx.ext.auth.impl.Codec: byte[] base64UrlDecode(java.lang.String)>(v19);
specialinvoke v18.<java.math.BigInteger: void <init>(int,byte[])>(1, v20);
v21 = new java.math.BigInteger;
v22 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("q");
v23 = staticinvoke <io.vertx.ext.auth.impl.Codec: byte[] base64UrlDecode(java.lang.String)>(v22);
specialinvoke v21.<java.math.BigInteger: void <init>(int,byte[])>(1, v23);
v24 = new java.math.BigInteger;
v25 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("dp");
v26 = staticinvoke <io.vertx.ext.auth.impl.Codec: byte[] base64UrlDecode(java.lang.String)>(v25);
specialinvoke v24.<java.math.BigInteger: void <init>(int,byte[])>(1, v26);
v27 = new java.math.BigInteger;
v28 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("dq");
v29 = staticinvoke <io.vertx.ext.auth.impl.Codec: byte[] base64UrlDecode(java.lang.String)>(v28);
specialinvoke v27.<java.math.BigInteger: void <init>(int,byte[])>(1, v29);
v30 = new java.math.BigInteger;
v31 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("qi");
v32 = staticinvoke <io.vertx.ext.auth.impl.Codec: byte[] base64UrlDecode(java.lang.String)>(v31);
specialinvoke v30.<java.math.BigInteger: void <init>(int,byte[])>(1, v32);
v33 = staticinvoke <java.security.KeyFactory: java.security.KeyFactory getInstance(java.lang.String)>("RSA");
v34 = new java.security.spec.RSAPrivateCrtKeySpec;
specialinvoke v34.<java.security.spec.RSAPrivateCrtKeySpec: void <init>(java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger)>(v4, v7, v15, v18, v21, v24, v27, v30);
v35 = virtualinvoke v33.<java.security.KeyFactory: java.security.PrivateKey generatePrivate(java.security.spec.KeySpec)>(v34);
v0.<io.vertx.ext.auth.impl.jose.JWK: java.security.PrivateKey privateKey> = v35;
label1:
v36 = virtualinvoke v1.<io.vertx.core.json.JsonObject: boolean containsKey(java.lang.String)>("x5c");
if v36 == 0 goto label4;
v37 = virtualinvoke v1.<io.vertx.core.json.JsonObject: io.vertx.core.json.JsonArray getJsonArray(java.lang.String)>("x5c");
v38 = new java.util.ArrayList;
specialinvoke v38.<java.util.ArrayList: void <init>()>();
v39 = 0;
label2:
v40 = virtualinvoke v37.<io.vertx.core.json.JsonArray: int size()>();
if v39 >= v40 goto label3;
v41 = virtualinvoke v37.<io.vertx.core.json.JsonArray: java.lang.String getString(int)>(v39);
v42 = staticinvoke <io.vertx.ext.auth.impl.jose.JWS: java.security.cert.X509Certificate parseX5c(java.lang.String)>(v41);
interfaceinvoke v38.<java.util.List: boolean add(java.lang.Object)>(v42);
v39 = v39 + 1;
goto label2;
label3:
staticinvoke <io.vertx.ext.auth.impl.CertificateHelper: void checkValidity(java.util.List,boolean,java.util.List)>(v38, 0, null);
v43 = interfaceinvoke v38.<java.util.List: java.lang.Object get(int)>(0);
v44 = virtualinvoke v43.<java.security.cert.X509Certificate: java.security.PublicKey getPublicKey()>();
v0.<io.vertx.ext.auth.impl.jose.JWK: java.security.PublicKey publicKey> = v44;
label4:
return;
}
private void createEC(io.vertx.core.json.JsonObject) throws java.security.NoSuchAlgorithmException, java.security.spec.InvalidKeySpecException, java.security.spec.InvalidParameterSpecException
{
byte[] v10, v13, v23;
io.vertx.ext.auth.impl.jose.JWK v0;
java.security.spec.ECPublicKeySpec v15;
java.lang.String[] v19, v6;
java.security.spec.ECPrivateKeySpec v25;
java.security.spec.ECGenParameterSpec v3;
io.vertx.core.json.JsonObject v1;
java.math.BigInteger v11, v21, v8;
java.lang.String v12, v22, v4, v5, v9;
java.security.spec.AlgorithmParameterSpec v17, v26;
boolean v20, v7;
java.security.PublicKey v18;
java.security.AlgorithmParameters v2;
java.security.KeyFactory v14, v24;
java.security.PrivateKey v27;
java.security.spec.ECPoint v16;
v0 := @this: io.vertx.ext.auth.impl.jose.JWK;
v1 := @parameter0: io.vertx.core.json.JsonObject;
v2 = staticinvoke <java.security.AlgorithmParameters: java.security.AlgorithmParameters getInstance(java.lang.String)>("EC");
v3 = new java.security.spec.ECGenParameterSpec;
v4 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("crv");
v5 = staticinvoke <io.vertx.ext.auth.impl.jose.JWK: java.lang.String translateECCrv(java.lang.String)>(v4);
specialinvoke v3.<java.security.spec.ECGenParameterSpec: void <init>(java.lang.String)>(v5);
virtualinvoke v2.<java.security.AlgorithmParameters: void init(java.security.spec.AlgorithmParameterSpec)>(v3);
v6 = newarray (java.lang.String)[2];
v6[0] = "x";
v6[1] = "y";
v7 = staticinvoke <io.vertx.ext.auth.impl.jose.JWK: boolean jsonHasProperties(io.vertx.core.json.JsonObject,java.lang.String[])>(v1, v6);
if v7 == 0 goto label1;
v8 = new java.math.BigInteger;
v9 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("x");
v10 = staticinvoke <io.vertx.ext.auth.impl.Codec: byte[] base64UrlDecode(java.lang.String)>(v9);
specialinvoke v8.<java.math.BigInteger: void <init>(int,byte[])>(1, v10);
v11 = new java.math.BigInteger;
v12 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("y");
v13 = staticinvoke <io.vertx.ext.auth.impl.Codec: byte[] base64UrlDecode(java.lang.String)>(v12);
specialinvoke v11.<java.math.BigInteger: void <init>(int,byte[])>(1, v13);
v14 = staticinvoke <java.security.KeyFactory: java.security.KeyFactory getInstance(java.lang.String)>("EC");
v15 = new java.security.spec.ECPublicKeySpec;
v16 = new java.security.spec.ECPoint;
specialinvoke v16.<java.security.spec.ECPoint: void <init>(java.math.BigInteger,java.math.BigInteger)>(v8, v11);
v17 = virtualinvoke v2.<java.security.AlgorithmParameters: java.security.spec.AlgorithmParameterSpec getParameterSpec(java.lang.Class)>(class "Ljava/security/spec/ECParameterSpec;");
specialinvoke v15.<java.security.spec.ECPublicKeySpec: void <init>(java.security.spec.ECPoint,java.security.spec.ECParameterSpec)>(v16, v17);
v18 = virtualinvoke v14.<java.security.KeyFactory: java.security.PublicKey generatePublic(java.security.spec.KeySpec)>(v15);
v0.<io.vertx.ext.auth.impl.jose.JWK: java.security.PublicKey publicKey> = v18;
label1:
v19 = newarray (java.lang.String)[1];
v19[0] = "d";
v20 = staticinvoke <io.vertx.ext.auth.impl.jose.JWK: boolean jsonHasProperties(io.vertx.core.json.JsonObject,java.lang.String[])>(v1, v19);
if v20 == 0 goto label2;
v21 = new java.math.BigInteger;
v22 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("d");
v23 = staticinvoke <io.vertx.ext.auth.impl.Codec: byte[] base64UrlDecode(java.lang.String)>(v22);
specialinvoke v21.<java.math.BigInteger: void <init>(int,byte[])>(1, v23);
v24 = staticinvoke <java.security.KeyFactory: java.security.KeyFactory getInstance(java.lang.String)>("EC");
v25 = new java.security.spec.ECPrivateKeySpec;
v26 = virtualinvoke v2.<java.security.AlgorithmParameters: java.security.spec.AlgorithmParameterSpec getParameterSpec(java.lang.Class)>(class "Ljava/security/spec/ECParameterSpec;");
specialinvoke v25.<java.security.spec.ECPrivateKeySpec: void <init>(java.math.BigInteger,java.security.spec.ECParameterSpec)>(v21, v26);
v27 = virtualinvoke v24.<java.security.KeyFactory: java.security.PrivateKey generatePrivate(java.security.spec.KeySpec)>(v25);
v0.<io.vertx.ext.auth.impl.jose.JWK: java.security.PrivateKey privateKey> = v27;
label2:
return;
}
private void createOKP(io.vertx.core.json.JsonObject) throws java.security.NoSuchAlgorithmException, java.security.spec.InvalidKeySpecException
{
byte[] v14, v18, v19, v26, v30, v33, v35, v38, v39, v43, v46, v47, v5, v8, v9;
io.vertx.ext.auth.impl.jose.JWK v0;
io.vertx.core.json.JsonObject v1;
boolean v24, v3;
java.security.spec.X509EncodedKeySpec v21;
java.security.KeyFactory v20, v48;
io.vertx.core.buffer.Buffer v10, v11, v15, v16, v17, v27, v28, v31, v32, v34, v36, v40, v41, v44, v45, v6;
java.security.PrivateKey v50;
java.lang.String[] v2, v23;
int v12, v13, v29, v42;
java.lang.String v25, v37, v4, v7;
java.security.spec.PKCS8EncodedKeySpec v49;
java.security.PublicKey v22;
v0 := @this: io.vertx.ext.auth.impl.jose.JWK;
v1 := @parameter0: io.vertx.core.json.JsonObject;
v2 = newarray (java.lang.String)[1];
v2[0] = "x";
v3 = staticinvoke <io.vertx.ext.auth.impl.jose.JWK: boolean jsonHasProperties(io.vertx.core.json.JsonObject,java.lang.String[])>(v1, v2);
if v3 == 0 goto label1;
v4 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("x");
v5 = staticinvoke <io.vertx.ext.auth.impl.Codec: byte[] base64UrlDecode(java.lang.String)>(v4);
v6 = staticinvoke <io.vertx.core.buffer.Buffer: io.vertx.core.buffer.Buffer buffer()>();
v7 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("crv");
v8 = staticinvoke <io.vertx.ext.auth.impl.jose.JWK: byte[] oidCrv(java.lang.String)>(v7);
v9 = staticinvoke <io.vertx.ext.auth.impl.asn.ASN1: byte[] sequence(byte[])>(v8);
v10 = interfaceinvoke v6.<io.vertx.core.buffer.Buffer: io.vertx.core.buffer.Buffer appendBytes(byte[])>(v9);
v11 = interfaceinvoke v10.<io.vertx.core.buffer.Buffer: io.vertx.core.buffer.Buffer appendByte(byte)>(3);
v12 = lengthof v5;
v13 = v12 + 1;
v14 = staticinvoke <io.vertx.ext.auth.impl.asn.ASN1: byte[] length(int)>(v13);
v15 = interfaceinvoke v11.<io.vertx.core.buffer.Buffer: io.vertx.core.buffer.Buffer appendBytes(byte[])>(v14);
v16 = interfaceinvoke v15.<io.vertx.core.buffer.Buffer: io.vertx.core.buffer.Buffer appendByte(byte)>(0);
v17 = interfaceinvoke v16.<io.vertx.core.buffer.Buffer: io.vertx.core.buffer.Buffer appendBytes(byte[])>(v5);
v18 = interfaceinvoke v17.<io.vertx.core.buffer.Buffer: byte[] getBytes()>();
v19 = staticinvoke <io.vertx.ext.auth.impl.asn.ASN1: byte[] sequence(byte[])>(v18);
v20 = staticinvoke <java.security.KeyFactory: java.security.KeyFactory getInstance(java.lang.String)>("EdDSA");
v21 = new java.security.spec.X509EncodedKeySpec;
specialinvoke v21.<java.security.spec.X509EncodedKeySpec: void <init>(byte[])>(v19);
v22 = virtualinvoke v20.<java.security.KeyFactory: java.security.PublicKey generatePublic(java.security.spec.KeySpec)>(v21);
v0.<io.vertx.ext.auth.impl.jose.JWK: java.security.PublicKey publicKey> = v22;
label1:
v23 = newarray (java.lang.String)[1];
v23[0] = "d";
v24 = staticinvoke <io.vertx.ext.auth.impl.jose.JWK: boolean jsonHasProperties(io.vertx.core.json.JsonObject,java.lang.String[])>(v1, v23);
if v24 == 0 goto label2;
v25 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("d");
v26 = staticinvoke <io.vertx.ext.auth.impl.Codec: byte[] base64UrlDecode(java.lang.String)>(v25);
v27 = staticinvoke <io.vertx.core.buffer.Buffer: io.vertx.core.buffer.Buffer buffer()>();
v28 = interfaceinvoke v27.<io.vertx.core.buffer.Buffer: io.vertx.core.buffer.Buffer appendByte(byte)>(4);
v29 = lengthof v26;
v30 = staticinvoke <io.vertx.ext.auth.impl.asn.ASN1: byte[] length(int)>(v29);
v31 = interfaceinvoke v28.<io.vertx.core.buffer.Buffer: io.vertx.core.buffer.Buffer appendBytes(byte[])>(v30);
v32 = interfaceinvoke v31.<io.vertx.core.buffer.Buffer: io.vertx.core.buffer.Buffer appendBytes(byte[])>(v26);
v33 = interfaceinvoke v32.<io.vertx.core.buffer.Buffer: byte[] getBytes()>();
v34 = staticinvoke <io.vertx.core.buffer.Buffer: io.vertx.core.buffer.Buffer buffer()>();
v35 = newarray (byte)[3];
v35[0] = 2;
v35[1] = 1;
v35[2] = 0;
v36 = interfaceinvoke v34.<io.vertx.core.buffer.Buffer: io.vertx.core.buffer.Buffer appendBytes(byte[])>(v35);
v37 = virtualinvoke v1.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("crv");
v38 = staticinvoke <io.vertx.ext.auth.impl.jose.JWK: byte[] oidCrv(java.lang.String)>(v37);
v39 = staticinvoke <io.vertx.ext.auth.impl.asn.ASN1: byte[] sequence(byte[])>(v38);
v40 = interfaceinvoke v36.<io.vertx.core.buffer.Buffer: io.vertx.core.buffer.Buffer appendBytes(byte[])>(v39);
v41 = interfaceinvoke v40.<io.vertx.core.buffer.Buffer: io.vertx.core.buffer.Buffer appendByte(byte)>(4);
v42 = lengthof v33;
v43 = staticinvoke <io.vertx.ext.auth.impl.asn.ASN1: byte[] length(int)>(v42);
v44 = interfaceinvoke v41.<io.vertx.core.buffer.Buffer: io.vertx.core.buffer.Buffer appendBytes(byte[])>(v43);
v45 = interfaceinvoke v44.<io.vertx.core.buffer.Buffer: io.vertx.core.buffer.Buffer appendBytes(byte[])>(v33);
v46 = interfaceinvoke v45.<io.vertx.core.buffer.Buffer: byte[] getBytes()>();
v47 = staticinvoke <io.vertx.ext.auth.impl.asn.ASN1: byte[] sequence(byte[])>(v46);
v48 = staticinvoke <java.security.KeyFactory: java.security.KeyFactory getInstance(java.lang.String)>("EdDSA");
v49 = new java.security.spec.PKCS8EncodedKeySpec;
specialinvoke v49.<java.security.spec.PKCS8EncodedKeySpec: void <init>(byte[])>(v47);
v50 = virtualinvoke v48.<java.security.KeyFactory: java.security.PrivateKey generatePrivate(java.security.spec.KeySpec)>(v49);
v0.<io.vertx.ext.auth.impl.jose.JWK: java.security.PrivateKey privateKey> = v50;
label2:
return;
}
private void createOCT(java.lang.String, io.vertx.core.json.JsonObject) throws java.security.NoSuchAlgorithmException, java.security.InvalidKeyException
{
byte[] v7;
io.vertx.ext.auth.impl.jose.JWK v0;
javax.crypto.Mac v3, v4;
javax.crypto.spec.SecretKeySpec v5;
io.vertx.core.json.JsonObject v2;
java.lang.String v1, v6;
v0 := @this: io.vertx.ext.auth.impl.jose.JWK;
v1 := @parameter0: java.lang.String;
v2 := @parameter1: io.vertx.core.json.JsonObject;
v3 = staticinvoke <javax.crypto.Mac: javax.crypto.Mac getInstance(java.lang.String)>(v1);
v0.<io.vertx.ext.auth.impl.jose.JWK: javax.crypto.Mac mac> = v3;
v4 = v0.<io.vertx.ext.auth.impl.jose.JWK: javax.crypto.Mac mac>;
v5 = new javax.crypto.spec.SecretKeySpec;
v6 = virtualinvoke v2.<io.vertx.core.json.JsonObject: java.lang.String getString(java.lang.String)>("k");
v7 = staticinvoke <io.vertx.ext.auth.impl.Codec: byte[] base64UrlDecode(java.lang.String)>(v6);
specialinvoke v5.<javax.crypto.spec.SecretKeySpec: void <init>(byte[],java.lang.String)>(v7, v1);
virtualinvoke v4.<javax.crypto.Mac: void init(java.security.Key)>(v5);
return;
}
public java.lang.String getAlgorithm()
{
io.vertx.ext.auth.impl.jose.JWK v0;
java.lang.String v1;
v0 := @this: io.vertx.ext.auth.impl.jose.JWK;
v1 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String alg>;
return v1;
}
public java.lang.String getId()
{
io.vertx.ext.auth.impl.jose.JWK v0;
java.lang.String v1;
v0 := @this: io.vertx.ext.auth.impl.jose.JWK;
v1 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kid>;
return v1;
}
private static java.lang.String translateECCrv(java.lang.String)
{
java.lang.IllegalArgumentException v7;
byte v1;
int v2;
java.lang.String v0, v8;
boolean v3, v4, v5, v6;
v0 := @parameter0: java.lang.String;
v1 = -1;
v2 = virtualinvoke v0.<java.lang.String: int hashCode()>();
lookupswitch(v2)
{
case -845821990: goto label04;
case 75272022: goto label01;
case 75273074: goto label02;
case 75274807: goto label03;
default: goto label05;
};
label01:
v3 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("P-256");
if v3 == 0 goto label05;
v1 = 0;
goto label05;
label02:
v4 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("P-384");
if v4 == 0 goto label05;
v1 = 1;
goto label05;
label03:
v5 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("P-521");
if v5 == 0 goto label05;
v1 = 2;
goto label05;
label04:
v6 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("secp256k1");
if v6 == 0 goto label05;
v1 = 3;
label05:
tableswitch(v1)
{
case 0: goto label06;
case 1: goto label07;
case 2: goto label08;
case 3: goto label09;
default: goto label10;
};
label06:
return "secp256r1";
label07:
return "secp384r1";
label08:
return "secp521r1";
label09:
return "secp256k1";
label10:
v7 = new java.lang.IllegalArgumentException;
v8 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v0) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Unsupported {crv}: \u0001");
specialinvoke v7.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(v8);
throw v7;
}
private static byte[] oidCrv(java.lang.String)
{
byte[] v10, v7, v8, v9;
java.lang.IllegalArgumentException v11;
byte v1;
int v2;
java.lang.String v0, v12;
boolean v3, v4, v5, v6;
v0 := @parameter0: java.lang.String;
v1 = -1;
v2 = virtualinvoke v0.<java.lang.String: int hashCode()>();
lookupswitch(v2)
{
case -1727794526: goto label03;
case -276032869: goto label01;
case 2673248: goto label04;
case 66753689: goto label02;
default: goto label05;
};
label01:
v3 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("Ed25519");
if v3 == 0 goto label05;
v1 = 0;
goto label05;
label02:
v4 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("Ed448");
if v4 == 0 goto label05;
v1 = 1;
goto label05;
label03:
v5 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("X25519");
if v5 == 0 goto label05;
v1 = 2;
goto label05;
label04:
v6 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("X448");
if v6 == 0 goto label05;
v1 = 3;
label05:
tableswitch(v1)
{
case 0: goto label06;
case 1: goto label07;
case 2: goto label08;
case 3: goto label09;
default: goto label10;
};
label06:
v7 = newarray (byte)[5];
v7[0] = 6;
v7[1] = 3;
v7[2] = 43;
v7[3] = 101;
v7[4] = 112;
return v7;
label07:
v8 = newarray (byte)[5];
v8[0] = 6;
v8[1] = 3;
v8[2] = 43;
v8[3] = 101;
v8[4] = 113;
return v8;
label08:
v9 = newarray (byte)[5];
v9[0] = 6;
v9[1] = 3;
v9[2] = 43;
v9[3] = 101;
v9[4] = 110;
return v9;
label09:
v10 = newarray (byte)[5];
v10[0] = 6;
v10[1] = 3;
v10[2] = 43;
v10[3] = 101;
v10[4] = 111;
return v10;
label10:
v11 = new java.lang.IllegalArgumentException;
v12 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v0) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Unsupported {crv}: \u0001");
specialinvoke v11.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(v12);
throw v11;
}
private static transient boolean jsonHasProperties(io.vertx.core.json.JsonObject, java.lang.String[])
{
int v2, v3;
io.vertx.core.json.JsonObject v0;
java.lang.Object v6;
java.lang.String[] v1;
java.lang.String v4;
boolean v5;
v0 := @parameter0: io.vertx.core.json.JsonObject;
v1 := @parameter1: java.lang.String[];
v2 = lengthof v1;
v3 = 0;
label1:
if v3 >= v2 goto label4;
v4 = v1[v3];
v5 = virtualinvoke v0.<io.vertx.core.json.JsonObject: boolean containsKey(java.lang.String)>(v4);
if v5 == 0 goto label2;
v6 = virtualinvoke v0.<io.vertx.core.json.JsonObject: java.lang.Object getValue(java.lang.String)>(v4);
if v6 != null goto label3;
label2:
return 0;
label3:
v3 = v3 + 1;
goto label1;
label4:
return 1;
}
public java.lang.String use()
{
io.vertx.ext.auth.impl.jose.JWK v0;
java.lang.String v1;
v0 := @this: io.vertx.ext.auth.impl.jose.JWK;
v1 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String use>;
return v1;
}
public java.lang.String label()
{
io.vertx.ext.auth.impl.jose.JWK v0;
java.lang.String v1;
v0 := @this: io.vertx.ext.auth.impl.jose.JWK;
v1 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String label>;
return v1;
}
public java.lang.String kty()
{
io.vertx.ext.auth.impl.jose.JWK v0;
java.lang.String v1;
v0 := @this: io.vertx.ext.auth.impl.jose.JWK;
v1 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kty>;
return v1;
}
public javax.crypto.Mac mac()
{
javax.crypto.Mac v1;
io.vertx.ext.auth.impl.jose.JWK v0;
v0 := @this: io.vertx.ext.auth.impl.jose.JWK;
v1 = v0.<io.vertx.ext.auth.impl.jose.JWK: javax.crypto.Mac mac>;
return v1;
}
public java.security.PublicKey publicKey()
{
java.security.PublicKey v1;
io.vertx.ext.auth.impl.jose.JWK v0;
v0 := @this: io.vertx.ext.auth.impl.jose.JWK;
v1 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.security.PublicKey publicKey>;
return v1;
}
public java.security.PrivateKey privateKey()
{
io.vertx.ext.auth.impl.jose.JWK v0;
java.security.PrivateKey v1;
v0 := @this: io.vertx.ext.auth.impl.jose.JWK;
v1 = v0.<io.vertx.ext.auth.impl.jose.JWK: java.security.PrivateKey privateKey>;
return v1;
}
static void <clinit>()
{
io.vertx.core.impl.logging.Logger v0;
io.vertx.ext.auth.impl.jose.JWK$1 v1;
v0 = staticinvoke <io.vertx.core.impl.logging.LoggerFactory: io.vertx.core.impl.logging.Logger getLogger(java.lang.Class)>(class "Lio/vertx/ext/auth/impl/jose/JWK;");
<io.vertx.ext.auth.impl.jose.JWK: io.vertx.core.impl.logging.Logger LOG> = v0;
v1 = new io.vertx.ext.auth.impl.jose.JWK$1;
specialinvoke v1.<io.vertx.ext.auth.impl.jose.JWK$1: void <init>()>();
<io.vertx.ext.auth.impl.jose.JWK: java.util.Map ALG_ALIAS> = v1;
return;
}
}