public class io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper extends java.lang.Object
{
private void <init>()
{
io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper v0;
v0 := @this: io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper;
specialinvoke v0.<java.lang.Object: void <init>()>();
return;
}
public static boolean hasParentClass(io.vertx.codegen.ClassModel)
{
io.vertx.codegen.type.ClassTypeInfo v4;
io.vertx.codegen.type.TypeInfo v1;
io.vertx.codegen.ClassModel v0;
java.util.List v3, v8;
java.lang.String v5, v9;
boolean v10, v11, v2, v6, v7;
v0 := @parameter0: io.vertx.codegen.ClassModel;
v1 = virtualinvoke v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo getConcreteSuperType()>();
if v1 != null goto label1;
return 0;
label1:
v2 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: boolean isParameterized()>();
if v2 == 0 goto label4;
v3 = <io.smallrye.mutiny.vertx.codegen.MutinyGenerator: java.util.List IGNORED_TYPES>;
v4 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v5 = virtualinvoke v4.<io.vertx.codegen.type.ClassTypeInfo: java.lang.String getName()>();
v6 = interfaceinvoke v3.<java.util.List: boolean contains(java.lang.Object)>(v5);
if v6 != 0 goto label2;
v7 = 1;
goto label3;
label2:
v7 = 0;
label3:
return v7;
label4:
v8 = <io.smallrye.mutiny.vertx.codegen.MutinyGenerator: java.util.List IGNORED_TYPES>;
v9 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: java.lang.String getName()>();
v10 = interfaceinvoke v8.<java.util.List: boolean contains(java.lang.Object)>(v9);
if v10 != 0 goto label5;
v11 = 1;
goto label6;
label5:
v11 = 0;
label6:
return v11;
}
public static io.vertx.codegen.MethodKind methodKind(io.vertx.codegen.MethodInfo)
{
io.vertx.codegen.type.TypeInfo v5;
java.util.List v1, v8;
int v2, v3;
io.vertx.codegen.MethodKind v12, v13, v14;
java.lang.Object v4, v9;
io.vertx.codegen.MethodInfo v0;
io.vertx.codegen.type.ClassKind v10, v11, v6, v7;
v0 := @parameter0: io.vertx.codegen.MethodInfo;
v1 = virtualinvoke v0.<io.vertx.codegen.MethodInfo: java.util.List getParams()>();
v2 = interfaceinvoke v1.<java.util.List: int size()>();
v3 = v2 - 1;
if v3 < 0 goto label2;
v4 = interfaceinvoke v1.<java.util.List: java.lang.Object get(int)>(v3);
v5 = virtualinvoke v4.<io.vertx.codegen.ParamInfo: io.vertx.codegen.type.TypeInfo getType()>();
v6 = virtualinvoke v5.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v7 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind HANDLER>;
if v6 != v7 goto label2;
v8 = virtualinvoke v5.<io.vertx.codegen.type.ParameterizedTypeInfo: java.util.List getArgs()>();
v9 = interfaceinvoke v8.<java.util.List: java.lang.Object get(int)>(0);
v10 = virtualinvoke v9.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v11 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind ASYNC_RESULT>;
if v10 != v11 goto label1;
v12 = <io.vertx.codegen.MethodKind: io.vertx.codegen.MethodKind CALLBACK>;
return v12;
label1:
v13 = <io.vertx.codegen.MethodKind: io.vertx.codegen.MethodKind HANDLER>;
return v13;
label2:
v14 = <io.vertx.codegen.MethodKind: io.vertx.codegen.MethodKind OTHER>;
return v14;
}
public static java.lang.String genTypeName(io.vertx.codegen.type.TypeInfo)
{
java.lang.String v1;
io.vertx.codegen.type.TypeInfo v0;
v0 := @parameter0: io.vertx.codegen.type.TypeInfo;
v1 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTypeName(io.vertx.codegen.type.TypeInfo,boolean)>(v0, 0);
return v1;
}
public static java.lang.String genTranslatedTypeName(io.vertx.codegen.type.TypeInfo)
{
java.lang.String v1;
io.vertx.codegen.type.TypeInfo v0;
v0 := @parameter0: io.vertx.codegen.type.TypeInfo;
v1 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTypeName(io.vertx.codegen.type.TypeInfo,boolean)>(v0, 1);
return v1;
}
protected static boolean isImported(io.vertx.codegen.type.TypeInfo)
{
int[] v1;
io.vertx.codegen.type.TypeInfo v0;
int v3, v4;
io.vertx.codegen.type.ClassKind v2;
v0 := @parameter0: io.vertx.codegen.type.TypeInfo;
v1 = <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper$1: int[] $SwitchMap$io$vertx$codegen$type$ClassKind>;
v2 = virtualinvoke v0.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v3 = virtualinvoke v2.<io.vertx.codegen.type.ClassKind: int ordinal()>();
v4 = v1[v3];
tableswitch(v4)
{
case 1: goto label1;
case 2: goto label1;
case 3: goto label1;
case 4: goto label1;
case 5: goto label1;
case 6: goto label1;
case 7: goto label1;
case 8: goto label1;
case 9: goto label1;
case 10: goto label1;
default: goto label2;
};
label1:
return 1;
label2:
return 0;
}
private static java.lang.String expandInnerTypes(java.lang.String)
{
java.lang.String v0, v1;
v0 := @parameter0: java.lang.String;
v1 = virtualinvoke v0.<java.lang.String: java.lang.String replace(char,char)>(36, 46);
return v1;
}
public static java.lang.String genTypeName(io.vertx.codegen.type.TypeInfo, boolean)
{
java.util.stream.Collector v36;
io.vertx.codegen.type.ClassKind v40, v41;
boolean v1, v12, v17, v2, v22, v45, v54, v58, v7;
io.vertx.codegen.type.TypeInfo v0, v18, v23, v24, v8;
java.util.List v32;
java.util.stream.Stream v33, v35;
java.util.function.Function v34;
java.lang.String v10, v11, v14, v16, v19, v21, v26, v27, v28, v29, v31, v38, v39, v4, v42, v44, v47, v48, v49, v50, v51, v53, v56, v57, v59, v6, v60, v61, v62, v9;
io.vertx.codegen.type.ClassTypeInfo v13, v3, v30;
java.lang.Class v15, v20, v25, v43, v46, v5, v52, v55;
java.lang.Object v37;
v0 := @parameter0: io.vertx.codegen.type.TypeInfo;
v1 := @parameter1: boolean;
if v1 != 0 goto label1;
v2 = virtualinvoke v0.<io.vertx.codegen.type.TypeInfo: boolean isParameterized()>();
if v2 == 0 goto label1;
v3 = virtualinvoke v0.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v4 = virtualinvoke v3.<io.vertx.codegen.type.ClassTypeInfo: java.lang.String getName()>();
v5 = class "Lio/smallrye/mutiny/Uni;";
v6 = virtualinvoke v5.<java.lang.Class: java.lang.String getName()>();
v7 = virtualinvoke v4.<java.lang.String: boolean equals(java.lang.Object)>(v6);
if v7 == 0 goto label1;
v8 = virtualinvoke v0.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(0);
v9 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTypeName(io.vertx.codegen.type.TypeInfo,boolean)>(v8, v1);
v10 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v9) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("io.vertx.core.Future<\u0001>");
v11 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String expandInnerTypes(java.lang.String)>(v10);
return v11;
label1:
v12 = virtualinvoke v0.<io.vertx.codegen.type.TypeInfo: boolean isParameterized()>();
if v12 == 0 goto label3;
if v1 == 0 goto label2;
v13 = virtualinvoke v0.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v14 = virtualinvoke v13.<io.vertx.codegen.type.ClassTypeInfo: java.lang.String getName()>();
v15 = class "Lio/vertx/core/Handler;";
v16 = virtualinvoke v15.<java.lang.Class: java.lang.String getName()>();
v17 = virtualinvoke v14.<java.lang.String: boolean equals(java.lang.Object)>(v16);
if v17 == 0 goto label2;
v18 = virtualinvoke v0.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(0);
v19 = virtualinvoke v18.<io.vertx.codegen.type.TypeInfo: java.lang.String getName()>();
v20 = class "Lio/vertx/core/Promise;";
v21 = virtualinvoke v20.<java.lang.Class: java.lang.String getName()>();
v22 = virtualinvoke v19.<java.lang.String: boolean startsWith(java.lang.String)>(v21);
if v22 == 0 goto label2;
v23 = virtualinvoke v0.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(0);
v24 = virtualinvoke v23.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(0);
v25 = class "Lio/smallrye/mutiny/Uni;";
v26 = virtualinvoke v25.<java.lang.Class: java.lang.String getName()>();
v27 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTypeName(io.vertx.codegen.type.TypeInfo,boolean)>(v24, 1);
v28 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v26, v27) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001<\u0001>");
v29 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String expandInnerTypes(java.lang.String)>(v28);
return v29;
label2:
v30 = virtualinvoke v0.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v31 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTypeName(io.vertx.codegen.type.TypeInfo,boolean)>(v30, v1);
v32 = virtualinvoke v0.<io.vertx.codegen.type.ParameterizedTypeInfo: java.util.List getArgs()>();
v33 = interfaceinvoke v32.<java.util.List: java.util.stream.Stream stream()>();
v34 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper$lambda_genTypeName_0__2373: java.util.function.Function bootstrap$(boolean)>(v1);
v35 = interfaceinvoke v33.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v34);
v36 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)>(", ", "<", ">");
v37 = interfaceinvoke v35.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v36);
v38 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.Object)>(v31, v37) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001\u0001");
v39 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String expandInnerTypes(java.lang.String)>(v38);
return v39;
label3:
v40 = virtualinvoke v0.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v41 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind API>;
if v40 != v41 goto label5;
if v1 == 0 goto label6;
v42 = virtualinvoke v0.<io.vertx.codegen.type.TypeInfo: java.lang.String getName()>();
v43 = class "Lio/vertx/core/Future;";
v44 = virtualinvoke v43.<java.lang.Class: java.lang.String getName()>();
v45 = virtualinvoke v42.<java.lang.String: boolean equals(java.lang.Object)>(v44);
if v45 == 0 goto label4;
v46 = class "Lio/smallrye/mutiny/Uni;";
v47 = virtualinvoke v46.<java.lang.Class: java.lang.String getName()>();
v48 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String expandInnerTypes(java.lang.String)>(v47);
return v48;
label4:
v49 = virtualinvoke v0.<io.vertx.codegen.type.TypeInfo: java.lang.String translateName(java.lang.String)>("mutiny");
v50 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String expandInnerTypes(java.lang.String)>(v49);
return v50;
label5:
if v1 == 0 goto label6;
v51 = virtualinvoke v0.<io.vertx.codegen.type.TypeInfo: java.lang.String getName()>();
v52 = class "Lio/vertx/core/Future;";
v53 = virtualinvoke v52.<java.lang.Class: java.lang.String getName()>();
v54 = virtualinvoke v51.<java.lang.String: boolean equals(java.lang.Object)>(v53);
if v54 == 0 goto label6;
v55 = class "Lio/smallrye/mutiny/Uni;";
v56 = virtualinvoke v55.<java.lang.Class: java.lang.String getName()>();
v57 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String expandInnerTypes(java.lang.String)>(v56);
return v57;
label6:
v58 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: boolean isImported(io.vertx.codegen.type.TypeInfo)>(v0);
if v58 == 0 goto label7;
v59 = virtualinvoke v0.<io.vertx.codegen.type.TypeInfo: java.lang.String getSimpleName()>();
v60 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String expandInnerTypes(java.lang.String)>(v59);
return v60;
label7:
v61 = virtualinvoke v0.<io.vertx.codegen.type.TypeInfo: java.lang.String getName()>();
v62 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String expandInnerTypes(java.lang.String)>(v61);
return v62;
}
private static boolean isSameType(io.vertx.codegen.type.TypeInfo, io.vertx.codegen.MethodInfo)
{
io.vertx.codegen.type.ClassKind v10, v15, v16, v17, v2, v20, v23, v26, v6, v7, v8, v9;
boolean v11, v12, v13, v14, v19, v22, v25, v28, v3, v30, v31, v4, v5;
io.vertx.codegen.type.TypeInfo v0, v18, v21, v24, v27, v29;
io.vertx.codegen.MethodInfo v1;
v0 := @parameter0: io.vertx.codegen.type.TypeInfo;
v1 := @parameter1: io.vertx.codegen.MethodInfo;
v2 = virtualinvoke v0.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v3 = virtualinvoke v0.<io.vertx.codegen.type.TypeInfo: boolean isDataObjectHolder()>();
if v3 != 0 goto label01;
v4 = v2.<io.vertx.codegen.type.ClassKind: boolean basic>;
if v4 != 0 goto label01;
v5 = v2.<io.vertx.codegen.type.ClassKind: boolean json>;
if v5 != 0 goto label01;
v6 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind ENUM>;
if v2 == v6 goto label01;
v7 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind OTHER>;
if v2 == v7 goto label01;
v8 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind THROWABLE>;
if v2 == v8 goto label01;
v9 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind VOID>;
if v2 != v9 goto label02;
label01:
return 1;
label02:
v10 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind OBJECT>;
if v2 != v10 goto label06;
v11 = virtualinvoke v0.<io.vertx.codegen.type.TypeInfo: boolean isVariable()>();
if v11 == 0 goto label05;
v12 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: boolean isReified(io.vertx.codegen.type.TypeVariableInfo,io.vertx.codegen.MethodInfo)>(v0, v1);
if v12 != 0 goto label03;
v13 = 1;
goto label04;
label03:
v13 = 0;
label04:
return v13;
label05:
return 1;
label06:
v14 = virtualinvoke v0.<io.vertx.codegen.type.TypeInfo: boolean isParameterized()>();
if v14 == 0 goto label13;
v15 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind LIST>;
if v2 == v15 goto label07;
v16 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind SET>;
if v2 == v16 goto label07;
v17 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind ASYNC_RESULT>;
if v2 != v17 goto label08;
label07:
v18 = virtualinvoke v0.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(0);
v19 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: boolean isSameType(io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo)>(v18, v1);
return v19;
label08:
v20 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind MAP>;
if v2 != v20 goto label09;
v21 = virtualinvoke v0.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(1);
v22 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: boolean isSameType(io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo)>(v21, v1);
return v22;
label09:
v23 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind HANDLER>;
if v2 != v23 goto label10;
v24 = virtualinvoke v0.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(0);
v25 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: boolean isSameType(io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo)>(v24, v1);
return v25;
label10:
v26 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind FUNCTION>;
if v2 != v26 goto label13;
v27 = virtualinvoke v0.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(0);
v28 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: boolean isSameType(io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo)>(v27, v1);
if v28 == 0 goto label11;
v29 = virtualinvoke v0.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(1);
v30 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: boolean isSameType(io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo)>(v29, v1);
if v30 == 0 goto label11;
v31 = 1;
goto label12;
label11:
v31 = 0;
label12:
return v31;
label13:
return 0;
}
public static java.lang.String genConvParam(java.util.Map, io.vertx.codegen.type.TypeInfo, io.vertx.codegen.MethodInfo, java.lang.String)
{
java.util.Map v0;
java.lang.String v11, v12, v13, v16, v18, v23, v24, v27, v29, v3, v33, v35, v37, v42, v43, v44, v46, v49, v50, v57, v58, v6, v61, v63, v65, v66, v67, v68, v69, v73, v75, v76, v77, v78, v79, v8, v80, v81, v82, v86, v88, v89, v92, v93, v96, v97;
io.vertx.codegen.type.ClassTypeInfo v15, v26, v32, v5, v60, v87;
io.vertx.codegen.type.ClassKind v21, v22, v38, v40, v45, v47, v52, v54, v55, v70, v83, v84, v90, v94;
boolean v14, v19, v25, v30, v36, v39, v4, v41, v51, v59, v64, v74, v9;
io.vertx.codegen.type.TypeInfo v1, v10, v20, v31, v53, v56, v71, v72, v85, v91, v95;
java.lang.Class v17, v28, v34, v48, v62, v7;
io.vertx.codegen.MethodInfo v2;
v0 := @parameter0: java.util.Map;
v1 := @parameter1: io.vertx.codegen.type.TypeInfo;
v2 := @parameter2: io.vertx.codegen.MethodInfo;
v3 := @parameter3: java.lang.String;
v4 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: boolean isParameterized()>();
if v4 == 0 goto label01;
v5 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v6 = virtualinvoke v5.<io.vertx.codegen.type.ClassTypeInfo: java.lang.String getName()>();
v7 = class "Lio/smallrye/mutiny/Multi;";
v8 = virtualinvoke v7.<java.lang.Class: java.lang.String getName()>();
v9 = virtualinvoke v6.<java.lang.String: boolean equals(java.lang.Object)>(v8);
if v9 == 0 goto label01;
v10 = virtualinvoke v1.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(0);
v11 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genConvParam(java.util.Map,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo,java.lang.String)>(v0, v10, v2, "obj");
v12 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v11) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("obj -> \u0001");
v13 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v3, v12) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("io.smallrye.mutiny.vertx.ReadStreamSubscriber.asReadStream(\u0001, \u0001).resume()");
return v13;
label01:
v14 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: boolean isParameterized()>();
if v14 == 0 goto label03;
v15 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v16 = virtualinvoke v15.<io.vertx.codegen.type.ClassTypeInfo: java.lang.String getName()>();
v17 = class "Lio/vertx/core/Future;";
v18 = virtualinvoke v17.<java.lang.Class: java.lang.String getName()>();
v19 = virtualinvoke v16.<java.lang.String: boolean equals(java.lang.Object)>(v18);
if v19 == 0 goto label03;
v20 = virtualinvoke v1.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(0);
v21 = virtualinvoke v20.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v22 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind API>;
if v21 != v22 goto label02;
v23 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v3) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("io.smallrye.mutiny.vertx.UniHelper.toFuture(\u0001.map(r -> r.getDelegate()))");
return v23;
label02:
v24 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v3) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("io.smallrye.mutiny.vertx.UniHelper.toFuture(\u0001)");
return v24;
label03:
v25 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: boolean isParameterized()>();
if v25 == 0 goto label04;
v26 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v27 = virtualinvoke v26.<io.vertx.codegen.type.ClassTypeInfo: java.lang.String getName()>();
v28 = class "Ljava/util/function/Supplier;";
v29 = virtualinvoke v28.<java.lang.Class: java.lang.String getName()>();
v30 = virtualinvoke v27.<java.lang.String: boolean equals(java.lang.Object)>(v29);
if v30 == 0 goto label04;
v31 = virtualinvoke v1.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(0);
v32 = virtualinvoke v31.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v33 = virtualinvoke v32.<io.vertx.codegen.type.ClassTypeInfo: java.lang.String getName()>();
v34 = class "Lio/vertx/core/Future;";
v35 = virtualinvoke v34.<java.lang.Class: java.lang.String getName()>();
v36 = virtualinvoke v33.<java.lang.String: boolean equals(java.lang.Object)>(v35);
if v36 == 0 goto label04;
v37 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v3) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("() -> io.smallrye.mutiny.vertx.UniHelper.toFuture(\u0001.get())");
return v37;
label04:
v38 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v39 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: boolean isSameType(io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo)>(v1, v2);
if v39 == 0 goto label05;
return v3;
label05:
v40 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind OBJECT>;
if v38 != v40 goto label07;
v41 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: boolean isVariable()>();
if v41 == 0 goto label06;
v42 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTypeArg(io.vertx.codegen.type.TypeVariableInfo,io.vertx.codegen.MethodInfo)>(v1, v2);
if v42 == null goto label06;
v43 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: java.lang.String getName()>();
v44 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String,java.lang.String)>(v42, v43, v3) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001.<\u0001>unwrap(\u0001)");
return v44;
label06:
return v3;
label07:
v45 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind API>;
if v38 != v45 goto label08;
v46 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v3) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001.getDelegate()");
return v46;
label08:
v47 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind CLASS_TYPE>;
if v38 != v47 goto label09;
v48 = class "Lio/smallrye/mutiny/vertx/MutinyHelper;";
v49 = virtualinvoke v48.<java.lang.Class: java.lang.String getName()>();
v50 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v49, v3) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001.unwrap(\u0001)");
return v50;
label09:
v51 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: boolean isParameterized()>();
if v51 == 0 goto label18;
v52 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind HANDLER>;
if v38 != v52 goto label12;
v53 = virtualinvoke v1.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(0);
v54 = virtualinvoke v53.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v55 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind ASYNC_RESULT>;
if v54 != v55 goto label10;
v56 = virtualinvoke v53.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(0);
v57 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genConvReturn(java.util.Map,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo,java.lang.String)>(v0, v56, v2, "event");
v58 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v3, v57) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("new io.smallrye.mutiny.vertx.DelegatingHandler<>(\u0001, ar -> ar.map(event -> \u0001))");
return v58;
label10:
v59 = virtualinvoke v53.<io.vertx.codegen.type.TypeInfo: boolean isParameterized()>();
if v59 == 0 goto label11;
v60 = virtualinvoke v53.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v61 = virtualinvoke v60.<io.vertx.codegen.type.ClassTypeInfo: java.lang.String getName()>();
v62 = class "Lio/vertx/core/Promise;";
v63 = virtualinvoke v62.<java.lang.Class: java.lang.String getName()>();
v64 = virtualinvoke v61.<java.lang.String: boolean equals(java.lang.Object)>(v63);
if v64 == 0 goto label11;
v65 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTypeName(io.vertx.codegen.type.TypeInfo)>(v53);
v66 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTypeName(io.vertx.codegen.type.TypeInfo)>(v53);
v67 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String,java.lang.String)>(v65, v66, v3) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("new Handler<\u0001>() {\n          public void handle(\u0001 event) {\n            \u0001.subscribe().with(it -> event.complete(it), failure -> event.fail(failure));\n          }\n      }");
return v67;
label11:
v68 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genConvReturn(java.util.Map,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo,java.lang.String)>(v0, v53, v2, "event");
v69 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v3, v68) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("new io.smallrye.mutiny.vertx.DelegatingHandler<>(\u0001, event -> \u0001)");
return v69;
label12:
v70 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind FUNCTION>;
if v38 != v70 goto label14;
v71 = virtualinvoke v1.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(0);
v72 = virtualinvoke v1.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(1);
v73 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTranslatedTypeName(io.vertx.codegen.type.TypeInfo)>(v72);
v74 = virtualinvoke v73.<java.lang.String: boolean startsWith(java.lang.String)>("io.smallrye.mutiny.Uni<");
if v74 == 0 goto label13;
v75 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String generatingAFunctionReturningAFuture(java.util.Map,io.vertx.codegen.MethodInfo,java.lang.String,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.type.TypeInfo)>(v0, v2, v3, v71, v72);
return v75;
label13:
v76 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTypeName(io.vertx.codegen.type.TypeInfo)>(v71);
v77 = virtualinvoke v72.<io.vertx.codegen.type.TypeInfo: java.lang.String getName()>();
v78 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTypeName(io.vertx.codegen.type.TypeInfo)>(v72);
v79 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTypeName(io.vertx.codegen.type.TypeInfo)>(v71);
v80 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genConvReturn(java.util.Map,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo,java.lang.String)>(v0, v71, v2, "arg");
v81 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genConvParam(java.util.Map,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo,java.lang.String)>(v0, v72, v2, "ret");
v82 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>(v76, v77, v78, v79, v73, v3, v80, v81) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("new java.util.function.Function<\u0001,\u0001>() {\n      public \u0001 apply(\u0001 arg) {\n        \u0001 ret = \u0001.apply(\u0001);\n        return \u0001;\n      }\n    }");
return v82;
label14:
v83 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind LIST>;
if v38 == v83 goto label15;
v84 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind SET>;
if v38 != v84 goto label16;
label15:
v85 = virtualinvoke v1.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(0);
v86 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genConvParam(java.util.Map,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo,java.lang.String)>(v0, v85, v2, "elt");
v87 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v88 = virtualinvoke v87.<io.vertx.codegen.type.ClassTypeInfo: java.lang.String getSimpleName()>();
v89 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String,java.lang.String)>(v3, v86, v88) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001.stream().map(elt -> \u0001).collect(java.util.stream.Collectors.to\u0001())");
return v89;
label16:
v90 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind MAP>;
if v38 != v90 goto label17;
v91 = virtualinvoke v1.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(1);
v92 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genConvParam(java.util.Map,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo,java.lang.String)>(v0, v91, v2, "e.getValue()");
v93 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v3, v92) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001.entrySet().stream().collect(java.util.stream.Collectors.toMap(e -> e.getKey(), e -> \u0001))");
return v93;
label17:
v94 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind FUTURE>;
if v38 != v94 goto label18;
v95 = virtualinvoke v1.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(0);
v96 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genConvParam(java.util.Map,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo,java.lang.String)>(v0, v95, v2, "val");
v97 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v3, v96) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001.map(val -> \u0001)");
return v97;
label18:
return v3;
}
private static java.lang.String generatingAFunctionReturningAFuture(java.util.Map, io.vertx.codegen.MethodInfo, java.lang.String, io.vertx.codegen.type.TypeInfo, io.vertx.codegen.type.TypeInfo)
{
java.util.Map v0;
java.lang.String v12, v13, v14, v15, v16, v17, v18, v19, v2, v20, v21, v22, v23;
io.vertx.codegen.type.ClassKind v10, v6, v7, v9;
boolean v11, v5;
io.vertx.codegen.type.TypeInfo v3, v4, v8;
io.vertx.codegen.MethodInfo v1;
v0 := @parameter0: java.util.Map;
v1 := @parameter1: io.vertx.codegen.MethodInfo;
v2 := @parameter2: java.lang.String;
v3 := @parameter3: io.vertx.codegen.type.TypeInfo;
v4 := @parameter4: io.vertx.codegen.type.TypeInfo;
v5 = 0;
v6 = virtualinvoke v4.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v7 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind FUTURE>;
if v6 != v7 goto label3;
v8 = virtualinvoke v4.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(0);
v9 = virtualinvoke v8.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v10 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind API>;
if v9 != v10 goto label1;
v11 = 1;
goto label2;
label1:
v11 = 0;
label2:
v5 = v11;
label3:
if v5 == 0 goto label4;
v12 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTypeName(io.vertx.codegen.type.TypeInfo)>(v3);
v13 = virtualinvoke v4.<io.vertx.codegen.type.TypeInfo: java.lang.String getName()>();
v14 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTypeName(io.vertx.codegen.type.TypeInfo)>(v4);
v15 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTypeName(io.vertx.codegen.type.TypeInfo)>(v3);
v16 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genConvReturn(java.util.Map,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo,java.lang.String)>(v0, v3, v1, "arg");
v17 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>(v12, v13, v14, v15, v2, v16) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("new java.util.function.Function<\u0001,\u0001>() {\n      public \u0001 apply(\u0001 arg) {\n            return io.smallrye.mutiny.vertx.UniHelper.toFuture(\n                 \u0001.apply(\u0001).map(x -> x.getDelegate())\n            );\n         }\n     }");
return v17;
label4:
v18 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTypeName(io.vertx.codegen.type.TypeInfo)>(v3);
v19 = virtualinvoke v4.<io.vertx.codegen.type.TypeInfo: java.lang.String getName()>();
v20 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTypeName(io.vertx.codegen.type.TypeInfo)>(v4);
v21 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTypeName(io.vertx.codegen.type.TypeInfo)>(v3);
v22 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genConvReturn(java.util.Map,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo,java.lang.String)>(v0, v3, v1, "arg");
v23 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>(v18, v19, v20, v21, v2, v22) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("new java.util.function.Function<\u0001,\u0001>() {\n      public \u0001 apply(\u0001 arg) {\n            return io.smallrye.mutiny.vertx.UniHelper.toFuture(\n                 \u0001.apply(\u0001)\n            );\n         }\n     }");
return v23;
}
private static boolean isReified(io.vertx.codegen.type.TypeVariableInfo, io.vertx.codegen.MethodInfo)
{
io.vertx.codegen.TypeArgExpression v3;
io.vertx.codegen.MethodInfo v1;
io.vertx.codegen.type.TypeVariableInfo v0;
boolean v2, v4, v5;
v0 := @parameter0: io.vertx.codegen.type.TypeVariableInfo;
v1 := @parameter1: io.vertx.codegen.MethodInfo;
v2 = virtualinvoke v0.<io.vertx.codegen.type.TypeVariableInfo: boolean isClassParam()>();
if v2 == 0 goto label1;
return 1;
label1:
v3 = virtualinvoke v1.<io.vertx.codegen.MethodInfo: io.vertx.codegen.TypeArgExpression resolveTypeArg(io.vertx.codegen.type.TypeVariableInfo)>(v0);
if v3 == null goto label2;
v4 = virtualinvoke v3.<io.vertx.codegen.TypeArgExpression: boolean isClassType()>();
if v4 == 0 goto label2;
v5 = 1;
goto label3;
label2:
v5 = 0;
label3:
return v5;
}
private static java.lang.String genTypeArg(io.vertx.codegen.type.TypeVariableInfo, io.vertx.codegen.MethodInfo)
{
io.vertx.codegen.ParamInfo v10, v13;
io.vertx.codegen.TypeParamInfo v3;
int v15, v4;
java.lang.String v11, v12, v14, v16, v5, v9;
io.vertx.codegen.type.TypeVariableInfo v0;
boolean v2, v7;
io.vertx.codegen.TypeArgExpression v6;
java.lang.Class v8;
io.vertx.codegen.MethodInfo v1;
v0 := @parameter0: io.vertx.codegen.type.TypeVariableInfo;
v1 := @parameter1: io.vertx.codegen.MethodInfo;
v2 = virtualinvoke v0.<io.vertx.codegen.type.TypeVariableInfo: boolean isClassParam()>();
if v2 == 0 goto label1;
v3 = virtualinvoke v0.<io.vertx.codegen.type.TypeVariableInfo: io.vertx.codegen.TypeParamInfo getParam()>();
v4 = virtualinvoke v3.<io.vertx.codegen.TypeParamInfo: int getIndex()>();
v5 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (int)>(v4) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("__typeArg_\u0001");
return v5;
label1:
v6 = virtualinvoke v1.<io.vertx.codegen.MethodInfo: io.vertx.codegen.TypeArgExpression resolveTypeArg(io.vertx.codegen.type.TypeVariableInfo)>(v0);
if v6 == null goto label3;
v7 = virtualinvoke v6.<io.vertx.codegen.TypeArgExpression: boolean isClassType()>();
if v7 == 0 goto label2;
v8 = class "Lio/smallrye/mutiny/vertx/TypeArg;";
v9 = virtualinvoke v8.<java.lang.Class: java.lang.String getName()>();
v10 = virtualinvoke v6.<io.vertx.codegen.TypeArgExpression: io.vertx.codegen.ParamInfo getParam()>();
v11 = virtualinvoke v10.<io.vertx.codegen.ParamInfo: java.lang.String getName()>();
v12 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v9, v11) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001.of(\u0001)");
return v12;
label2:
v13 = virtualinvoke v6.<io.vertx.codegen.TypeArgExpression: io.vertx.codegen.ParamInfo getParam()>();
v14 = virtualinvoke v13.<io.vertx.codegen.ParamInfo: java.lang.String getName()>();
v15 = virtualinvoke v6.<io.vertx.codegen.TypeArgExpression: int getIndex()>();
v16 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,int)>(v14, v15) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001.__typeArg_\u0001");
return v16;
label3:
return null;
}
public static void genTypeArg(io.vertx.codegen.type.TypeInfo, io.vertx.codegen.MethodInfo, int, java.lang.StringBuilder)
{
io.vertx.codegen.type.ClassKind v29, v4, v5;
boolean v18, v30;
io.vertx.codegen.type.TypeInfo v0;
java.util.List v19;
java.lang.StringBuilder v10, v13, v14, v16, v17, v24, v25, v26, v27, v3, v6, v8, v9;
int v2, v20, v21, v23;
java.lang.String v12, v28, v31, v7;
io.vertx.codegen.type.ClassTypeInfo v11, v15;
java.lang.Object v22;
io.vertx.codegen.MethodInfo v1;
v0 := @parameter0: io.vertx.codegen.type.TypeInfo;
v1 := @parameter1: io.vertx.codegen.MethodInfo;
v2 := @parameter2: int;
v3 := @parameter3: java.lang.StringBuilder;
v4 = virtualinvoke v0.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v5 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind API>;
if v4 != v5 goto label3;
v6 = virtualinvoke v3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("new TypeArg<");
v7 = virtualinvoke v0.<io.vertx.codegen.type.TypeInfo: java.lang.String translateName(java.lang.String)>("mutiny");
v8 = virtualinvoke v6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(v7);
v9 = virtualinvoke v8.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(">(o");
v10 = virtualinvoke v9.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(v2);
virtualinvoke v10.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" -> ");
v11 = virtualinvoke v0.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v12 = virtualinvoke v11.<io.vertx.codegen.type.ClassTypeInfo: java.lang.String translateName(java.lang.String)>("mutiny");
v13 = virtualinvoke v3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(v12);
v14 = virtualinvoke v13.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(".newInstance((");
v15 = virtualinvoke v0.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v16 = virtualinvoke v14.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>(v15);
v17 = virtualinvoke v16.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(")o");
virtualinvoke v17.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(v2);
v18 = v0 instanceof io.vertx.codegen.type.ParameterizedTypeInfo;
if v18 == 0 goto label2;
v19 = virtualinvoke v0.<io.vertx.codegen.type.ParameterizedTypeInfo: java.util.List getArgs()>();
v20 = 0;
label1:
v21 = interfaceinvoke v19.<java.util.List: int size()>();
if v20 >= v21 goto label2;
virtualinvoke v3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(", ");
v22 = interfaceinvoke v19.<java.util.List: java.lang.Object get(int)>(v20);
v23 = v2 + 1;
staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: void genTypeArg(io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo,int,java.lang.StringBuilder)>(v22, v1, v23, v3);
v20 = v20 + 1;
goto label1;
label2:
virtualinvoke v3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(")");
v24 = virtualinvoke v3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(", o");
v25 = virtualinvoke v24.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(v2);
v26 = virtualinvoke v25.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" -> o");
v27 = virtualinvoke v26.<java.lang.StringBuilder: java.lang.StringBuilder append(int)>(v2);
virtualinvoke v27.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(".getDelegate())");
goto label5;
label3:
v28 = "TypeArg.unknown()";
v29 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind OBJECT>;
if v4 != v29 goto label4;
v30 = virtualinvoke v0.<io.vertx.codegen.type.TypeInfo: boolean isVariable()>();
if v30 == 0 goto label4;
v31 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTypeArg(io.vertx.codegen.type.TypeVariableInfo,io.vertx.codegen.MethodInfo)>(v0, v1);
if v31 == null goto label4;
v28 = v31;
label4:
virtualinvoke v3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(v28);
label5:
return;
}
private static java.lang.String genTypeArg(java.util.Map, io.vertx.codegen.type.TypeInfo, io.vertx.codegen.MethodInfo)
{
io.vertx.codegen.type.TypeInfo v1;
java.util.Map v0;
java.lang.Object v3, v4;
java.lang.StringBuilder v5;
java.lang.String v6;
io.vertx.codegen.MethodInfo v2;
v0 := @parameter0: java.util.Map;
v1 := @parameter1: io.vertx.codegen.type.TypeInfo;
v2 := @parameter2: io.vertx.codegen.MethodInfo;
v3 = interfaceinvoke v0.<java.util.Map: java.lang.Object get(java.lang.Object)>(v2);
if v3 == null goto label1;
v4 = interfaceinvoke v3.<java.util.Map: java.lang.Object get(java.lang.Object)>(v1);
if v4 == null goto label1;
return v4;
label1:
v5 = new java.lang.StringBuilder;
specialinvoke v5.<java.lang.StringBuilder: void <init>()>();
staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: void genTypeArg(io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo,int,java.lang.StringBuilder)>(v1, v2, 0, v5);
v6 = virtualinvoke v5.<java.lang.StringBuilder: java.lang.String toString()>();
return v6;
}
private static void fail(java.lang.String)
{
java.lang.String v0;
v0 := @parameter0: java.lang.String;
return;
}
public static java.lang.String writeReturnStatementForApi(java.util.Map, io.vertx.codegen.type.TypeInfo, io.vertx.codegen.MethodInfo, java.lang.String)
{
io.vertx.codegen.type.ClassTypeInfo v5, v7;
java.util.Iterator v10;
io.vertx.codegen.type.TypeInfo v1;
java.util.List v9;
java.util.Map v0;
java.lang.Object v12;
java.lang.StringBuilder v4;
java.lang.String v13, v14, v3, v6;
io.vertx.codegen.MethodInfo v2;
boolean v11, v8;
v0 := @parameter0: java.util.Map;
v1 := @parameter1: io.vertx.codegen.type.TypeInfo;
v2 := @parameter2: io.vertx.codegen.MethodInfo;
v3 := @parameter3: java.lang.String;
v4 = new java.lang.StringBuilder;
v5 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v6 = virtualinvoke v5.<io.vertx.codegen.type.ClassTypeInfo: java.lang.String translateName(java.lang.String)>("mutiny");
specialinvoke v4.<java.lang.StringBuilder: void <init>(java.lang.String)>(v6);
virtualinvoke v4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(".newInstance((");
v7 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
virtualinvoke v4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.Object)>(v7);
virtualinvoke v4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(")");
virtualinvoke v4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(v3);
v8 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: boolean isParameterized()>();
if v8 == 0 goto label2;
v9 = virtualinvoke v1.<io.vertx.codegen.type.ParameterizedTypeInfo: java.util.List getArgs()>();
v10 = interfaceinvoke v9.<java.util.List: java.util.Iterator iterator()>();
label1:
v11 = interfaceinvoke v10.<java.util.Iterator: boolean hasNext()>();
if v11 == 0 goto label2;
v12 = interfaceinvoke v10.<java.util.Iterator: java.lang.Object next()>();
virtualinvoke v4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(", ");
v13 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTypeArg(java.util.Map,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo)>(v0, v12, v2);
virtualinvoke v4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(v13);
goto label1;
label2:
virtualinvoke v4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(")");
v14 = virtualinvoke v4.<java.lang.StringBuilder: java.lang.String toString()>();
return v14;
}
public static java.lang.String genConvReturn(java.util.Map, io.vertx.codegen.type.TypeInfo, io.vertx.codegen.MethodInfo, java.lang.String)
{
java.util.Map v0;
io.vertx.codegen.type.ClassKind v13, v16, v18, v19, v29, v30, v36, v4, v40, v5;
boolean v12, v15, v6;
io.vertx.codegen.type.TypeInfo v1, v17, v20, v31, v37, v41;
java.lang.String v10, v11, v14, v21, v22, v23, v24, v25, v26, v27, v28, v3, v32, v34, v35, v38, v39, v42, v43, v7, v8, v9;
io.vertx.codegen.type.ClassTypeInfo v33;
io.vertx.codegen.MethodInfo v2;
v0 := @parameter0: java.util.Map;
v1 := @parameter1: io.vertx.codegen.type.TypeInfo;
v2 := @parameter2: io.vertx.codegen.MethodInfo;
v3 := @parameter3: java.lang.String;
v4 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v5 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind OBJECT>;
if v4 != v5 goto label02;
v6 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: boolean isVariable()>();
if v6 == 0 goto label01;
v7 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTypeArg(io.vertx.codegen.type.TypeVariableInfo,io.vertx.codegen.MethodInfo)>(v1, v2);
if v7 == null goto label01;
v8 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: java.lang.String getName()>();
v9 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String,java.lang.String)>(v8, v7, v3) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("(\u0001)\u0001.wrap(\u0001)");
return v9;
label01:
v10 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: java.lang.String getSimpleName()>();
v11 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v10, v3) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("(\u0001) \u0001");
return v11;
label02:
v12 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: boolean isSameType(io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo)>(v1, v2);
if v12 == 0 goto label03;
return v3;
label03:
v13 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind API>;
if v4 != v13 goto label04;
v14 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String writeReturnStatementForApi(java.util.Map,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo,java.lang.String)>(v0, v1, v2, v3);
return v14;
label04:
v15 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: boolean isParameterized()>();
if v15 == 0 goto label10;
v16 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind HANDLER>;
if v4 != v16 goto label06;
v17 = virtualinvoke v1.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(0);
v18 = virtualinvoke v17.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v19 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind ASYNC_RESULT>;
if v18 != v19 goto label05;
v20 = virtualinvoke v17.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(0);
v21 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTranslatedTypeName(io.vertx.codegen.type.TypeInfo)>(v20);
v22 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTranslatedTypeName(io.vertx.codegen.type.TypeInfo)>(v20);
v23 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genConvParam(java.util.Map,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo,java.lang.String)>(v0, v20, v2, "ar.result()");
v24 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>(v21, v22, v3, v23, v3) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("new Handler<AsyncResult<\u0001>>() {\n      public void handle(AsyncResult<\u0001> ar) {\n        if (ar.succeeded()) {\n          \u0001.handle(io.vertx.core.Future.succeededFuture(\u0001));\n        } else {\n          \u0001.handle(io.vertx.core.Future.failedFuture(ar.cause()));\n        }\n      }\n    }");
return v24;
label05:
v25 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTranslatedTypeName(io.vertx.codegen.type.TypeInfo)>(v17);
v26 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genTranslatedTypeName(io.vertx.codegen.type.TypeInfo)>(v17);
v27 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genConvParam(java.util.Map,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo,java.lang.String)>(v0, v17, v2, "event");
v28 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String,java.lang.String,java.lang.String)>(v25, v26, v3, v27) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("new Handler<\u0001>() {\n      public void handle(\u0001 event) {\n          \u0001.handle(\u0001);\n      }\n    }");
return v28;
label06:
v29 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind LIST>;
if v4 == v29 goto label07;
v30 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind SET>;
if v4 != v30 goto label08;
label07:
v31 = virtualinvoke v1.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(0);
v32 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genConvReturn(java.util.Map,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo,java.lang.String)>(v0, v31, v2, "elt");
v33 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v34 = virtualinvoke v33.<io.vertx.codegen.type.ClassTypeInfo: java.lang.String getSimpleName()>();
v35 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String,java.lang.String)>(v3, v32, v34) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001.stream().map(elt -> \u0001).collect(java.util.stream.Collectors.to\u0001())");
return v35;
label08:
v36 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind MAP>;
if v4 != v36 goto label09;
v37 = virtualinvoke v1.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(1);
v38 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genConvReturn(java.util.Map,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo,java.lang.String)>(v0, v37, v2, "_e.getValue()");
v39 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v3, v38) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001.entrySet().stream().collect(Collectors.toMap(_e -> _e.getKey(), _e -> \u0001))");
return v39;
label09:
v40 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind FUTURE>;
if v4 != v40 goto label10;
v41 = virtualinvoke v1.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(0);
v42 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper: java.lang.String genConvReturn(java.util.Map,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.MethodInfo,java.lang.String)>(v0, v41, v2, "val");
v43 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v3, v42) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001.map(val -> \u0001)");
return v43;
label10:
return v3;
}
static java.lang.String genOptTypeParamsDecl(io.vertx.codegen.type.ClassTypeInfo, java.lang.String)
{
io.vertx.codegen.type.ClassTypeInfo v0;
java.util.function.Function v6;
java.util.List v2, v4;
java.util.stream.Stream v5, v7;
int v3;
java.lang.Object v9;
java.lang.String v1;
java.util.stream.Collector v8;
v0 := @parameter0: io.vertx.codegen.type.ClassTypeInfo;
v1 := @parameter1: java.lang.String;
v2 = virtualinvoke v0.<io.vertx.codegen.type.ClassTypeInfo: java.util.List getParams()>();
v3 = interfaceinvoke v2.<java.util.List: int size()>();
if v3 <= 0 goto label1;
v4 = virtualinvoke v0.<io.vertx.codegen.type.ClassTypeInfo: java.util.List getParams()>();
v5 = interfaceinvoke v4.<java.util.List: java.util.stream.Stream stream()>();
v6 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper$getName__2374: java.util.function.Function bootstrap$()>();
v7 = interfaceinvoke v5.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v6);
v8 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)>(",", "<", ">");
v9 = interfaceinvoke v7.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v8);
return v9;
label1:
return v1;
}
public static java.lang.String renderLinkToHtml(io.vertx.codegen.doc.Tag$Link)
{
int v17;
java.lang.String v10, v11, v12, v13, v16, v18, v19, v20, v4, v5;
io.vertx.codegen.type.ClassKind v6, v7;
boolean v14;
javax.lang.model.element.Name v15;
io.vertx.codegen.type.ClassTypeInfo v2;
javax.lang.model.element.ElementKind v9;
io.vertx.codegen.type.TypeInfo v1;
io.vertx.codegen.doc.Tag$Link v0;
javax.lang.model.element.Element v8;
io.vertx.codegen.ModuleInfo v3;
v0 := @parameter0: io.vertx.codegen.doc.Tag$Link;
v1 = virtualinvoke v0.<io.vertx.codegen.doc.Tag$Link: io.vertx.codegen.type.TypeInfo getTargetType()>();
v2 = virtualinvoke v1.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v3 = virtualinvoke v2.<io.vertx.codegen.type.ClassTypeInfo: io.vertx.codegen.ModuleInfo getModule()>();
if v3 == null goto label3;
v4 = virtualinvoke v0.<io.vertx.codegen.doc.Tag$Link: java.lang.String getLabel()>();
v5 = virtualinvoke v4.<java.lang.String: java.lang.String trim()>();
v6 = virtualinvoke v2.<io.vertx.codegen.type.ClassTypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v7 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind API>;
if v6 != v7 goto label3;
v8 = virtualinvoke v0.<io.vertx.codegen.doc.Tag$Link: javax.lang.model.element.Element getTargetElement()>();
v9 = interfaceinvoke v8.<javax.lang.model.element.Element: javax.lang.model.element.ElementKind getKind()>();
v10 = virtualinvoke v9.<javax.lang.model.element.ElementKind: java.lang.String name()>();
v11 = virtualinvoke v2.<io.vertx.codegen.type.ClassTypeInfo: java.lang.String translateName(java.lang.String)>("mutiny");
v12 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v11) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("{@link \u0001");
v13 = "METHOD";
v14 = virtualinvoke v13.<java.lang.String: boolean equals(java.lang.Object)>(v10);
if v14 == 0 goto label1;
v15 = interfaceinvoke v8.<javax.lang.model.element.Element: javax.lang.model.element.Name getSimpleName()>();
v16 = virtualinvoke v15.<java.lang.Object: java.lang.String toString()>();
v12 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v12, v16) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001#\u0001");
label1:
v17 = virtualinvoke v5.<java.lang.String: int length()>();
if v17 <= 0 goto label2;
v12 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v12, v5) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001 \u0001");
label2:
v18 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v12) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001}");
return v18;
label3:
v19 = virtualinvoke v2.<io.vertx.codegen.type.ClassTypeInfo: java.lang.String getName()>();
v20 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v19) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("{@link \u0001}");
return v20;
}
public static java.lang.String renderLinkToHtml(io.vertx.codegen.type.ClassTypeInfo, io.vertx.codegen.MethodInfo)
{
java.util.function.Function v12;
java.lang.String v16, v17, v18, v4, v5, v6, v7;
java.util.stream.Collector v14;
io.vertx.codegen.type.ClassKind v2, v3;
boolean v9;
io.vertx.codegen.type.ClassTypeInfo v0;
java.util.List v10, v8;
java.util.stream.Stream v11, v13;
java.lang.Object v15;
io.vertx.codegen.MethodInfo v1;
v0 := @parameter0: io.vertx.codegen.type.ClassTypeInfo;
v1 := @parameter1: io.vertx.codegen.MethodInfo;
v2 = virtualinvoke v0.<io.vertx.codegen.type.ClassTypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v3 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind API>;
if v2 != v3 goto label2;
v4 = virtualinvoke v0.<io.vertx.codegen.type.ClassTypeInfo: java.lang.String translateName(java.lang.String)>("mutiny");
v5 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v4) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("{@link \u0001");
v6 = virtualinvoke v1.<io.vertx.codegen.MethodInfo: java.lang.String getName()>();
v7 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v5, v6) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001#\u0001");
v8 = virtualinvoke v1.<io.vertx.codegen.MethodInfo: java.util.List getParams()>();
v9 = interfaceinvoke v8.<java.util.List: boolean isEmpty()>();
if v9 != 0 goto label1;
v10 = virtualinvoke v1.<io.vertx.codegen.MethodInfo: java.util.List getParams()>();
v11 = interfaceinvoke v10.<java.util.List: java.util.stream.Stream stream()>();
v12 = staticinvoke <io.smallrye.mutiny.vertx.codegen.lang.CodeGenHelper$lambda_renderLinkToHtml_1__2375: java.util.function.Function bootstrap$()>();
v13 = interfaceinvoke v11.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v12);
v14 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector joining(java.lang.CharSequence)>(",");
v15 = interfaceinvoke v13.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v14);
v7 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.Object)>(v7, v15) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001(\u0001)");
label1:
v16 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v7) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001}");
return v16;
label2:
v17 = virtualinvoke v0.<io.vertx.codegen.type.ClassTypeInfo: java.lang.String getName()>();
v18 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v17) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("{@link \u0001}");
return v18;
}
}