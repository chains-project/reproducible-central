public final class io.vertx.ext.auth.impl.jose.JWS extends java.lang.Object
{
private static final io.vertx.core.impl.logging.Logger LOG;
public static final java.lang.String EdDSA;
public static final java.lang.String ES256;
public static final java.lang.String ES384;
public static final java.lang.String ES512;
public static final java.lang.String PS256;
public static final java.lang.String PS384;
public static final java.lang.String PS512;
public static final java.lang.String ES256K;
public static final java.lang.String RS256;
public static final java.lang.String RS384;
public static final java.lang.String RS512;
public static final java.lang.String RS1;
public static final java.lang.String HS256;
public static final java.lang.String HS384;
public static final java.lang.String HS512;
private static final java.security.cert.CertificateFactory X509;
private final io.vertx.ext.auth.impl.jose.JWK jwk;
private final java.security.Signature signature;
private final int len;
public void <init>(io.vertx.ext.auth.impl.jose.JWK)
{
io.vertx.ext.auth.impl.jose.JWK v1;
java.security.Signature v8;
java.security.PublicKey v10;
java.lang.RuntimeException v13;
java.lang.IllegalArgumentException v6;
java.security.GeneralSecurityException v12;
int v11;
io.vertx.ext.auth.impl.jose.JWS v0;
java.lang.String v2, v3, v4, v7, v9;
boolean v5;
v0 := @this: io.vertx.ext.auth.impl.jose.JWS;
v1 := @parameter0: io.vertx.ext.auth.impl.jose.JWK;
specialinvoke v0.<java.lang.Object: void <init>()>();
v2 = virtualinvoke v1.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String use()>();
if v2 == null goto label1;
v3 = "sig";
v4 = virtualinvoke v1.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String use()>();
v5 = virtualinvoke v3.<java.lang.String: boolean equals(java.lang.Object)>(v4);
if v5 != 0 goto label1;
v6 = new java.lang.IllegalArgumentException;
specialinvoke v6.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>("JWK isn\'t meant to perform JWS operations");
throw v6;
label1:
v7 = virtualinvoke v1.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String getAlgorithm()>();
v8 = staticinvoke <io.vertx.ext.auth.impl.jose.JWS: java.security.Signature getSignature(java.lang.String)>(v7);
v0.<io.vertx.ext.auth.impl.jose.JWS: java.security.Signature signature> = v8;
v9 = virtualinvoke v1.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String getAlgorithm()>();
v10 = virtualinvoke v1.<io.vertx.ext.auth.impl.jose.JWK: java.security.PublicKey publicKey()>();
v11 = staticinvoke <io.vertx.ext.auth.impl.jose.JWS: int getSignatureLength(java.lang.String,java.security.PublicKey)>(v9, v10);
v0.<io.vertx.ext.auth.impl.jose.JWS: int len> = v11;
label2:
goto label4;
label3:
v12 := @caughtexception;
v13 = new java.lang.RuntimeException;
specialinvoke v13.<java.lang.RuntimeException: void <init>(java.lang.Throwable)>(v12);
throw v13;
label4:
v0.<io.vertx.ext.auth.impl.jose.JWS: io.vertx.ext.auth.impl.jose.JWK jwk> = v1;
return;
catch java.security.NoSuchAlgorithmException from label1 to label2 with label3;
catch java.security.InvalidAlgorithmParameterException from label1 to label2 with label3;
}
public byte[] sign(byte[])
{
java.lang.Throwable v23, v7;
byte[] v1, v17, v22, v6;
java.lang.IllegalStateException v12;
io.vertx.ext.auth.impl.jose.JWK v10, v3, v5, v8;
java.lang.NullPointerException v2;
byte v18;
int v19, v21;
io.vertx.ext.auth.impl.jose.JWS v0;
java.lang.String v11;
boolean v20;
java.security.Signature v13, v14, v15, v16;
javax.crypto.Mac v4;
java.security.PrivateKey v9;
v0 := @this: io.vertx.ext.auth.impl.jose.JWS;
v1 := @parameter0: byte[];
if v1 != null goto label01;
v2 = new java.lang.NullPointerException;
specialinvoke v2.<java.lang.NullPointerException: void <init>(java.lang.String)>("payload is missing");
throw v2;
label01:
v3 = v0.<io.vertx.ext.auth.impl.jose.JWS: io.vertx.ext.auth.impl.jose.JWK jwk>;
v4 = virtualinvoke v3.<io.vertx.ext.auth.impl.jose.JWK: javax.crypto.Mac mac()>();
if v4 == null goto label05;
v5 = v0.<io.vertx.ext.auth.impl.jose.JWS: io.vertx.ext.auth.impl.jose.JWK jwk>;
entermonitor v5;
label02:
v6 = virtualinvoke v4.<javax.crypto.Mac: byte[] doFinal(byte[])>(v1);
exitmonitor v5;
label03:
return v6;
label04:
v7 := @caughtexception;
exitmonitor v5;
throw v7;
label05:
v8 = v0.<io.vertx.ext.auth.impl.jose.JWS: io.vertx.ext.auth.impl.jose.JWK jwk>;
v9 = virtualinvoke v8.<io.vertx.ext.auth.impl.jose.JWK: java.security.PrivateKey privateKey()>();
v10 = v0.<io.vertx.ext.auth.impl.jose.JWS: io.vertx.ext.auth.impl.jose.JWK jwk>;
v11 = virtualinvoke v10.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kty()>();
if v9 != null goto label06;
v12 = new java.lang.IllegalStateException;
specialinvoke v12.<java.lang.IllegalStateException: void <init>(java.lang.String)>("JWK doesn\'t contain secKey material");
throw v12;
label06:
v13 = v0.<io.vertx.ext.auth.impl.jose.JWS: java.security.Signature signature>;
entermonitor v13;
label07:
v14 = v0.<io.vertx.ext.auth.impl.jose.JWS: java.security.Signature signature>;
virtualinvoke v14.<java.security.Signature: void initSign(java.security.PrivateKey)>(v9);
v15 = v0.<io.vertx.ext.auth.impl.jose.JWS: java.security.Signature signature>;
virtualinvoke v15.<java.security.Signature: void update(byte[])>(v1);
v16 = v0.<io.vertx.ext.auth.impl.jose.JWS: java.security.Signature signature>;
v17 = virtualinvoke v16.<java.security.Signature: byte[] sign()>();
v18 = -1;
v19 = virtualinvoke v11.<java.lang.String: int hashCode()>();
lookupswitch(v19)
{
case 2206: goto label08;
default: goto label09;
};
label08:
v20 = virtualinvoke v11.<java.lang.String: boolean equals(java.lang.Object)>("EC");
if v20 == 0 goto label09;
v18 = 0;
label09:
lookupswitch(v18)
{
case 0: goto label10;
default: goto label12;
};
label10:
v21 = v0.<io.vertx.ext.auth.impl.jose.JWS: int len>;
v22 = staticinvoke <io.vertx.ext.auth.impl.jose.JWS: byte[] toJWS(byte[],int)>(v17, v21);
exitmonitor v13;
label11:
return v22;
label12:
exitmonitor v13;
label13:
return v17;
label14:
v23 := @caughtexception;
exitmonitor v13;
throw v23;
catch java.lang.Throwable from label02 to label03 with label04;
catch java.lang.Throwable from label07 to label11 with label14;
catch java.lang.Throwable from label12 to label13 with label14;
}
public boolean verify(byte[], byte[])
{
byte[] v1, v2, v26, v8;
java.lang.IllegalStateException v15;
io.vertx.ext.auth.impl.jose.JWK v11, v13, v5, v7;
java.lang.NullPointerException v3, v4;
java.security.GeneralSecurityException v33;
byte v19;
io.vertx.ext.auth.impl.jose.JWS v0;
boolean v21, v22, v29, v31, v9;
java.security.Signature v16, v17, v18, v28, v30;
javax.crypto.Mac v6;
java.lang.Throwable v10, v32;
int v20, v23, v24, v25, v27;
java.lang.String v14;
java.security.PublicKey v12;
java.lang.RuntimeException v34;
v0 := @this: io.vertx.ext.auth.impl.jose.JWS;
v1 := @parameter0: byte[];
v2 := @parameter1: byte[];
if v1 != null goto label01;
v3 = new java.lang.NullPointerException;
specialinvoke v3.<java.lang.NullPointerException: void <init>(java.lang.String)>("signature is missing");
throw v3;
label01:
if v2 != null goto label02;
v4 = new java.lang.NullPointerException;
specialinvoke v4.<java.lang.NullPointerException: void <init>(java.lang.String)>("payload is missing");
throw v4;
label02:
v5 = v0.<io.vertx.ext.auth.impl.jose.JWS: io.vertx.ext.auth.impl.jose.JWK jwk>;
v6 = virtualinvoke v5.<io.vertx.ext.auth.impl.jose.JWK: javax.crypto.Mac mac()>();
if v6 == null goto label06;
v7 = v0.<io.vertx.ext.auth.impl.jose.JWS: io.vertx.ext.auth.impl.jose.JWK jwk>;
entermonitor v7;
label03:
v8 = virtualinvoke v0.<io.vertx.ext.auth.impl.jose.JWS: byte[] sign(byte[])>(v2);
v9 = staticinvoke <java.security.MessageDigest: boolean isEqual(byte[],byte[])>(v1, v8);
exitmonitor v7;
label04:
return v9;
label05:
v10 := @caughtexception;
exitmonitor v7;
throw v10;
label06:
v11 = v0.<io.vertx.ext.auth.impl.jose.JWS: io.vertx.ext.auth.impl.jose.JWK jwk>;
v12 = virtualinvoke v11.<io.vertx.ext.auth.impl.jose.JWK: java.security.PublicKey publicKey()>();
v13 = v0.<io.vertx.ext.auth.impl.jose.JWS: io.vertx.ext.auth.impl.jose.JWK jwk>;
v14 = virtualinvoke v13.<io.vertx.ext.auth.impl.jose.JWK: java.lang.String kty()>();
if v12 != null goto label07;
v15 = new java.lang.IllegalStateException;
specialinvoke v15.<java.lang.IllegalStateException: void <init>(java.lang.String)>("JWK doesn\'t contain pubKey material");
throw v15;
label07:
v16 = v0.<io.vertx.ext.auth.impl.jose.JWS: java.security.Signature signature>;
entermonitor v16;
label08:
v17 = v0.<io.vertx.ext.auth.impl.jose.JWS: java.security.Signature signature>;
virtualinvoke v17.<java.security.Signature: void initVerify(java.security.PublicKey)>(v12);
v18 = v0.<io.vertx.ext.auth.impl.jose.JWS: java.security.Signature signature>;
virtualinvoke v18.<java.security.Signature: void update(byte[])>(v2);
v19 = -1;
v20 = virtualinvoke v14.<java.lang.String: int hashCode()>();
lookupswitch(v20)
{
case 2206: goto label09;
default: goto label10;
};
label09:
v21 = virtualinvoke v14.<java.lang.String: boolean equals(java.lang.Object)>("EC");
if v21 == 0 goto label10;
v19 = 0;
label10:
lookupswitch(v19)
{
case 0: goto label11;
default: goto label12;
};
label11:
v22 = staticinvoke <io.vertx.ext.auth.impl.jose.JWS: boolean isASN1(byte[])>(v1);
if v22 != 0 goto label12;
v1 = staticinvoke <io.vertx.ext.auth.impl.jose.JWS: byte[] toASN1(byte[])>(v1);
label12:
v23 = lengthof v1;
v24 = v0.<io.vertx.ext.auth.impl.jose.JWS: int len>;
if v23 >= v24 goto label14;
v25 = v0.<io.vertx.ext.auth.impl.jose.JWS: int len>;
v26 = newarray (byte)[v25];
v27 = lengthof v1;
staticinvoke <java.lang.System: void arraycopy(java.lang.Object,int,java.lang.Object,int,int)>(v1, 0, v26, 0, v27);
v28 = v0.<io.vertx.ext.auth.impl.jose.JWS: java.security.Signature signature>;
v29 = virtualinvoke v28.<java.security.Signature: boolean verify(byte[])>(v26);
exitmonitor v16;
label13:
return v29;
label14:
v30 = v0.<io.vertx.ext.auth.impl.jose.JWS: java.security.Signature signature>;
v31 = virtualinvoke v30.<java.security.Signature: boolean verify(byte[])>(v1);
exitmonitor v16;
label15:
return v31;
label16:
v32 := @caughtexception;
exitmonitor v16;
throw v32;
label17:
v33 := @caughtexception;
v34 = new java.lang.RuntimeException;
specialinvoke v34.<java.lang.RuntimeException: void <init>(java.lang.Throwable)>(v33);
throw v34;
catch java.lang.Throwable from label03 to label04 with label05;
catch java.lang.Throwable from label08 to label13 with label16;
catch java.lang.Throwable from label14 to label15 with label16;
catch java.security.SignatureException from label06 to label13 with label17;
catch java.security.InvalidKeyException from label06 to label13 with label17;
catch java.security.SignatureException from label14 to label15 with label17;
catch java.security.InvalidKeyException from label14 to label15 with label17;
}
public io.vertx.ext.auth.impl.jose.JWK jwk()
{
io.vertx.ext.auth.impl.jose.JWK v1;
io.vertx.ext.auth.impl.jose.JWS v0;
v0 := @this: io.vertx.ext.auth.impl.jose.JWS;
v1 = v0.<io.vertx.ext.auth.impl.jose.JWS: io.vertx.ext.auth.impl.jose.JWK jwk>;
return v1;
}
private static java.security.Signature getSignature(java.lang.String) throws java.security.NoSuchAlgorithmException, java.security.InvalidAlgorithmParameterException
{
byte v1;
boolean v10, v11, v12, v13, v14, v15, v16, v17, v3, v4, v5, v6, v7, v8, v9;
java.security.Signature v18, v19, v20, v21, v22, v23, v24, v25, v28, v31, v34;
java.security.NoSuchAlgorithmException v35;
java.security.spec.PSSParameterSpec v26, v29, v32;
int v2;
java.lang.String v0;
java.security.spec.MGF1ParameterSpec v27, v30, v33;
v0 := @parameter0: java.lang.String;
v1 = -1;
v2 = virtualinvoke v0.<java.lang.String: int hashCode()>();
lookupswitch(v2)
{
case 81424: goto label11;
case 66245349: goto label04;
case 66246401: goto label06;
case 66248104: goto label07;
case 66770035: goto label15;
case 69015912: goto label01;
case 69016964: goto label02;
case 69018667: goto label03;
case 76404080: goto label12;
case 76405132: goto label13;
case 76406835: goto label14;
case 78251122: goto label08;
case 78252174: goto label09;
case 78253877: goto label10;
case 2053605894: goto label05;
default: goto label16;
};
label01:
v3 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("HS256");
if v3 == 0 goto label16;
v1 = 0;
goto label16;
label02:
v4 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("HS384");
if v4 == 0 goto label16;
v1 = 1;
goto label16;
label03:
v5 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("HS512");
if v5 == 0 goto label16;
v1 = 2;
goto label16;
label04:
v6 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("ES256");
if v6 == 0 goto label16;
v1 = 3;
goto label16;
label05:
v7 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("ES256K");
if v7 == 0 goto label16;
v1 = 4;
goto label16;
label06:
v8 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("ES384");
if v8 == 0 goto label16;
v1 = 5;
goto label16;
label07:
v9 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("ES512");
if v9 == 0 goto label16;
v1 = 6;
goto label16;
label08:
v10 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("RS256");
if v10 == 0 goto label16;
v1 = 7;
goto label16;
label09:
v11 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("RS384");
if v11 == 0 goto label16;
v1 = 8;
goto label16;
label10:
v12 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("RS512");
if v12 == 0 goto label16;
v1 = 9;
goto label16;
label11:
v13 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("RS1");
if v13 == 0 goto label16;
v1 = 10;
goto label16;
label12:
v14 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("PS256");
if v14 == 0 goto label16;
v1 = 11;
goto label16;
label13:
v15 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("PS384");
if v15 == 0 goto label16;
v1 = 12;
goto label16;
label14:
v16 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("PS512");
if v16 == 0 goto label16;
v1 = 13;
goto label16;
label15:
v17 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("EdDSA");
if v17 == 0 goto label16;
v1 = 14;
label16:
tableswitch(v1)
{
case 0: goto label17;
case 1: goto label17;
case 2: goto label17;
case 3: goto label18;
case 4: goto label18;
case 5: goto label19;
case 6: goto label20;
case 7: goto label21;
case 8: goto label22;
case 9: goto label23;
case 10: goto label24;
case 11: goto label25;
case 12: goto label26;
case 13: goto label27;
case 14: goto label28;
default: goto label29;
};
label17:
return null;
label18:
v18 = staticinvoke <java.security.Signature: java.security.Signature getInstance(java.lang.String)>("SHA256withECDSA");
return v18;
label19:
v19 = staticinvoke <java.security.Signature: java.security.Signature getInstance(java.lang.String)>("SHA384withECDSA");
return v19;
label20:
v20 = staticinvoke <java.security.Signature: java.security.Signature getInstance(java.lang.String)>("SHA512withECDSA");
return v20;
label21:
v21 = staticinvoke <java.security.Signature: java.security.Signature getInstance(java.lang.String)>("SHA256withRSA");
return v21;
label22:
v22 = staticinvoke <java.security.Signature: java.security.Signature getInstance(java.lang.String)>("SHA384withRSA");
return v22;
label23:
v23 = staticinvoke <java.security.Signature: java.security.Signature getInstance(java.lang.String)>("SHA512withRSA");
return v23;
label24:
v24 = staticinvoke <java.security.Signature: java.security.Signature getInstance(java.lang.String)>("SHA1withRSA");
return v24;
label25:
v25 = staticinvoke <java.security.Signature: java.security.Signature getInstance(java.lang.String)>("RSASSA-PSS");
v26 = new java.security.spec.PSSParameterSpec;
v27 = <java.security.spec.MGF1ParameterSpec: java.security.spec.MGF1ParameterSpec SHA256>;
specialinvoke v26.<java.security.spec.PSSParameterSpec: void <init>(java.lang.String,java.lang.String,java.security.spec.AlgorithmParameterSpec,int,int)>("SHA-256", "MGF1", v27, 32, 1);
virtualinvoke v25.<java.security.Signature: void setParameter(java.security.spec.AlgorithmParameterSpec)>(v26);
return v25;
label26:
v28 = staticinvoke <java.security.Signature: java.security.Signature getInstance(java.lang.String)>("RSASSA-PSS");
v29 = new java.security.spec.PSSParameterSpec;
v30 = <java.security.spec.MGF1ParameterSpec: java.security.spec.MGF1ParameterSpec SHA384>;
specialinvoke v29.<java.security.spec.PSSParameterSpec: void <init>(java.lang.String,java.lang.String,java.security.spec.AlgorithmParameterSpec,int,int)>("SHA-384", "MGF1", v30, 48, 1);
virtualinvoke v28.<java.security.Signature: void setParameter(java.security.spec.AlgorithmParameterSpec)>(v29);
return v28;
label27:
v31 = staticinvoke <java.security.Signature: java.security.Signature getInstance(java.lang.String)>("RSASSA-PSS");
v32 = new java.security.spec.PSSParameterSpec;
v33 = <java.security.spec.MGF1ParameterSpec: java.security.spec.MGF1ParameterSpec SHA512>;
specialinvoke v32.<java.security.spec.PSSParameterSpec: void <init>(java.lang.String,java.lang.String,java.security.spec.AlgorithmParameterSpec,int,int)>("SHA-512", "MGF1", v33, 64, 1);
virtualinvoke v31.<java.security.Signature: void setParameter(java.security.spec.AlgorithmParameterSpec)>(v32);
return v31;
label28:
v34 = staticinvoke <java.security.Signature: java.security.Signature getInstance(java.lang.String)>("EdDSA");
return v34;
label29:
v35 = new java.security.NoSuchAlgorithmException;
specialinvoke v35.<java.security.NoSuchAlgorithmException: void <init>()>();
throw v35;
}
public static boolean verifySignature(java.lang.String, java.security.cert.X509Certificate, byte[], byte[]) throws java.security.InvalidKeyException, java.security.SignatureException, java.security.InvalidAlgorithmParameterException, java.security.NoSuchAlgorithmException
{
java.security.cert.X509Certificate v1;
byte[] v2, v3;
byte v5;
int v6;
java.lang.String v0, v14;
boolean v10, v11, v15, v7, v8, v9;
java.security.SignatureException v13, v4;
java.security.Signature v12;
v0 := @parameter0: java.lang.String;
v1 := @parameter1: java.security.cert.X509Certificate;
v2 := @parameter2: byte[];
v3 := @parameter3: byte[];
if v0 == null goto label01;
if v1 == null goto label01;
if v2 == null goto label01;
if v3 != null goto label02;
label01:
v4 = new java.security.SignatureException;
specialinvoke v4.<java.security.SignatureException: void <init>(java.lang.String)>("Cannot validate signature, one of {alg, certificate, signature, data} is null");
throw v4;
label02:
v5 = -1;
v6 = virtualinvoke v0.<java.lang.String: int hashCode()>();
lookupswitch(v6)
{
case 66245349: goto label03;
case 66246401: goto label04;
case 66248104: goto label05;
case 2053605894: goto label06;
default: goto label07;
};
label03:
v7 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("ES256");
if v7 == 0 goto label07;
v5 = 0;
goto label07;
label04:
v8 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("ES384");
if v8 == 0 goto label07;
v5 = 1;
goto label07;
label05:
v9 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("ES512");
if v9 == 0 goto label07;
v5 = 2;
goto label07;
label06:
v10 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("ES256K");
if v10 == 0 goto label07;
v5 = 3;
label07:
tableswitch(v5)
{
case 0: goto label08;
case 1: goto label08;
case 2: goto label08;
case 3: goto label08;
default: goto label09;
};
label08:
v11 = staticinvoke <io.vertx.ext.auth.impl.jose.JWS: boolean isASN1(byte[])>(v2);
if v11 != 0 goto label09;
v2 = staticinvoke <io.vertx.ext.auth.impl.jose.JWS: byte[] toASN1(byte[])>(v2);
label09:
v12 = staticinvoke <io.vertx.ext.auth.impl.jose.JWS: java.security.Signature getSignature(java.lang.String)>(v0);
if v12 != null goto label10;
v13 = new java.security.SignatureException;
v14 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v0) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Cannot get a signature for: \u0001");
specialinvoke v13.<java.security.SignatureException: void <init>(java.lang.String)>(v14);
throw v13;
label10:
virtualinvoke v12.<java.security.Signature: void initVerify(java.security.cert.Certificate)>(v1);
virtualinvoke v12.<java.security.Signature: void update(byte[])>(v3);
v15 = virtualinvoke v12.<java.security.Signature: boolean verify(byte[])>(v2);
return v15;
}
private static int getSignatureLength(java.lang.String, java.security.PublicKey) throws java.security.NoSuchAlgorithmException
{
byte v7;
int v4, v5, v6, v8;
java.math.BigInteger v3;
java.lang.String v0;
boolean v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v2, v20, v21, v22, v23, v9;
java.security.PublicKey v1;
java.security.NoSuchAlgorithmException v24;
v0 := @parameter0: java.lang.String;
v1 := @parameter1: java.security.PublicKey;
v2 = v1 instanceof java.security.interfaces.RSAKey;
if v2 == 0 goto label01;
v3 = interfaceinvoke v1.<java.security.interfaces.RSAKey: java.math.BigInteger getModulus()>();
v4 = virtualinvoke v3.<java.math.BigInteger: int bitLength()>();
v5 = v4 + 7;
v6 = v5 >> 3;
return v6;
label01:
v7 = -1;
v8 = virtualinvoke v0.<java.lang.String: int hashCode()>();
lookupswitch(v8)
{
case 81424: goto label08;
case 66245349: goto label03;
case 66246401: goto label05;
case 66248104: goto label06;
case 66770035: goto label02;
case 69015912: goto label07;
case 69016964: goto label11;
case 69018667: goto label14;
case 76404080: goto label10;
case 76405132: goto label13;
case 76406835: goto label16;
case 78251122: goto label09;
case 78252174: goto label12;
case 78253877: goto label15;
case 2053605894: goto label04;
default: goto label17;
};
label02:
v9 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("EdDSA");
if v9 == 0 goto label17;
v7 = 0;
goto label17;
label03:
v10 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("ES256");
if v10 == 0 goto label17;
v7 = 1;
goto label17;
label04:
v11 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("ES256K");
if v11 == 0 goto label17;
v7 = 2;
goto label17;
label05:
v12 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("ES384");
if v12 == 0 goto label17;
v7 = 3;
goto label17;
label06:
v13 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("ES512");
if v13 == 0 goto label17;
v7 = 4;
goto label17;
label07:
v14 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("HS256");
if v14 == 0 goto label17;
v7 = 5;
goto label17;
label08:
v15 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("RS1");
if v15 == 0 goto label17;
v7 = 6;
goto label17;
label09:
v16 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("RS256");
if v16 == 0 goto label17;
v7 = 7;
goto label17;
label10:
v17 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("PS256");
if v17 == 0 goto label17;
v7 = 8;
goto label17;
label11:
v18 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("HS384");
if v18 == 0 goto label17;
v7 = 9;
goto label17;
label12:
v19 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("RS384");
if v19 == 0 goto label17;
v7 = 10;
goto label17;
label13:
v20 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("PS384");
if v20 == 0 goto label17;
v7 = 11;
goto label17;
label14:
v21 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("HS512");
if v21 == 0 goto label17;
v7 = 12;
goto label17;
label15:
v22 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("RS512");
if v22 == 0 goto label17;
v7 = 13;
goto label17;
label16:
v23 = virtualinvoke v0.<java.lang.String: boolean equals(java.lang.Object)>("PS512");
if v23 == 0 goto label17;
v7 = 14;
label17:
tableswitch(v7)
{
case 0: goto label18;
case 1: goto label18;
case 2: goto label18;
case 3: goto label19;
case 4: goto label20;
case 5: goto label21;
case 6: goto label21;
case 7: goto label21;
case 8: goto label21;
case 9: goto label22;
case 10: goto label22;
case 11: goto label22;
case 12: goto label23;
case 13: goto label23;
case 14: goto label23;
default: goto label24;
};
label18:
return 64;
label19:
return 96;
label20:
return 132;
label21:
return 256;
label22:
return 384;
label23:
return 512;
label24:
v24 = new java.security.NoSuchAlgorithmException;
specialinvoke v24.<java.security.NoSuchAlgorithmException: void <init>()>();
throw v24;
}
public static java.security.cert.X509Certificate parseX5c(java.lang.String) throws java.security.cert.CertificateException
{
io.vertx.core.impl.logging.Logger v10, v7;
byte[] v5;
java.security.cert.CertificateFactory v1;
java.security.cert.Certificate v6;
java.io.ByteArrayInputStream v2;
java.nio.charset.Charset v4;
java.lang.String v0, v11, v3, v9;
boolean v8;
v0 := @parameter0: java.lang.String;
v1 = <io.vertx.ext.auth.impl.jose.JWS: java.security.cert.CertificateFactory X509>;
v2 = new java.io.ByteArrayInputStream;
v3 = staticinvoke <io.vertx.ext.auth.impl.jose.JWS: java.lang.String addBoundaries(java.lang.String,java.lang.String)>(v0, "CERTIFICATE");
v4 = <java.nio.charset.StandardCharsets: java.nio.charset.Charset UTF_8>;
v5 = virtualinvoke v3.<java.lang.String: byte[] getBytes(java.nio.charset.Charset)>(v4);
specialinvoke v2.<java.io.ByteArrayInputStream: void <init>(byte[])>(v5);
v6 = virtualinvoke v1.<java.security.cert.CertificateFactory: java.security.cert.Certificate generateCertificate(java.io.InputStream)>(v2);
v7 = <io.vertx.ext.auth.impl.jose.JWS: io.vertx.core.impl.logging.Logger LOG>;
v8 = interfaceinvoke v7.<io.vertx.core.impl.logging.Logger: boolean isDebugEnabled()>();
if v8 == 0 goto label1;
v9 = staticinvoke <io.vertx.ext.auth.impl.jose.JWS: java.lang.String extractCRLs(java.security.cert.X509Certificate)>(v6);
if v9 == null goto label1;
v10 = <io.vertx.ext.auth.impl.jose.JWS: io.vertx.core.impl.logging.Logger LOG>;
v11 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v9) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("CRL Distribution Point: \u0001");
interfaceinvoke v10.<io.vertx.core.impl.logging.Logger: void debug(java.lang.Object)>(v11);
label1:
return v6;
}
public static java.security.cert.X509Certificate parseX5c(byte[]) throws java.security.cert.CertificateException
{
io.vertx.core.impl.logging.Logger v4, v7;
byte[] v0;
java.security.cert.CertificateFactory v1;
java.security.cert.Certificate v3;
java.io.ByteArrayInputStream v2;
java.lang.String v6, v8;
boolean v5;
v0 := @parameter0: byte[];
v1 = <io.vertx.ext.auth.impl.jose.JWS: java.security.cert.CertificateFactory X509>;
v2 = new java.io.ByteArrayInputStream;
specialinvoke v2.<java.io.ByteArrayInputStream: void <init>(byte[])>(v0);
v3 = virtualinvoke v1.<java.security.cert.CertificateFactory: java.security.cert.Certificate generateCertificate(java.io.InputStream)>(v2);
v4 = <io.vertx.ext.auth.impl.jose.JWS: io.vertx.core.impl.logging.Logger LOG>;
v5 = interfaceinvoke v4.<io.vertx.core.impl.logging.Logger: boolean isDebugEnabled()>();
if v5 == 0 goto label1;
v6 = staticinvoke <io.vertx.ext.auth.impl.jose.JWS: java.lang.String extractCRLs(java.security.cert.X509Certificate)>(v3);
if v6 == null goto label1;
v7 = <io.vertx.ext.auth.impl.jose.JWS: io.vertx.core.impl.logging.Logger LOG>;
v8 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v6) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("CRL Distribution Point: \u0001");
interfaceinvoke v7.<io.vertx.core.impl.logging.Logger: void debug(java.lang.Object)>(v8);
label1:
return v3;
}
public static java.lang.String extractCRLs(java.security.cert.X509Certificate) throws java.security.cert.CertificateException
{
java.security.cert.X509Certificate v0;
byte[] v1, v16, v5;
java.nio.charset.Charset v17;
int v10, v9;
io.vertx.ext.auth.impl.asn.ASN1$ASN v11, v12, v13, v14, v2, v6;
java.lang.String v15;
boolean v3, v7;
java.security.cert.CertificateException v4, v8;
v0 := @parameter0: java.security.cert.X509Certificate;
if v0 == null goto label5;
v1 = virtualinvoke v0.<java.security.cert.X509Certificate: byte[] getExtensionValue(java.lang.String)>("2.5.29.31");
if v1 == null goto label5;
v2 = staticinvoke <io.vertx.ext.auth.impl.asn.ASN1: io.vertx.ext.auth.impl.asn.ASN1$ASN parseASN1(byte[])>(v1);
v3 = virtualinvoke v2.<io.vertx.ext.auth.impl.asn.ASN1$ASN: boolean is(int)>(4);
if v3 != 0 goto label1;
v4 = new java.security.cert.CertificateException;
specialinvoke v4.<java.security.cert.CertificateException: void <init>(java.lang.String)>("2.5.29.31 Extension is not an ASN.1 OCTET STRING!");
throw v4;
label1:
v5 = virtualinvoke v2.<io.vertx.ext.auth.impl.asn.ASN1$ASN: byte[] binary(int)>(0);
v6 = staticinvoke <io.vertx.ext.auth.impl.asn.ASN1: io.vertx.ext.auth.impl.asn.ASN1$ASN parseASN1(byte[])>(v5);
v7 = virtualinvoke v6.<io.vertx.ext.auth.impl.asn.ASN1$ASN: boolean is(int)>(16);
if v7 != 0 goto label2;
v8 = new java.security.cert.CertificateException;
specialinvoke v8.<java.security.cert.CertificateException: void <init>(java.lang.String)>("2.5.29.31 Extension is not an ASN.1 SEQUENCE!");
throw v8;
label2:
v9 = 0;
label3:
v10 = virtualinvoke v6.<io.vertx.ext.auth.impl.asn.ASN1$ASN: int length()>();
if v9 >= v10 goto label5;
v11 = virtualinvoke v6.<io.vertx.ext.auth.impl.asn.ASN1$ASN: io.vertx.ext.auth.impl.asn.ASN1$ASN object(int,int)>(v9, 16);
v12 = virtualinvoke v11.<io.vertx.ext.auth.impl.asn.ASN1$ASN: io.vertx.ext.auth.impl.asn.ASN1$ASN object(int)>(0);
v13 = virtualinvoke v12.<io.vertx.ext.auth.impl.asn.ASN1$ASN: io.vertx.ext.auth.impl.asn.ASN1$ASN object(int)>(0);
v14 = virtualinvoke v13.<io.vertx.ext.auth.impl.asn.ASN1$ASN: io.vertx.ext.auth.impl.asn.ASN1$ASN object(int,int)>(0, 134);
if v14 == null goto label4;
v15 = new java.lang.String;
v16 = virtualinvoke v14.<io.vertx.ext.auth.impl.asn.ASN1$ASN: byte[] binary(int)>(0);
v17 = <java.nio.charset.StandardCharsets: java.nio.charset.Charset US_ASCII>;
specialinvoke v15.<java.lang.String: void <init>(byte[],java.nio.charset.Charset)>(v16, v17);
return v15;
label4:
v9 = v9 + 1;
goto label3;
label5:
return null;
}
public static java.security.cert.X509CRL parseX5crl(java.lang.String) throws java.security.cert.CRLException
{
byte[] v5;
java.io.ByteArrayInputStream v2;
java.nio.charset.Charset v4;
java.security.cert.CertificateFactory v1;
java.lang.String v0, v3;
java.security.cert.CRL v6;
v0 := @parameter0: java.lang.String;
v1 = <io.vertx.ext.auth.impl.jose.JWS: java.security.cert.CertificateFactory X509>;
v2 = new java.io.ByteArrayInputStream;
v3 = staticinvoke <io.vertx.ext.auth.impl.jose.JWS: java.lang.String addBoundaries(java.lang.String,java.lang.String)>(v0, "X509 CRL");
v4 = <java.nio.charset.StandardCharsets: java.nio.charset.Charset UTF_8>;
v5 = virtualinvoke v3.<java.lang.String: byte[] getBytes(java.nio.charset.Charset)>(v4);
specialinvoke v2.<java.io.ByteArrayInputStream: void <init>(byte[])>(v5);
v6 = virtualinvoke v1.<java.security.cert.CertificateFactory: java.security.cert.CRL generateCRL(java.io.InputStream)>(v2);
return v6;
}
public static java.security.cert.X509CRL parseX5crl(byte[]) throws java.security.cert.CRLException
{
byte[] v0;
java.io.ByteArrayInputStream v2;
java.security.cert.CertificateFactory v1;
java.security.cert.CRL v3;
v0 := @parameter0: byte[];
v1 = <io.vertx.ext.auth.impl.jose.JWS: java.security.cert.CertificateFactory X509>;
v2 = new java.io.ByteArrayInputStream;
specialinvoke v2.<java.io.ByteArrayInputStream: void <init>(byte[])>(v0);
v3 = virtualinvoke v1.<java.security.cert.CertificateFactory: java.security.cert.CRL generateCRL(java.io.InputStream)>(v2);
return v3;
}
private static boolean byteAtIndexIs(byte[], int, int)
{
byte[] v0;
byte v4;
int v1, v2, v3, v5;
boolean v6;
v0 := @parameter0: byte[];
v1 := @parameter1: int;
v2 := @parameter2: int;
if v0 != null goto label1;
return 0;
label1:
v3 = lengthof v0;
if v3 > v1 goto label2;
return 0;
label2:
v4 = v0[v1];
v5 = staticinvoke <java.lang.Byte: int toUnsignedInt(byte)>(v4);
if v5 != v2 goto label3;
v6 = 1;
goto label4;
label3:
v6 = 0;
label4:
return v6;
}
private static boolean byteAtIndexLte(byte[], int, int)
{
byte[] v0;
byte v4, v5;
int v1, v2, v3, v6;
boolean v7;
v0 := @parameter0: byte[];
v1 := @parameter1: int;
v2 := @parameter2: int;
if v0 != null goto label1;
return 0;
label1:
v3 = lengthof v0;
if v3 > v1 goto label2;
return 0;
label2:
v4 = v0[v1];
if v4 > 0 goto label3;
return 0;
label3:
v5 = v0[v1];
v6 = staticinvoke <java.lang.Byte: int toUnsignedInt(byte)>(v5);
if v6 > v2 goto label4;
v7 = 1;
goto label5;
label4:
v7 = 0;
label5:
return v7;
}
public static boolean isASN1(byte[])
{
byte[] v0;
byte v19;
int v10, v11, v13, v14, v15, v16, v18, v2, v20, v21, v5, v6, v7, v8;
boolean v1, v12, v17, v22, v3, v4, v9;
v0 := @parameter0: byte[];
v1 = staticinvoke <io.vertx.ext.auth.impl.jose.JWS: boolean byteAtIndexIs(byte[],int,int)>(v0, 0, 48);
if v1 != 0 goto label01;
return 0;
label01:
v2 = lengthof v0;
if v2 >= 128 goto label02;
v3 = 0;
goto label04;
label02:
v4 = staticinvoke <io.vertx.ext.auth.impl.jose.JWS: boolean byteAtIndexIs(byte[],int,int)>(v0, 1, 129);
if v4 != 0 goto label03;
return 0;
label03:
v3 = 1;
label04:
v5 = v3 + 1;
v6 = lengthof v0;
v7 = v6 - v3;
v8 = v7 - 2;
v9 = staticinvoke <io.vertx.ext.auth.impl.jose.JWS: boolean byteAtIndexIs(byte[],int,int)>(v0, v5, v8);
if v9 != 0 goto label05;
return 0;
label05:
v10 = v3 + 2;
v11 = 0;
label06:
if v11 >= 2 goto label09;
v12 = staticinvoke <io.vertx.ext.auth.impl.jose.JWS: boolean byteAtIndexIs(byte[],int,int)>(v0, v10, 2);
if v12 != 0 goto label07;
return 0;
label07:
v13 = v10 + 1;
v14 = lengthof v0;
v15 = v14 - v10;
v16 = v15 - 2;
v17 = staticinvoke <io.vertx.ext.auth.impl.jose.JWS: boolean byteAtIndexLte(byte[],int,int)>(v0, v13, v16);
if v17 != 0 goto label08;
return 0;
label08:
v18 = v10 + 1;
v19 = v0[v18];
v20 = v10 + v19;
v10 = v20 + 2;
v11 = v11 + 1;
goto label06;
label09:
v21 = lengthof v0;
if v10 != v21 goto label10;
v22 = 1;
goto label11;
label10:
v22 = 0;
label11:
return v22;
}
public static byte[] toJWS(byte[], int)
{
byte[] v0, v48;
byte v11, v16, v20, v27, v3, v32, v37, v42, v45, v5, v6, v7;
short v33, v38;
int v1, v10, v12, v13, v14, v15, v17, v18, v19, v2, v21, v22, v23, v24, v25, v26, v28, v29, v30, v31, v34, v35, v36, v39, v40, v41, v43, v44, v47, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v8;
java.lang.RuntimeException v4, v46, v9;
v0 := @parameter0: byte[];
v1 := @parameter1: int;
v2 = lengthof v0;
if v2 < 8 goto label01;
v3 = v0[0];
if v3 == 48 goto label02;
label01:
v4 = new java.lang.RuntimeException;
specialinvoke v4.<java.lang.RuntimeException: void <init>(java.lang.String)>("Invalid ECDSA signature format");
throw v4;
label02:
v5 = v0[1];
if v5 <= 0 goto label03;
v6 = 2;
goto label05;
label03:
v7 = v0[1];
v8 = (int) -127;
if v7 != v8 goto label04;
v6 = 3;
goto label05;
label04:
v9 = new java.lang.RuntimeException;
specialinvoke v9.<java.lang.RuntimeException: void <init>(java.lang.String)>("Invalid ECDSA signature format");
throw v9;
label05:
v10 = v6 + 1;
v11 = v0[v10];
v12 = v11;
label06:
if v12 <= 0 goto label07;
v13 = v6 + 2;
v14 = v13 + v11;
v15 = v14 - v12;
v16 = v0[v15];
if v16 != 0 goto label07;
v12 = v12 - 1;
goto label06;
label07:
v17 = v6 + 2;
v18 = v17 + v11;
v19 = v18 + 1;
v20 = v0[v19];
v21 = v20;
label08:
if v21 <= 0 goto label09;
v22 = v6 + 2;
v23 = v22 + v11;
v24 = v23 + 2;
v25 = v24 + v20;
v26 = v25 - v21;
v27 = v0[v26];
if v27 != 0 goto label09;
v21 = v21 - 1;
goto label08;
label09:
v28 = staticinvoke <java.lang.Math: int max(int,int)>(v12, v21);
v29 = v1 / 2;
v30 = staticinvoke <java.lang.Math: int max(int,int)>(v28, v29);
v31 = v6 - 1;
v32 = v0[v31];
v33 = v32 & 255;
v34 = lengthof v0;
v35 = v34 - v6;
if v33 != v35 goto label10;
v36 = v6 - 1;
v37 = v0[v36];
v38 = v37 & 255;
v39 = 2 + v11;
v40 = v39 + 2;
v41 = v40 + v20;
if v38 != v41 goto label10;
v42 = v0[v6];
if v42 != 2 goto label10;
v43 = v6 + 2;
v44 = v43 + v11;
v45 = v0[v44];
if v45 == 2 goto label11;
label10:
v46 = new java.lang.RuntimeException;
specialinvoke v46.<java.lang.RuntimeException: void <init>(java.lang.String)>("Invalid ECDSA signature format");
throw v46;
label11:
v47 = 2 * v30;
v48 = newarray (byte)[v47];
v49 = v6 + 2;
v50 = v49 + v11;
v51 = v50 - v12;
v52 = v30 - v12;
staticinvoke <java.lang.System: void arraycopy(java.lang.Object,int,java.lang.Object,int,int)>(v0, v51, v48, v52, v12);
v53 = v6 + 2;
v54 = v53 + v11;
v55 = v54 + 2;
v56 = v55 + v20;
v57 = v56 - v21;
v58 = 2 * v30;
v59 = v58 - v21;
staticinvoke <java.lang.System: void arraycopy(java.lang.Object,int,java.lang.Object,int,int)>(v0, v57, v48, v59, v21);
return v48;
}
public static byte[] toASN1(byte[])
{
byte[] v0, v25;
byte v12, v17, v26, v5, v8;
int v1, v10, v11, v14, v15, v16, v18, v19, v2, v20, v22, v23, v24, v27, v28, v29, v3, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v4, v40, v41, v42, v6, v7, v9;
java.lang.RuntimeException v13, v21;
v0 := @parameter0: byte[];
v1 = lengthof v0;
v2 = v1 / 2;
v3 = v2;
label01:
if v3 <= 0 goto label02;
v4 = v2 - v3;
v5 = v0[v4];
if v5 != 0 goto label02;
v3 = v3 - 1;
goto label01;
label02:
v6 = v3;
v7 = v2 - v3;
v8 = v0[v7];
if v8 >= 0 goto label03;
v6 = v3 + 1;
label03:
v9 = v2;
label04:
if v9 <= 0 goto label05;
v10 = 2 * v2;
v11 = v10 - v9;
v12 = v0[v11];
if v12 != 0 goto label05;
v9 = v9 - 1;
goto label04;
label05:
if v9 != 0 goto label06;
v13 = new java.lang.RuntimeException;
specialinvoke v13.<java.lang.RuntimeException: void <init>(java.lang.String)>("Invalid ECDSA signature");
throw v13;
label06:
v14 = v9;
v15 = 2 * v2;
v16 = v15 - v9;
v17 = v0[v16];
if v17 >= 0 goto label07;
v14 = v9 + 1;
label07:
v18 = 2 + v6;
v19 = v18 + 2;
v20 = v19 + v14;
if v20 <= 255 goto label08;
v21 = new java.lang.RuntimeException;
specialinvoke v21.<java.lang.RuntimeException: void <init>(java.lang.String)>("Invalid ECDSA signature format");
throw v21;
label08:
if v20 >= 128 goto label09;
v22 = 4 + v6;
v23 = v22 + 2;
v24 = v23 + v14;
v25 = newarray (byte)[v24];
v26 = 1;
goto label10;
label09:
v27 = 5 + v6;
v28 = v27 + 2;
v29 = v28 + v14;
v25 = newarray (byte)[v29];
v25[1] = -127;
v26 = 2;
label10:
v25[0] = 48;
v30 = v26 + 1;
v25[v26] = v20;
v31 = v30 + 1;
v25[v30] = 2;
v32 = v31 + 1;
v25[v31] = v6;
v33 = v2 - v3;
v34 = v32 + v6;
v35 = v34 - v3;
staticinvoke <java.lang.System: void arraycopy(java.lang.Object,int,java.lang.Object,int,int)>(v0, v33, v25, v35, v3);
v36 = v32 + v6;
v37 = v36 + 1;
v25[v36] = 2;
v38 = v37 + 1;
v25[v37] = v14;
v39 = 2 * v2;
v40 = v39 - v9;
v41 = v38 + v14;
v42 = v41 - v9;
staticinvoke <java.lang.System: void arraycopy(java.lang.Object,int,java.lang.Object,int,int)>(v0, v40, v25, v42, v9);
return v25;
}
private static java.lang.String addBoundaries(java.lang.String, java.lang.String)
{
java.lang.String v0, v1, v2, v3, v6;
boolean v4, v5;
v0 := @parameter0: java.lang.String;
v1 := @parameter1: java.lang.String;
v2 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v1) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("-----BEGIN \u0001-----\n");
v3 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v1) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\n-----END \u0001-----\n");
v4 = virtualinvoke v0.<java.lang.String: boolean contains(java.lang.CharSequence)>(v2);
if v4 == 0 goto label1;
v5 = virtualinvoke v0.<java.lang.String: boolean contains(java.lang.CharSequence)>(v3);
if v5 == 0 goto label1;
return v0;
label1:
v6 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String,java.lang.String)>(v2, v0, v3) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001\u0001\u0001");
return v6;
}
static void <clinit>()
{
io.vertx.core.impl.logging.Logger v0;
java.security.cert.CertificateFactory v1;
java.lang.RuntimeException v3;
java.security.cert.CertificateException v2;
v0 = staticinvoke <io.vertx.core.impl.logging.LoggerFactory: io.vertx.core.impl.logging.Logger getLogger(java.lang.Class)>(class "Lio/vertx/ext/auth/impl/jose/JWS;");
<io.vertx.ext.auth.impl.jose.JWS: io.vertx.core.impl.logging.Logger LOG> = v0;
label1:
v1 = staticinvoke <java.security.cert.CertificateFactory: java.security.cert.CertificateFactory getInstance(java.lang.String)>("X.509");
<io.vertx.ext.auth.impl.jose.JWS: java.security.cert.CertificateFactory X509> = v1;
label2:
goto label4;
label3:
v2 := @caughtexception;
v3 = new java.lang.RuntimeException;
specialinvoke v3.<java.lang.RuntimeException: void <init>(java.lang.Throwable)>(v2);
throw v3;
label4:
return;
catch java.security.cert.CertificateException from label1 to label2 with label3;
}
}