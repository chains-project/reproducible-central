public abstract class io.netty.handler.ssl.ReferenceCountedOpenSslContext extends io.netty.handler.ssl.SslContext implements io.netty.util.ReferenceCounted
{
private static final io.netty.util.internal.logging.InternalLogger logger;
private static final int DEFAULT_BIO_NON_APPLICATION_BUFFER_SIZE;
static final boolean USE_TASKS;
private static final java.lang.Integer DH_KEY_LENGTH;
private static final io.netty.util.ResourceLeakDetector leakDetector;
protected static final int VERIFY_DEPTH;
static final boolean CLIENT_ENABLE_SESSION_TICKET;
static final boolean CLIENT_ENABLE_SESSION_TICKET_TLSV13;
static final boolean SERVER_ENABLE_SESSION_TICKET;
static final boolean SERVER_ENABLE_SESSION_TICKET_TLSV13;
static final boolean SERVER_ENABLE_SESSION_CACHE;
static final boolean CLIENT_ENABLE_SESSION_CACHE;
protected long ctx;
private final java.util.List unmodifiableCiphers;
private final io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator apn;
private final int mode;
private final io.netty.util.ResourceLeakTracker leak;
private final io.netty.util.AbstractReferenceCounted refCnt;
final java.security.cert.Certificate[] keyCertChain;
final io.netty.handler.ssl.ClientAuth clientAuth;
final java.lang.String[] protocols;
final boolean enableOcsp;
final io.netty.handler.ssl.OpenSslEngineMap engineMap;
final java.util.concurrent.locks.ReadWriteLock ctxLock;
private volatile int bioNonApplicationBufferSize;
static final io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator NONE_PROTOCOL_NEGOTIATOR;
final boolean tlsFalseStart;
transient void <init>(java.lang.Iterable, io.netty.handler.ssl.CipherSuiteFilter, io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator, int, java.security.cert.Certificate[], io.netty.handler.ssl.ClientAuth, java.lang.String[], boolean, boolean, boolean, java.util.Map$Entry[]) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.ReferenceCountedOpenSslContext$1 v12;
java.lang.Integer v120, v122;
io.netty.handler.ssl.ClientAuth v6;
byte v64;
io.netty.util.internal.logging.InternalLogger v37, v79;
java.lang.StringBuilder v68, v69;
java.lang.Object[] v127;
io.netty.handler.ssl.ReferenceCountedOpenSslContext$PrivateKeyMethod v143;
long v114, v115, v116, v121, v134, v135, v136, v137, v139, v141, v142, v145, v158, v160, v162, v165, v167, v65, v72, v73, v76, v78, v87;
io.netty.handler.ssl.ApplicationProtocolConfig$Protocol v131;
int[] v130, v154;
io.netty.handler.ssl.OpenSslEngineMap v144, v147, v152;
io.netty.handler.ssl.OpenSslContextOption v25, v27, v29, v31, v33, v35;
java.security.cert.Certificate[] v5;
int v100, v101, v102, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v117, v118, v119, v123, v129, v132, v133, v15, v156, v157, v159, v161, v163, v166, v21, v22, v4, v60, v88, v89, v90, v91, v92, v93, v94, v95, v96, v97, v98, v99;
io.netty.util.ResourceLeakTracker v49;
io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator v3;
java.lang.Class v38, v43, v45;
java.lang.Object v150, v24, v26, v28, v30, v32, v34, v36, v40, v51, v54, v55, v62;
io.netty.handler.ssl.OpenSslCertificateCompressionConfig$AlgorithmMode v155;
io.netty.handler.ssl.CipherSuiteFilter v2;
java.util.Set v57;
io.netty.handler.ssl.ReferenceCountedOpenSslContext$DefaultOpenSslEngineMap v13;
java.lang.Exception v66, v83;
javax.net.ssl.SSLException v67, v82, v84;
java.lang.Throwable v169;
java.lang.Error v138;
java.util.concurrent.locks.ReentrantReadWriteLock v14;
java.util.ArrayList v61;
java.lang.String v39, v41, v44, v46, v47, v77, v80, v81, v86;
java.util.LinkedHashSet v59;
java.util.Map$Entry v23;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
java.lang.IllegalStateException v164, v17;
boolean v10, v125, v140, v149, v16, v19, v20, v50, v52, v63, v71, v75, v8, v9;
io.netty.util.ResourceLeakDetector v48;
java.util.List v124, v56, v70, v74, v85;
io.netty.handler.ssl.ApplicationProtocolConfig$SelectorFailureBehavior v128;
io.netty.handler.ssl.ReferenceCountedOpenSslContext$AsyncPrivateKeyMethod v146;
java.lang.String[] v126, v168, v53, v58, v7;
java.lang.Iterable v1;
io.netty.handler.ssl.OpenSslCertificateCompressionAlgorithm v153;
java.util.Map$Entry[] v11;
java.util.Iterator v148;
java.lang.IllegalArgumentException v18, v42;
io.netty.handler.ssl.ReferenceCountedOpenSslContext$CompressionAlgorithm v151;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 := @parameter0: java.lang.Iterable;
v2 := @parameter1: io.netty.handler.ssl.CipherSuiteFilter;
v3 := @parameter2: io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator;
v4 := @parameter3: int;
v5 := @parameter4: java.security.cert.Certificate[];
v6 := @parameter5: io.netty.handler.ssl.ClientAuth;
v7 := @parameter6: java.lang.String[];
v8 := @parameter7: boolean;
v9 := @parameter8: boolean;
v10 := @parameter9: boolean;
v11 := @parameter10: java.util.Map$Entry[];
specialinvoke v0.<io.netty.handler.ssl.SslContext: void <init>(boolean)>(v8);
v12 = new io.netty.handler.ssl.ReferenceCountedOpenSslContext$1;
specialinvoke v12.<io.netty.handler.ssl.ReferenceCountedOpenSslContext$1: void <init>(io.netty.handler.ssl.ReferenceCountedOpenSslContext)>(v0);
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.util.AbstractReferenceCounted refCnt> = v12;
v13 = new io.netty.handler.ssl.ReferenceCountedOpenSslContext$DefaultOpenSslEngineMap;
specialinvoke v13.<io.netty.handler.ssl.ReferenceCountedOpenSslContext$DefaultOpenSslEngineMap: void <init>()>();
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.handler.ssl.OpenSslEngineMap engineMap> = v13;
v14 = new java.util.concurrent.locks.ReentrantReadWriteLock;
specialinvoke v14.<java.util.concurrent.locks.ReentrantReadWriteLock: void <init>()>();
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.concurrent.locks.ReadWriteLock ctxLock> = v14;
v15 = <io.netty.handler.ssl.ReferenceCountedOpenSslContext: int DEFAULT_BIO_NON_APPLICATION_BUFFER_SIZE>;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: int bioNonApplicationBufferSize> = v15;
staticinvoke <io.netty.handler.ssl.OpenSsl: void ensureAvailability()>();
if v9 == 0 goto label01;
v16 = staticinvoke <io.netty.handler.ssl.OpenSsl: boolean isOcspSupported()>();
if v16 != 0 goto label01;
v17 = new java.lang.IllegalStateException;
specialinvoke v17.<java.lang.IllegalStateException: void <init>(java.lang.String)>("OCSP is not supported.");
throw v17;
label01:
if v4 == 1 goto label02;
if v4 == 0 goto label02;
v18 = new java.lang.IllegalArgumentException;
specialinvoke v18.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>("mode most be either SSL.SSL_MODE_SERVER or SSL.SSL_MODE_CLIENT");
throw v18;
label02:
v19 = 0;
v20 = <io.netty.handler.ssl.ReferenceCountedOpenSslContext: boolean USE_TASKS>;
if v11 == null goto label11;
v21 = lengthof v11;
v22 = 0;
label03:
if v22 >= v21 goto label11;
v23 = v11[v22];
v24 = interfaceinvoke v23.<java.util.Map$Entry: java.lang.Object getKey()>();
v25 = <io.netty.handler.ssl.OpenSslContextOption: io.netty.handler.ssl.OpenSslContextOption TLS_FALSE_START>;
if v24 != v25 goto label04;
v26 = interfaceinvoke v23.<java.util.Map$Entry: java.lang.Object getValue()>();
v19 = virtualinvoke v26.<java.lang.Boolean: boolean booleanValue()>();
goto label10;
label04:
v27 = <io.netty.handler.ssl.OpenSslContextOption: io.netty.handler.ssl.OpenSslContextOption USE_TASKS>;
if v24 != v27 goto label05;
v28 = interfaceinvoke v23.<java.util.Map$Entry: java.lang.Object getValue()>();
v20 = virtualinvoke v28.<java.lang.Boolean: boolean booleanValue()>();
goto label10;
label05:
v29 = <io.netty.handler.ssl.OpenSslContextOption: io.netty.handler.ssl.OpenSslContextOption PRIVATE_KEY_METHOD>;
if v24 != v29 goto label06;
v30 = interfaceinvoke v23.<java.util.Map$Entry: java.lang.Object getValue()>();
goto label10;
label06:
v31 = <io.netty.handler.ssl.OpenSslContextOption: io.netty.handler.ssl.OpenSslContextOption ASYNC_PRIVATE_KEY_METHOD>;
if v24 != v31 goto label07;
v32 = interfaceinvoke v23.<java.util.Map$Entry: java.lang.Object getValue()>();
goto label10;
label07:
v33 = <io.netty.handler.ssl.OpenSslContextOption: io.netty.handler.ssl.OpenSslContextOption CERTIFICATE_COMPRESSION_ALGORITHMS>;
if v24 != v33 goto label08;
v34 = interfaceinvoke v23.<java.util.Map$Entry: java.lang.Object getValue()>();
goto label10;
label08:
v35 = <io.netty.handler.ssl.OpenSslContextOption: io.netty.handler.ssl.OpenSslContextOption MAX_CERTIFICATE_LIST_BYTES>;
if v24 != v35 goto label09;
v36 = interfaceinvoke v23.<java.util.Map$Entry: java.lang.Object getValue()>();
goto label10;
label09:
v37 = <io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.util.internal.logging.InternalLogger logger>;
v38 = class "Lio/netty/handler/ssl/SslContextOption;";
v39 = virtualinvoke v38.<java.lang.Class: java.lang.String getSimpleName()>();
v40 = interfaceinvoke v23.<java.util.Map$Entry: java.lang.Object getKey()>();
v41 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.Object)>(v39, v40) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Skipping unsupported \u0001: \u0001");
interfaceinvoke v37.<io.netty.util.internal.logging.InternalLogger: void debug(java.lang.String)>(v41);
label10:
v22 = v22 + 1;
goto label03;
label11:
if v30 == null goto label12;
if v32 == null goto label12;
v42 = new java.lang.IllegalArgumentException;
v43 = class "Lio/netty/handler/ssl/OpenSslAsyncPrivateKeyMethod;";
v44 = virtualinvoke v43.<java.lang.Class: java.lang.String getSimpleName()>();
v45 = class "Lio/netty/handler/ssl/OpenSslPrivateKeyMethod;";
v46 = virtualinvoke v45.<java.lang.Class: java.lang.String getSimpleName()>();
v47 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v44, v46) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("You can either only use \u0001 or \u0001");
specialinvoke v42.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(v47);
throw v42;
label12:
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: boolean tlsFalseStart> = v19;
if v10 == 0 goto label13;
v48 = <io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.util.ResourceLeakDetector leakDetector>;
v49 = virtualinvoke v48.<io.netty.util.ResourceLeakDetector: io.netty.util.ResourceLeakTracker track(java.lang.Object)>(v0);
goto label14;
label13:
v49 = null;
label14:
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.util.ResourceLeakTracker leak> = v49;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: int mode> = v4;
v50 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: boolean isServer()>();
if v50 == 0 goto label15;
v51 = staticinvoke <io.netty.util.internal.ObjectUtil: java.lang.Object checkNotNull(java.lang.Object,java.lang.String)>(v6, "clientAuth");
goto label16;
label15:
v51 = <io.netty.handler.ssl.ClientAuth: io.netty.handler.ssl.ClientAuth NONE>;
label16:
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.handler.ssl.ClientAuth clientAuth> = v51;
if v7 != null goto label19;
if v4 != 0 goto label17;
v52 = 1;
goto label18;
label17:
v52 = 0;
label18:
v53 = staticinvoke <io.netty.handler.ssl.OpenSsl: java.lang.String[] defaultProtocols(boolean)>(v52);
goto label20;
label19:
v53 = v7;
label20:
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.lang.String[] protocols> = v53;
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: boolean enableOcsp> = v9;
if v5 == null goto label21;
v54 = virtualinvoke v5.<java.lang.Object: java.lang.Object clone()>();
label21:
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.security.cert.Certificate[] keyCertChain> = v54;
v55 = staticinvoke <io.netty.util.internal.ObjectUtil: java.lang.Object checkNotNull(java.lang.Object,java.lang.String)>(v2, "cipherFilter");
v56 = <io.netty.handler.ssl.OpenSsl: java.util.List DEFAULT_CIPHERS>;
v57 = staticinvoke <io.netty.handler.ssl.OpenSsl: java.util.Set availableJavaCipherSuites()>();
v58 = interfaceinvoke v55.<io.netty.handler.ssl.CipherSuiteFilter: java.lang.String[] filterCipherSuites(java.lang.Iterable,java.util.List,java.util.Set)>(v1, v56, v57);
v59 = new java.util.LinkedHashSet;
v60 = lengthof v58;
specialinvoke v59.<java.util.LinkedHashSet: void <init>(int)>(v60);
staticinvoke <java.util.Collections: boolean addAll(java.util.Collection,java.lang.Object[])>(v59, v58);
v61 = new java.util.ArrayList;
specialinvoke v61.<java.util.ArrayList: void <init>(java.util.Collection)>(v59);
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.List unmodifiableCiphers> = v61;
v62 = staticinvoke <io.netty.util.internal.ObjectUtil: java.lang.Object checkNotNull(java.lang.Object,java.lang.String)>(v3, "apn");
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator apn> = v62;
label22:
v63 = staticinvoke <io.netty.handler.ssl.OpenSsl: boolean isTlsv13Supported()>();
label23:
v64 = 30;
if v63 == 0 goto label24;
v64 = 62;
label24:
v65 = staticinvoke <io.netty.internal.tcnative.SSLContext: long make(int,int)>(v64, v4);
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx> = v65;
label25:
goto label27;
label26:
v66 := @caughtexception;
v67 = new javax.net.ssl.SSLException;
specialinvoke v67.<javax.net.ssl.SSLException: void <init>(java.lang.String,java.lang.Throwable)>("failed to create an SSL_CTX", v66);
throw v67;
label27:
v68 = new java.lang.StringBuilder;
specialinvoke v68.<java.lang.StringBuilder: void <init>()>();
v69 = new java.lang.StringBuilder;
specialinvoke v69.<java.lang.StringBuilder: void <init>()>();
label28:
v70 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.List unmodifiableCiphers>;
v71 = interfaceinvoke v70.<java.util.List: boolean isEmpty()>();
if v71 == 0 goto label29;
v72 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
staticinvoke <io.netty.internal.tcnative.SSLContext: boolean setCipherSuite(long,java.lang.String,boolean)>(v72, "", 0);
if v63 == 0 goto label33;
v73 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
staticinvoke <io.netty.internal.tcnative.SSLContext: boolean setCipherSuite(long,java.lang.String,boolean)>(v73, "", 1);
goto label33;
label29:
v74 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.List unmodifiableCiphers>;
v75 = staticinvoke <io.netty.handler.ssl.OpenSsl: boolean isBoringSSL()>();
staticinvoke <io.netty.handler.ssl.CipherSuiteConverter: void convertToCipherStrings(java.lang.Iterable,java.lang.StringBuilder,java.lang.StringBuilder,boolean)>(v74, v68, v69, v75);
v76 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v77 = virtualinvoke v68.<java.lang.StringBuilder: java.lang.String toString()>();
staticinvoke <io.netty.internal.tcnative.SSLContext: boolean setCipherSuite(long,java.lang.String,boolean)>(v76, v77, 0);
if v63 == 0 goto label33;
v78 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v79 = <io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.util.internal.logging.InternalLogger logger>;
v80 = virtualinvoke v69.<java.lang.StringBuilder: java.lang.String toString()>();
v81 = staticinvoke <io.netty.handler.ssl.OpenSsl: java.lang.String checkTls13Ciphers(io.netty.util.internal.logging.InternalLogger,java.lang.String)>(v79, v80);
staticinvoke <io.netty.internal.tcnative.SSLContext: boolean setCipherSuite(long,java.lang.String,boolean)>(v78, v81, 1);
label30:
goto label33;
label31:
v82 := @caughtexception;
throw v82;
label32:
v83 := @caughtexception;
v84 = new javax.net.ssl.SSLException;
v85 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.List unmodifiableCiphers>;
v86 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.util.List)>(v85) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("failed to set cipher suite: \u0001");
specialinvoke v84.<javax.net.ssl.SSLException: void <init>(java.lang.String,java.lang.Throwable)>(v86, v83);
throw v84;
label33:
v87 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v88 = staticinvoke <io.netty.internal.tcnative.SSLContext: int getOptions(long)>(v87);
v89 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_SSLv2>;
v90 = v88 | v89;
v91 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_SSLv3>;
v92 = v90 | v91;
v93 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_TLSv1>;
v94 = v92 | v93;
v95 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_TLSv1_1>;
v96 = v94 | v95;
v97 = <io.netty.internal.tcnative.SSL: int SSL_OP_CIPHER_SERVER_PREFERENCE>;
v98 = v96 | v97;
v99 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_COMPRESSION>;
v100 = v98 | v99;
v101 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_TICKET>;
v102 = v100 | v101;
v103 = virtualinvoke v68.<java.lang.StringBuilder: int length()>();
if v103 != 0 goto label34;
v104 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_SSLv2>;
v105 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_SSLv3>;
v106 = v104 | v105;
v107 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_TLSv1>;
v108 = v106 | v107;
v109 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_TLSv1_1>;
v110 = v108 | v109;
v111 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_TLSv1_2>;
v112 = v110 | v111;
v102 = v102 | v112;
label34:
if v63 != 0 goto label35;
v113 = <io.netty.internal.tcnative.SSL: int SSL_OP_NO_TLSv1_3>;
v102 = v102 | v113;
label35:
v114 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
staticinvoke <io.netty.internal.tcnative.SSLContext: void setOptions(long,int)>(v114, v102);
v115 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v116 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v117 = staticinvoke <io.netty.internal.tcnative.SSLContext: int getMode(long)>(v116);
v118 = <io.netty.internal.tcnative.SSL: int SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER>;
v119 = v117 | v118;
staticinvoke <io.netty.internal.tcnative.SSLContext: int setMode(long,int)>(v115, v119);
v120 = <io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.lang.Integer DH_KEY_LENGTH>;
if v120 == null goto label36;
v121 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v122 = <io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.lang.Integer DH_KEY_LENGTH>;
v123 = virtualinvoke v122.<java.lang.Integer: int intValue()>();
staticinvoke <io.netty.internal.tcnative.SSLContext: void setTmpDHLength(long,int)>(v121, v123);
label36:
v124 = interfaceinvoke v3.<io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator: java.util.List protocols()>();
v125 = interfaceinvoke v124.<java.util.List: boolean isEmpty()>();
if v125 != 0 goto label41;
v126 = newarray (java.lang.String)[0];
v127 = interfaceinvoke v124.<java.util.List: java.lang.Object[] toArray(java.lang.Object[])>(v126);
v128 = interfaceinvoke v3.<io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator: io.netty.handler.ssl.ApplicationProtocolConfig$SelectorFailureBehavior selectorFailureBehavior()>();
v129 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslContext: int opensslSelectorFailureBehavior(io.netty.handler.ssl.ApplicationProtocolConfig$SelectorFailureBehavior)>(v128);
v130 = <io.netty.handler.ssl.ReferenceCountedOpenSslContext$3: int[] $SwitchMap$io$netty$handler$ssl$ApplicationProtocolConfig$Protocol>;
v131 = interfaceinvoke v3.<io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator: io.netty.handler.ssl.ApplicationProtocolConfig$Protocol protocol()>();
v132 = virtualinvoke v131.<io.netty.handler.ssl.ApplicationProtocolConfig$Protocol: int ordinal()>();
v133 = v130[v132];
tableswitch(v133)
{
case 1: goto label37;
case 2: goto label38;
case 3: goto label39;
default: goto label40;
};
label37:
v134 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
staticinvoke <io.netty.internal.tcnative.SSLContext: void setNpnProtos(long,java.lang.String[],int)>(v134, v127, v129);
goto label41;
label38:
v135 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
staticinvoke <io.netty.internal.tcnative.SSLContext: void setAlpnProtos(long,java.lang.String[],int)>(v135, v127, v129);
goto label41;
label39:
v136 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
staticinvoke <io.netty.internal.tcnative.SSLContext: void setNpnProtos(long,java.lang.String[],int)>(v136, v127, v129);
v137 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
staticinvoke <io.netty.internal.tcnative.SSLContext: void setAlpnProtos(long,java.lang.String[],int)>(v137, v127, v129);
goto label41;
label40:
v138 = new java.lang.Error;
specialinvoke v138.<java.lang.Error: void <init>()>();
throw v138;
label41:
if v9 == 0 goto label42;
v139 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v140 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: boolean isClient()>();
staticinvoke <io.netty.internal.tcnative.SSLContext: void enableOcsp(long,boolean)>(v139, v140);
label42:
v141 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
staticinvoke <io.netty.internal.tcnative.SSLContext: void setUseTasks(long,boolean)>(v141, v20);
if v30 == null goto label43;
v142 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v143 = new io.netty.handler.ssl.ReferenceCountedOpenSslContext$PrivateKeyMethod;
v144 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.handler.ssl.OpenSslEngineMap engineMap>;
specialinvoke v143.<io.netty.handler.ssl.ReferenceCountedOpenSslContext$PrivateKeyMethod: void <init>(io.netty.handler.ssl.OpenSslEngineMap,io.netty.handler.ssl.OpenSslPrivateKeyMethod)>(v144, v30);
staticinvoke <io.netty.internal.tcnative.SSLContext: void setPrivateKeyMethod(long,io.netty.internal.tcnative.SSLPrivateKeyMethod)>(v142, v143);
label43:
if v32 == null goto label44;
v145 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v146 = new io.netty.handler.ssl.ReferenceCountedOpenSslContext$AsyncPrivateKeyMethod;
v147 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.handler.ssl.OpenSslEngineMap engineMap>;
specialinvoke v146.<io.netty.handler.ssl.ReferenceCountedOpenSslContext$AsyncPrivateKeyMethod: void <init>(io.netty.handler.ssl.OpenSslEngineMap,io.netty.handler.ssl.OpenSslAsyncPrivateKeyMethod)>(v147, v32);
staticinvoke <io.netty.internal.tcnative.SSLContext: void setPrivateKeyMethod(long,io.netty.internal.tcnative.AsyncSSLPrivateKeyMethod)>(v145, v146);
label44:
if v34 == null goto label50;
v148 = virtualinvoke v34.<io.netty.handler.ssl.OpenSslCertificateCompressionConfig: java.util.Iterator iterator()>();
label45:
v149 = interfaceinvoke v148.<java.util.Iterator: boolean hasNext()>();
if v149 == 0 goto label50;
v150 = interfaceinvoke v148.<java.util.Iterator: java.lang.Object next()>();
v151 = new io.netty.handler.ssl.ReferenceCountedOpenSslContext$CompressionAlgorithm;
v152 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.handler.ssl.OpenSslEngineMap engineMap>;
v153 = virtualinvoke v150.<io.netty.handler.ssl.OpenSslCertificateCompressionConfig$AlgorithmConfig: io.netty.handler.ssl.OpenSslCertificateCompressionAlgorithm algorithm()>();
specialinvoke v151.<io.netty.handler.ssl.ReferenceCountedOpenSslContext$CompressionAlgorithm: void <init>(io.netty.handler.ssl.OpenSslEngineMap,io.netty.handler.ssl.OpenSslCertificateCompressionAlgorithm)>(v152, v153);
v154 = <io.netty.handler.ssl.ReferenceCountedOpenSslContext$3: int[] $SwitchMap$io$netty$handler$ssl$OpenSslCertificateCompressionConfig$AlgorithmMode>;
v155 = virtualinvoke v150.<io.netty.handler.ssl.OpenSslCertificateCompressionConfig$AlgorithmConfig: io.netty.handler.ssl.OpenSslCertificateCompressionConfig$AlgorithmMode mode()>();
v156 = virtualinvoke v155.<io.netty.handler.ssl.OpenSslCertificateCompressionConfig$AlgorithmMode: int ordinal()>();
v157 = v154[v156];
tableswitch(v157)
{
case 1: goto label46;
case 2: goto label47;
case 3: goto label48;
default: goto label49;
};
label46:
v158 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v159 = <io.netty.internal.tcnative.SSL: int SSL_CERT_COMPRESSION_DIRECTION_DECOMPRESS>;
staticinvoke <io.netty.internal.tcnative.SSLContext: int addCertificateCompressionAlgorithm(long,int,io.netty.internal.tcnative.CertificateCompressionAlgo)>(v158, v159, v151);
goto label45;
label47:
v160 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v161 = <io.netty.internal.tcnative.SSL: int SSL_CERT_COMPRESSION_DIRECTION_COMPRESS>;
staticinvoke <io.netty.internal.tcnative.SSLContext: int addCertificateCompressionAlgorithm(long,int,io.netty.internal.tcnative.CertificateCompressionAlgo)>(v160, v161, v151);
goto label45;
label48:
v162 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v163 = <io.netty.internal.tcnative.SSL: int SSL_CERT_COMPRESSION_DIRECTION_BOTH>;
staticinvoke <io.netty.internal.tcnative.SSLContext: int addCertificateCompressionAlgorithm(long,int,io.netty.internal.tcnative.CertificateCompressionAlgo)>(v162, v163, v151);
goto label45;
label49:
v164 = new java.lang.IllegalStateException;
specialinvoke v164.<java.lang.IllegalStateException: void <init>()>();
throw v164;
label50:
if v36 == null goto label51;
v165 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v166 = virtualinvoke v36.<java.lang.Integer: int intValue()>();
staticinvoke <io.netty.internal.tcnative.SSLContext: void setMaxCertList(long,int)>(v165, v166);
label51:
v167 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v168 = <io.netty.handler.ssl.OpenSsl: java.lang.String[] NAMED_GROUPS>;
staticinvoke <io.netty.internal.tcnative.SSLContext: boolean setCurvesList(long,java.lang.String[])>(v167, v168);
label52:
goto label54;
label53:
v169 := @caughtexception;
virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: boolean release()>();
throw v169;
label54:
return;
catch java.lang.Exception from label23 to label25 with label26;
catch javax.net.ssl.SSLException from label28 to label30 with label31;
catch java.lang.Exception from label28 to label30 with label32;
catch java.lang.Throwable from label22 to label52 with label53;
}
private static int opensslSelectorFailureBehavior(io.netty.handler.ssl.ApplicationProtocolConfig$SelectorFailureBehavior)
{
io.netty.handler.ssl.ApplicationProtocolConfig$SelectorFailureBehavior v0;
int[] v1;
int v2, v3;
java.lang.Error v4;
v0 := @parameter0: io.netty.handler.ssl.ApplicationProtocolConfig$SelectorFailureBehavior;
v1 = <io.netty.handler.ssl.ReferenceCountedOpenSslContext$3: int[] $SwitchMap$io$netty$handler$ssl$ApplicationProtocolConfig$SelectorFailureBehavior>;
v2 = virtualinvoke v0.<io.netty.handler.ssl.ApplicationProtocolConfig$SelectorFailureBehavior: int ordinal()>();
v3 = v1[v2];
lookupswitch(v3)
{
case 1: goto label1;
case 2: goto label2;
default: goto label3;
};
label1:
return 0;
label2:
return 1;
label3:
v4 = new java.lang.Error;
specialinvoke v4.<java.lang.Error: void <init>()>();
throw v4;
}
public final java.util.List cipherSuites()
{
java.util.List v1;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.List unmodifiableCiphers>;
return v1;
}
public io.netty.handler.ssl.ApplicationProtocolNegotiator applicationProtocolNegotiator()
{
io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator v1;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator apn>;
return v1;
}
public final boolean isClient()
{
int v1;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
boolean v2;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: int mode>;
if v1 != 0 goto label1;
v2 = 1;
goto label2;
label1:
v2 = 0;
label2:
return v2;
}
public final javax.net.ssl.SSLEngine newEngine(io.netty.buffer.ByteBufAllocator, java.lang.String, int)
{
io.netty.buffer.ByteBufAllocator v1;
int v3;
java.lang.String v2;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
javax.net.ssl.SSLEngine v4;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 := @parameter0: io.netty.buffer.ByteBufAllocator;
v2 := @parameter1: java.lang.String;
v3 := @parameter2: int;
v4 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: javax.net.ssl.SSLEngine newEngine0(io.netty.buffer.ByteBufAllocator,java.lang.String,int,boolean)>(v1, v2, v3, 1);
return v4;
}
protected final io.netty.handler.ssl.SslHandler newHandler(io.netty.buffer.ByteBufAllocator, boolean)
{
io.netty.handler.ssl.SslHandler v3;
io.netty.buffer.ByteBufAllocator v1;
int v4;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
boolean v2;
javax.net.ssl.SSLEngine v5;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 := @parameter0: io.netty.buffer.ByteBufAllocator;
v2 := @parameter1: boolean;
v3 = new io.netty.handler.ssl.SslHandler;
v4 = (int) -1;
v5 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: javax.net.ssl.SSLEngine newEngine0(io.netty.buffer.ByteBufAllocator,java.lang.String,int,boolean)>(v1, null, v4, 0);
specialinvoke v3.<io.netty.handler.ssl.SslHandler: void <init>(javax.net.ssl.SSLEngine,boolean)>(v5, v2);
return v3;
}
protected final io.netty.handler.ssl.SslHandler newHandler(io.netty.buffer.ByteBufAllocator, java.lang.String, int, boolean)
{
io.netty.handler.ssl.SslHandler v5;
io.netty.buffer.ByteBufAllocator v1;
int v3;
java.lang.String v2;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
boolean v4;
javax.net.ssl.SSLEngine v6;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 := @parameter0: io.netty.buffer.ByteBufAllocator;
v2 := @parameter1: java.lang.String;
v3 := @parameter2: int;
v4 := @parameter3: boolean;
v5 = new io.netty.handler.ssl.SslHandler;
v6 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: javax.net.ssl.SSLEngine newEngine0(io.netty.buffer.ByteBufAllocator,java.lang.String,int,boolean)>(v1, v2, v3, 0);
specialinvoke v5.<io.netty.handler.ssl.SslHandler: void <init>(javax.net.ssl.SSLEngine,boolean)>(v6, v4);
return v5;
}
protected io.netty.handler.ssl.SslHandler newHandler(io.netty.buffer.ByteBufAllocator, boolean, java.util.concurrent.Executor)
{
io.netty.handler.ssl.SslHandler v4;
java.util.concurrent.Executor v3;
io.netty.buffer.ByteBufAllocator v1;
int v5;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
boolean v2;
javax.net.ssl.SSLEngine v6;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 := @parameter0: io.netty.buffer.ByteBufAllocator;
v2 := @parameter1: boolean;
v3 := @parameter2: java.util.concurrent.Executor;
v4 = new io.netty.handler.ssl.SslHandler;
v5 = (int) -1;
v6 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: javax.net.ssl.SSLEngine newEngine0(io.netty.buffer.ByteBufAllocator,java.lang.String,int,boolean)>(v1, null, v5, 0);
specialinvoke v4.<io.netty.handler.ssl.SslHandler: void <init>(javax.net.ssl.SSLEngine,boolean,java.util.concurrent.Executor)>(v6, v2, v3);
return v4;
}
protected io.netty.handler.ssl.SslHandler newHandler(io.netty.buffer.ByteBufAllocator, java.lang.String, int, boolean, java.util.concurrent.Executor)
{
java.util.concurrent.Executor v5;
io.netty.buffer.ByteBufAllocator v1;
javax.net.ssl.SSLEngine v7;
io.netty.handler.ssl.SslHandler v6;
int v3;
java.lang.String v2;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
boolean v4;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 := @parameter0: io.netty.buffer.ByteBufAllocator;
v2 := @parameter1: java.lang.String;
v3 := @parameter2: int;
v4 := @parameter3: boolean;
v5 := @parameter4: java.util.concurrent.Executor;
v6 = new io.netty.handler.ssl.SslHandler;
v7 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: javax.net.ssl.SSLEngine newEngine0(io.netty.buffer.ByteBufAllocator,java.lang.String,int,boolean)>(v1, v2, v3, 0);
specialinvoke v6.<io.netty.handler.ssl.SslHandler: void <init>(javax.net.ssl.SSLEngine,java.util.concurrent.Executor)>(v7, v5);
return v6;
}
javax.net.ssl.SSLEngine newEngine0(io.netty.buffer.ByteBufAllocator, java.lang.String, int, boolean)
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v5;
io.netty.buffer.ByteBufAllocator v1;
int v3;
java.lang.String v2;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
boolean v4;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 := @parameter0: io.netty.buffer.ByteBufAllocator;
v2 := @parameter1: java.lang.String;
v3 := @parameter2: int;
v4 := @parameter3: boolean;
v5 = new io.netty.handler.ssl.ReferenceCountedOpenSslEngine;
specialinvoke v5.<io.netty.handler.ssl.ReferenceCountedOpenSslEngine: void <init>(io.netty.handler.ssl.ReferenceCountedOpenSslContext,io.netty.buffer.ByteBufAllocator,java.lang.String,int,boolean,boolean)>(v0, v1, v2, v3, v4, 1);
return v5;
}
public final javax.net.ssl.SSLEngine newEngine(io.netty.buffer.ByteBufAllocator)
{
io.netty.buffer.ByteBufAllocator v1;
int v2;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
javax.net.ssl.SSLEngine v3;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 := @parameter0: io.netty.buffer.ByteBufAllocator;
v2 = (int) -1;
v3 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: javax.net.ssl.SSLEngine newEngine(io.netty.buffer.ByteBufAllocator,java.lang.String,int)>(v1, null, v2);
return v3;
}
public final long context()
{
long v1;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long sslCtxPointer()>();
return v1;
}
public final io.netty.handler.ssl.OpenSslSessionStats stats()
{
io.netty.handler.ssl.OpenSslSessionContext v1;
io.netty.handler.ssl.OpenSslSessionStats v2;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.handler.ssl.OpenSslSessionContext sessionContext()>();
v2 = virtualinvoke v1.<io.netty.handler.ssl.OpenSslSessionContext: io.netty.handler.ssl.OpenSslSessionStats stats()>();
return v2;
}
public void setRejectRemoteInitiatedRenegotiation(boolean)
{
java.lang.UnsupportedOperationException v2;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
boolean v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 := @parameter0: boolean;
if v1 != 0 goto label1;
v2 = new java.lang.UnsupportedOperationException;
specialinvoke v2.<java.lang.UnsupportedOperationException: void <init>(java.lang.String)>("Renegotiation is not supported");
throw v2;
label1:
return;
}
public boolean getRejectRemoteInitiatedRenegotiation()
{
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
return 1;
}
public void setBioNonApplicationBufferSize(int)
{
int v1, v2;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 := @parameter0: int;
v2 = staticinvoke <io.netty.util.internal.ObjectUtil: int checkPositiveOrZero(int,java.lang.String)>(v1, "bioNonApplicationBufferSize");
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: int bioNonApplicationBufferSize> = v2;
return;
}
public int getBioNonApplicationBufferSize()
{
int v1;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: int bioNonApplicationBufferSize>;
return v1;
}
public final void setTicketKeys(byte[])
{
byte[] v1;
io.netty.handler.ssl.OpenSslSessionContext v2;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 := @parameter0: byte[];
v2 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.handler.ssl.OpenSslSessionContext sessionContext()>();
virtualinvoke v2.<io.netty.handler.ssl.OpenSslSessionContext: void setTicketKeys(byte[])>(v1);
return;
}
public abstract io.netty.handler.ssl.OpenSslSessionContext sessionContext();
public final long sslCtxPointer()
{
java.lang.Throwable v5;
java.util.concurrent.locks.Lock v2;
long v3, v4;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
java.util.concurrent.locks.ReadWriteLock v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.concurrent.locks.ReadWriteLock ctxLock>;
v2 = interfaceinvoke v1.<java.util.concurrent.locks.ReadWriteLock: java.util.concurrent.locks.Lock readLock()>();
interfaceinvoke v2.<java.util.concurrent.locks.Lock: void lock()>();
label1:
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v4 = staticinvoke <io.netty.internal.tcnative.SSLContext: long getSslCtx(long)>(v3);
label2:
interfaceinvoke v2.<java.util.concurrent.locks.Lock: void unlock()>();
return v4;
label3:
v5 := @caughtexception;
interfaceinvoke v2.<java.util.concurrent.locks.Lock: void unlock()>();
throw v5;
catch java.lang.Throwable from label1 to label2 with label3;
}
public final void setPrivateKeyMethod(io.netty.handler.ssl.OpenSslPrivateKeyMethod)
{
java.lang.Throwable v7;
io.netty.handler.ssl.OpenSslEngineMap v6;
io.netty.handler.ssl.ReferenceCountedOpenSslContext$PrivateKeyMethod v5;
long v4;
java.util.concurrent.locks.Lock v3;
io.netty.handler.ssl.OpenSslPrivateKeyMethod v1;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
java.util.concurrent.locks.ReadWriteLock v2;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 := @parameter0: io.netty.handler.ssl.OpenSslPrivateKeyMethod;
staticinvoke <io.netty.util.internal.ObjectUtil: java.lang.Object checkNotNull(java.lang.Object,java.lang.String)>(v1, "method");
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.concurrent.locks.ReadWriteLock ctxLock>;
v3 = interfaceinvoke v2.<java.util.concurrent.locks.ReadWriteLock: java.util.concurrent.locks.Lock writeLock()>();
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void lock()>();
label1:
v4 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v5 = new io.netty.handler.ssl.ReferenceCountedOpenSslContext$PrivateKeyMethod;
v6 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.handler.ssl.OpenSslEngineMap engineMap>;
specialinvoke v5.<io.netty.handler.ssl.ReferenceCountedOpenSslContext$PrivateKeyMethod: void <init>(io.netty.handler.ssl.OpenSslEngineMap,io.netty.handler.ssl.OpenSslPrivateKeyMethod)>(v6, v1);
staticinvoke <io.netty.internal.tcnative.SSLContext: void setPrivateKeyMethod(long,io.netty.internal.tcnative.SSLPrivateKeyMethod)>(v4, v5);
label2:
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
goto label4;
label3:
v7 := @caughtexception;
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
throw v7;
label4:
return;
catch java.lang.Throwable from label1 to label2 with label3;
}
public final void setUseTasks(boolean)
{
java.lang.Throwable v5;
java.util.concurrent.locks.Lock v3;
long v4;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
java.util.concurrent.locks.ReadWriteLock v2;
boolean v1;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 := @parameter0: boolean;
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.concurrent.locks.ReadWriteLock ctxLock>;
v3 = interfaceinvoke v2.<java.util.concurrent.locks.ReadWriteLock: java.util.concurrent.locks.Lock writeLock()>();
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void lock()>();
label1:
v4 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
staticinvoke <io.netty.internal.tcnative.SSLContext: void setUseTasks(long,boolean)>(v4, v1);
label2:
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
goto label4;
label3:
v5 := @caughtexception;
interfaceinvoke v3.<java.util.concurrent.locks.Lock: void unlock()>();
throw v5;
label4:
return;
catch java.lang.Throwable from label1 to label2 with label3;
}
private void destroy()
{
java.lang.Throwable v9;
long v3, v6, v7;
java.util.concurrent.locks.Lock v2;
byte v4;
io.netty.handler.ssl.OpenSslSessionContext v8;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
java.util.concurrent.locks.ReadWriteLock v1;
boolean v5;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.util.concurrent.locks.ReadWriteLock ctxLock>;
v2 = interfaceinvoke v1.<java.util.concurrent.locks.ReadWriteLock: java.util.concurrent.locks.Lock writeLock()>();
interfaceinvoke v2.<java.util.concurrent.locks.Lock: void lock()>();
label1:
v3 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
v4 = v3 cmp 0L;
if v4 == 0 goto label3;
v5 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: boolean enableOcsp>;
if v5 == 0 goto label2;
v6 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
staticinvoke <io.netty.internal.tcnative.SSLContext: void disableOcsp(long)>(v6);
label2:
v7 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx>;
staticinvoke <io.netty.internal.tcnative.SSLContext: int free(long)>(v7);
v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: long ctx> = 0L;
v8 = virtualinvoke v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.handler.ssl.OpenSslSessionContext sessionContext()>();
if v8 == null goto label3;
virtualinvoke v8.<io.netty.handler.ssl.OpenSslSessionContext: void destroy()>();
label3:
interfaceinvoke v2.<java.util.concurrent.locks.Lock: void unlock()>();
goto label5;
label4:
v9 := @caughtexception;
interfaceinvoke v2.<java.util.concurrent.locks.Lock: void unlock()>();
throw v9;
label5:
return;
catch java.lang.Throwable from label1 to label3 with label4;
}
protected static java.security.cert.X509Certificate[] certificates(byte[][])
{
byte[] v6;
byte[][] v0;
int v1, v3, v4;
io.netty.handler.ssl.util.LazyX509Certificate v5;
java.security.cert.X509Certificate[] v2;
v0 := @parameter0: byte[][];
v1 = lengthof v0;
v2 = newarray (java.security.cert.X509Certificate)[v1];
v3 = 0;
label1:
v4 = lengthof v2;
if v3 >= v4 goto label2;
v5 = new io.netty.handler.ssl.util.LazyX509Certificate;
v6 = v0[v3];
specialinvoke v5.<io.netty.handler.ssl.util.LazyX509Certificate: void <init>(byte[])>(v6);
v2[v3] = v5;
v3 = v3 + 1;
goto label1;
label2:
return v2;
}
protected static javax.net.ssl.X509TrustManager chooseTrustManager(javax.net.ssl.TrustManager[])
{
java.lang.IllegalStateException v7;
javax.net.ssl.TrustManager v3;
javax.net.ssl.TrustManager[] v0;
javax.net.ssl.X509TrustManager v6;
int v1, v2, v5;
boolean v4;
v0 := @parameter0: javax.net.ssl.TrustManager[];
v1 = lengthof v0;
v2 = 0;
label1:
if v2 >= v1 goto label4;
v3 = v0[v2];
v4 = v3 instanceof javax.net.ssl.X509TrustManager;
if v4 == 0 goto label3;
v5 = staticinvoke <io.netty.util.internal.PlatformDependent: int javaVersion()>();
if v5 < 7 goto label2;
v6 = staticinvoke <io.netty.handler.ssl.OpenSslX509TrustManagerWrapper: javax.net.ssl.X509TrustManager wrapIfNeeded(javax.net.ssl.X509TrustManager)>(v3);
return v6;
label2:
return v3;
label3:
v2 = v2 + 1;
goto label1;
label4:
v7 = new java.lang.IllegalStateException;
specialinvoke v7.<java.lang.IllegalStateException: void <init>(java.lang.String)>("no X509TrustManager found");
throw v7;
}
protected static javax.net.ssl.X509KeyManager chooseX509KeyManager(javax.net.ssl.KeyManager[])
{
java.lang.IllegalStateException v5;
int v1, v2;
javax.net.ssl.KeyManager v3;
boolean v4;
javax.net.ssl.KeyManager[] v0;
v0 := @parameter0: javax.net.ssl.KeyManager[];
v1 = lengthof v0;
v2 = 0;
label1:
if v2 >= v1 goto label3;
v3 = v0[v2];
v4 = v3 instanceof javax.net.ssl.X509KeyManager;
if v4 == 0 goto label2;
return v3;
label2:
v2 = v2 + 1;
goto label1;
label3:
v5 = new java.lang.IllegalStateException;
specialinvoke v5.<java.lang.IllegalStateException: void <init>(java.lang.String)>("no X509KeyManager found");
throw v5;
}
static io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator toNegotiator(io.netty.handler.ssl.ApplicationProtocolConfig)
{
java.lang.Error v22;
io.netty.handler.ssl.ApplicationProtocolConfig$Protocol v3;
io.netty.handler.ssl.ApplicationProtocolConfig$SelectedListenerFailureBehavior v20, v8;
int[] v11, v2, v7;
int v10, v13, v14, v4, v5, v9;
java.lang.String v18, v21;
io.netty.handler.ssl.ApplicationProtocolConfig v0;
java.lang.UnsupportedOperationException v16, v19;
io.netty.handler.ssl.OpenSslDefaultApplicationProtocolNegotiator v15;
io.netty.handler.ssl.ApplicationProtocolConfig$SelectorFailureBehavior v12, v17;
io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator v1, v6;
java.lang.StringBuilder v23, v24;
v0 := @parameter0: io.netty.handler.ssl.ApplicationProtocolConfig;
if v0 != null goto label1;
v1 = <io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator NONE_PROTOCOL_NEGOTIATOR>;
return v1;
label1:
v2 = <io.netty.handler.ssl.ReferenceCountedOpenSslContext$3: int[] $SwitchMap$io$netty$handler$ssl$ApplicationProtocolConfig$Protocol>;
v3 = virtualinvoke v0.<io.netty.handler.ssl.ApplicationProtocolConfig: io.netty.handler.ssl.ApplicationProtocolConfig$Protocol protocol()>();
v4 = virtualinvoke v3.<io.netty.handler.ssl.ApplicationProtocolConfig$Protocol: int ordinal()>();
v5 = v2[v4];
tableswitch(v5)
{
case 1: goto label3;
case 2: goto label3;
case 3: goto label3;
case 4: goto label2;
default: goto label8;
};
label2:
v6 = <io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator NONE_PROTOCOL_NEGOTIATOR>;
return v6;
label3:
v7 = <io.netty.handler.ssl.ReferenceCountedOpenSslContext$3: int[] $SwitchMap$io$netty$handler$ssl$ApplicationProtocolConfig$SelectedListenerFailureBehavior>;
v8 = virtualinvoke v0.<io.netty.handler.ssl.ApplicationProtocolConfig: io.netty.handler.ssl.ApplicationProtocolConfig$SelectedListenerFailureBehavior selectedListenerFailureBehavior()>();
v9 = virtualinvoke v8.<io.netty.handler.ssl.ApplicationProtocolConfig$SelectedListenerFailureBehavior: int ordinal()>();
v10 = v7[v9];
lookupswitch(v10)
{
case 1: goto label4;
case 2: goto label4;
default: goto label7;
};
label4:
v11 = <io.netty.handler.ssl.ReferenceCountedOpenSslContext$3: int[] $SwitchMap$io$netty$handler$ssl$ApplicationProtocolConfig$SelectorFailureBehavior>;
v12 = virtualinvoke v0.<io.netty.handler.ssl.ApplicationProtocolConfig: io.netty.handler.ssl.ApplicationProtocolConfig$SelectorFailureBehavior selectorFailureBehavior()>();
v13 = virtualinvoke v12.<io.netty.handler.ssl.ApplicationProtocolConfig$SelectorFailureBehavior: int ordinal()>();
v14 = v11[v13];
lookupswitch(v14)
{
case 1: goto label5;
case 2: goto label5;
default: goto label6;
};
label5:
v15 = new io.netty.handler.ssl.OpenSslDefaultApplicationProtocolNegotiator;
specialinvoke v15.<io.netty.handler.ssl.OpenSslDefaultApplicationProtocolNegotiator: void <init>(io.netty.handler.ssl.ApplicationProtocolConfig)>(v0);
return v15;
label6:
v16 = new java.lang.UnsupportedOperationException;
specialinvoke v23.<java.lang.StringBuilder: void <init>(java.lang.String)>("OpenSSL provider does not support ");
v17 = virtualinvoke v0.<io.netty.handler.ssl.ApplicationProtocolConfig: io.netty.handler.ssl.ApplicationProtocolConfig$SelectorFailureBehavior selectorFailureBehavior()>();
v18 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (io.netty.handler.ssl.ApplicationProtocolConfig$SelectorFailureBehavior)>(v17) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001 behavior");
specialinvoke v16.<java.lang.UnsupportedOperationException: void <init>(java.lang.String)>(v18);
throw v16;
label7:
v19 = new java.lang.UnsupportedOperationException;
specialinvoke v24.<java.lang.StringBuilder: void <init>(java.lang.String)>("OpenSSL provider does not support ");
v20 = virtualinvoke v0.<io.netty.handler.ssl.ApplicationProtocolConfig: io.netty.handler.ssl.ApplicationProtocolConfig$SelectedListenerFailureBehavior selectedListenerFailureBehavior()>();
v21 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (io.netty.handler.ssl.ApplicationProtocolConfig$SelectedListenerFailureBehavior)>(v20) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001 behavior");
specialinvoke v19.<java.lang.UnsupportedOperationException: void <init>(java.lang.String)>(v21);
throw v19;
label8:
v22 = new java.lang.Error;
specialinvoke v22.<java.lang.Error: void <init>()>();
throw v22;
}
static boolean useExtendedTrustManager(javax.net.ssl.X509TrustManager)
{
javax.net.ssl.X509TrustManager v0;
int v1;
boolean v2, v3;
v0 := @parameter0: javax.net.ssl.X509TrustManager;
v1 = staticinvoke <io.netty.util.internal.PlatformDependent: int javaVersion()>();
if v1 < 7 goto label1;
v2 = v0 instanceof javax.net.ssl.X509ExtendedTrustManager;
if v2 == 0 goto label1;
v3 = 1;
goto label2;
label1:
v3 = 0;
label2:
return v3;
}
public final int refCnt()
{
int v2;
io.netty.util.AbstractReferenceCounted v1;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.util.AbstractReferenceCounted refCnt>;
v2 = virtualinvoke v1.<io.netty.util.AbstractReferenceCounted: int refCnt()>();
return v2;
}
public final io.netty.util.ReferenceCounted retain()
{
io.netty.util.AbstractReferenceCounted v1;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.util.AbstractReferenceCounted refCnt>;
virtualinvoke v1.<io.netty.util.AbstractReferenceCounted: io.netty.util.ReferenceCounted retain()>();
return v0;
}
public final io.netty.util.ReferenceCounted retain(int)
{
int v1;
io.netty.util.AbstractReferenceCounted v2;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 := @parameter0: int;
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.util.AbstractReferenceCounted refCnt>;
virtualinvoke v2.<io.netty.util.AbstractReferenceCounted: io.netty.util.ReferenceCounted retain(int)>(v1);
return v0;
}
public final io.netty.util.ReferenceCounted touch()
{
io.netty.util.AbstractReferenceCounted v1;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.util.AbstractReferenceCounted refCnt>;
virtualinvoke v1.<io.netty.util.AbstractReferenceCounted: io.netty.util.ReferenceCounted touch()>();
return v0;
}
public final io.netty.util.ReferenceCounted touch(java.lang.Object)
{
io.netty.util.AbstractReferenceCounted v2;
java.lang.Object v1;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 := @parameter0: java.lang.Object;
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.util.AbstractReferenceCounted refCnt>;
virtualinvoke v2.<io.netty.util.AbstractReferenceCounted: io.netty.util.ReferenceCounted touch(java.lang.Object)>(v1);
return v0;
}
public final boolean release()
{
io.netty.util.AbstractReferenceCounted v1;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
boolean v2;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.util.AbstractReferenceCounted refCnt>;
v2 = virtualinvoke v1.<io.netty.util.AbstractReferenceCounted: boolean release()>();
return v2;
}
public final boolean release(int)
{
int v1;
io.netty.util.AbstractReferenceCounted v2;
io.netty.handler.ssl.ReferenceCountedOpenSslContext v0;
boolean v3;
v0 := @this: io.netty.handler.ssl.ReferenceCountedOpenSslContext;
v1 := @parameter0: int;
v2 = v0.<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.util.AbstractReferenceCounted refCnt>;
v3 = virtualinvoke v2.<io.netty.util.AbstractReferenceCounted: boolean release(int)>(v1);
return v3;
}
static void setKeyMaterial(long, java.security.cert.X509Certificate[], java.security.PrivateKey, java.lang.String) throws javax.net.ssl.SSLException
{
java.lang.Throwable v20;
io.netty.buffer.ByteBufAllocator v11, v13, v8, v9;
io.netty.handler.ssl.PemEncoded v10, v12, v7;
long v0, v14, v15, v4, v5, v6;
java.lang.String v16, v3;
java.lang.Exception v18;
javax.net.ssl.SSLException v17, v19;
java.security.PrivateKey v2;
java.security.cert.X509Certificate[] v1;
v0 := @parameter0: long;
v1 := @parameter1: java.security.cert.X509Certificate[];
v2 := @parameter2: java.security.PrivateKey;
v3 := @parameter3: java.lang.String;
v4 = 0L;
v5 = 0L;
v6 = 0L;
v7 = null;
label01:
v8 = <io.netty.buffer.ByteBufAllocator: io.netty.buffer.ByteBufAllocator DEFAULT>;
v7 = staticinvoke <io.netty.handler.ssl.PemX509Certificate: io.netty.handler.ssl.PemEncoded toPEM(io.netty.buffer.ByteBufAllocator,boolean,java.security.cert.X509Certificate[])>(v8, 1, v1);
v9 = <io.netty.buffer.ByteBufAllocator: io.netty.buffer.ByteBufAllocator DEFAULT>;
v10 = interfaceinvoke v7.<io.netty.handler.ssl.PemEncoded: io.netty.handler.ssl.PemEncoded retain()>();
v5 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslContext: long toBIO(io.netty.buffer.ByteBufAllocator,io.netty.handler.ssl.PemEncoded)>(v9, v10);
v11 = <io.netty.buffer.ByteBufAllocator: io.netty.buffer.ByteBufAllocator DEFAULT>;
v12 = interfaceinvoke v7.<io.netty.handler.ssl.PemEncoded: io.netty.handler.ssl.PemEncoded retain()>();
v6 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslContext: long toBIO(io.netty.buffer.ByteBufAllocator,io.netty.handler.ssl.PemEncoded)>(v11, v12);
if v2 == null goto label02;
v13 = <io.netty.buffer.ByteBufAllocator: io.netty.buffer.ByteBufAllocator DEFAULT>;
v4 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslContext: long toBIO(io.netty.buffer.ByteBufAllocator,java.security.PrivateKey)>(v13, v2);
label02:
v14 = v5;
v15 = v4;
if v3 != null goto label03;
v16 = "";
goto label04;
label03:
v16 = v3;
label04:
staticinvoke <io.netty.internal.tcnative.SSLContext: boolean setCertificateBio(long,long,long,java.lang.String)>(v0, v14, v15, v16);
staticinvoke <io.netty.internal.tcnative.SSLContext: boolean setCertificateChainBio(long,long,boolean)>(v0, v6, 1);
label05:
staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslContext: void freeBio(long)>(v4);
staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslContext: void freeBio(long)>(v5);
staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslContext: void freeBio(long)>(v6);
interfaceinvoke v7.<io.netty.handler.ssl.PemEncoded: boolean release()>();
goto label10;
label06:
v17 := @caughtexception;
throw v17;
label07:
v18 := @caughtexception;
v19 = new javax.net.ssl.SSLException;
specialinvoke v19.<javax.net.ssl.SSLException: void <init>(java.lang.String,java.lang.Throwable)>("failed to set certificate and key", v18);
throw v19;
label08:
v20 := @caughtexception;
staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslContext: void freeBio(long)>(v4);
staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslContext: void freeBio(long)>(v5);
staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslContext: void freeBio(long)>(v6);
if v7 == null goto label09;
interfaceinvoke v7.<io.netty.handler.ssl.PemEncoded: boolean release()>();
label09:
throw v20;
label10:
return;
catch javax.net.ssl.SSLException from label01 to label05 with label06;
catch java.lang.Exception from label01 to label05 with label07;
catch java.lang.Throwable from label01 to label05 with label08;
}
static void freeBio(long)
{
long v0;
byte v1;
v0 := @parameter0: long;
v1 = v0 cmp 0L;
if v1 == 0 goto label1;
staticinvoke <io.netty.internal.tcnative.SSL: void freeBIO(long)>(v0);
label1:
return;
}
static long toBIO(io.netty.buffer.ByteBufAllocator, java.security.PrivateKey) throws java.lang.Exception
{
java.lang.Throwable v5;
java.security.PrivateKey v1;
io.netty.buffer.ByteBufAllocator v0;
io.netty.handler.ssl.PemEncoded v2, v3;
long v4;
v0 := @parameter0: io.netty.buffer.ByteBufAllocator;
v1 := @parameter1: java.security.PrivateKey;
if v1 != null goto label1;
return 0L;
label1:
v2 = staticinvoke <io.netty.handler.ssl.PemPrivateKey: io.netty.handler.ssl.PemEncoded toPEM(io.netty.buffer.ByteBufAllocator,boolean,java.security.PrivateKey)>(v0, 1, v1);
label2:
v3 = interfaceinvoke v2.<io.netty.handler.ssl.PemEncoded: io.netty.handler.ssl.PemEncoded retain()>();
v4 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslContext: long toBIO(io.netty.buffer.ByteBufAllocator,io.netty.handler.ssl.PemEncoded)>(v0, v3);
label3:
interfaceinvoke v2.<io.netty.handler.ssl.PemEncoded: boolean release()>();
return v4;
label4:
v5 := @caughtexception;
interfaceinvoke v2.<io.netty.handler.ssl.PemEncoded: boolean release()>();
throw v5;
catch java.lang.Throwable from label2 to label3 with label4;
}
static transient long toBIO(io.netty.buffer.ByteBufAllocator, java.security.cert.X509Certificate[]) throws java.lang.Exception
{
java.lang.Throwable v5;
io.netty.buffer.ByteBufAllocator v0;
io.netty.handler.ssl.PemEncoded v2, v3;
long v4;
java.security.cert.X509Certificate[] v1;
v0 := @parameter0: io.netty.buffer.ByteBufAllocator;
v1 := @parameter1: java.security.cert.X509Certificate[];
if v1 != null goto label1;
return 0L;
label1:
staticinvoke <io.netty.util.internal.ObjectUtil: java.lang.Object[] checkNonEmpty(java.lang.Object[],java.lang.String)>(v1, "certChain");
v2 = staticinvoke <io.netty.handler.ssl.PemX509Certificate: io.netty.handler.ssl.PemEncoded toPEM(io.netty.buffer.ByteBufAllocator,boolean,java.security.cert.X509Certificate[])>(v0, 1, v1);
label2:
v3 = interfaceinvoke v2.<io.netty.handler.ssl.PemEncoded: io.netty.handler.ssl.PemEncoded retain()>();
v4 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslContext: long toBIO(io.netty.buffer.ByteBufAllocator,io.netty.handler.ssl.PemEncoded)>(v0, v3);
label3:
interfaceinvoke v2.<io.netty.handler.ssl.PemEncoded: boolean release()>();
return v4;
label4:
v5 := @caughtexception;
interfaceinvoke v2.<io.netty.handler.ssl.PemEncoded: boolean release()>();
throw v5;
catch java.lang.Throwable from label2 to label3 with label4;
}
static long toBIO(io.netty.buffer.ByteBufAllocator, io.netty.handler.ssl.PemEncoded) throws java.lang.Exception
{
java.lang.Throwable v13, v14, v16, v17;
io.netty.buffer.ByteBufAllocator v0;
io.netty.handler.ssl.PemEncoded v1;
long v11, v5;
io.netty.buffer.ByteBuf v10, v2, v4, v7;
int v6, v8, v9;
boolean v12, v15, v3;
v0 := @parameter0: io.netty.buffer.ByteBufAllocator;
v1 := @parameter1: io.netty.handler.ssl.PemEncoded;
label01:
v2 = interfaceinvoke v1.<io.netty.handler.ssl.PemEncoded: io.netty.buffer.ByteBuf content()>();
v3 = virtualinvoke v2.<io.netty.buffer.ByteBuf: boolean isDirect()>();
if v3 == 0 goto label03;
v4 = virtualinvoke v2.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf retainedSlice()>();
v5 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslContext: long newBIO(io.netty.buffer.ByteBuf)>(v4);
label02:
interfaceinvoke v1.<io.netty.handler.ssl.PemEncoded: boolean release()>();
return v5;
label03:
v6 = virtualinvoke v2.<io.netty.buffer.ByteBuf: int readableBytes()>();
v7 = interfaceinvoke v0.<io.netty.buffer.ByteBufAllocator: io.netty.buffer.ByteBuf directBuffer(int)>(v6);
label04:
v8 = virtualinvoke v2.<io.netty.buffer.ByteBuf: int readerIndex()>();
v9 = virtualinvoke v2.<io.netty.buffer.ByteBuf: int readableBytes()>();
virtualinvoke v7.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf writeBytes(io.netty.buffer.ByteBuf,int,int)>(v2, v8, v9);
v10 = virtualinvoke v7.<io.netty.buffer.ByteBuf: io.netty.buffer.ByteBuf retainedSlice()>();
v11 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslContext: long newBIO(io.netty.buffer.ByteBuf)>(v10);
label05:
v12 = interfaceinvoke v1.<io.netty.handler.ssl.PemEncoded: boolean isSensitive()>();
if v12 == 0 goto label06;
staticinvoke <io.netty.handler.ssl.SslUtils: void zeroout(io.netty.buffer.ByteBuf)>(v7);
label06:
virtualinvoke v7.<io.netty.buffer.ByteBuf: boolean release()>();
goto label08;
label07:
v13 := @caughtexception;
virtualinvoke v7.<io.netty.buffer.ByteBuf: boolean release()>();
throw v13;
label08:
interfaceinvoke v1.<io.netty.handler.ssl.PemEncoded: boolean release()>();
return v11;
label09:
v14 := @caughtexception;
label10:
v15 = interfaceinvoke v1.<io.netty.handler.ssl.PemEncoded: boolean isSensitive()>();
if v15 == 0 goto label11;
staticinvoke <io.netty.handler.ssl.SslUtils: void zeroout(io.netty.buffer.ByteBuf)>(v7);
label11:
virtualinvoke v7.<io.netty.buffer.ByteBuf: boolean release()>();
goto label13;
label12:
v16 := @caughtexception;
virtualinvoke v7.<io.netty.buffer.ByteBuf: boolean release()>();
throw v16;
label13:
throw v14;
label14:
v17 := @caughtexception;
interfaceinvoke v1.<io.netty.handler.ssl.PemEncoded: boolean release()>();
throw v17;
catch java.lang.Throwable from label05 to label06 with label07;
catch java.lang.Throwable from label04 to label05 with label09;
catch java.lang.Throwable from label10 to label11 with label12;
catch java.lang.Throwable from label01 to label02 with label14;
catch java.lang.Throwable from label03 to label08 with label14;
}
private static long newBIO(io.netty.buffer.ByteBuf) throws java.lang.Exception
{
java.lang.Throwable v8;
java.lang.IllegalStateException v7;
long v1, v3, v5;
io.netty.buffer.ByteBuf v0;
int v2, v4, v6;
v0 := @parameter0: io.netty.buffer.ByteBuf;
label1:
v1 = staticinvoke <io.netty.internal.tcnative.SSL: long newMemBIO()>();
v2 = virtualinvoke v0.<io.netty.buffer.ByteBuf: int readableBytes()>();
v3 = staticinvoke <io.netty.handler.ssl.OpenSsl: long memoryAddress(io.netty.buffer.ByteBuf)>(v0);
v4 = virtualinvoke v0.<io.netty.buffer.ByteBuf: int readerIndex()>();
v5 = v3 + v4;
v6 = staticinvoke <io.netty.internal.tcnative.SSL: int bioWrite(long,long,int)>(v1, v5, v2);
if v6 == v2 goto label2;
staticinvoke <io.netty.internal.tcnative.SSL: void freeBIO(long)>(v1);
v7 = new java.lang.IllegalStateException;
specialinvoke v7.<java.lang.IllegalStateException: void <init>(java.lang.String)>("Could not write data to memory BIO");
throw v7;
label2:
virtualinvoke v0.<io.netty.buffer.ByteBuf: boolean release()>();
return v1;
label3:
v8 := @caughtexception;
virtualinvoke v0.<io.netty.buffer.ByteBuf: boolean release()>();
throw v8;
catch java.lang.Throwable from label1 to label2 with label3;
}
static io.netty.handler.ssl.OpenSslKeyMaterialProvider providerFor(javax.net.ssl.KeyManagerFactory, java.lang.String)
{
javax.net.ssl.X509KeyManager v8;
io.netty.handler.ssl.OpenSslKeyMaterialProvider v3, v5, v6;
javax.net.ssl.KeyManagerFactory v0;
java.lang.String v1;
boolean v2, v4;
javax.net.ssl.KeyManager[] v7;
v0 := @parameter0: javax.net.ssl.KeyManagerFactory;
v1 := @parameter1: java.lang.String;
v2 = v0 instanceof io.netty.handler.ssl.OpenSslX509KeyManagerFactory;
if v2 == 0 goto label1;
v3 = virtualinvoke v0.<io.netty.handler.ssl.OpenSslX509KeyManagerFactory: io.netty.handler.ssl.OpenSslKeyMaterialProvider newProvider()>();
return v3;
label1:
v4 = v0 instanceof io.netty.handler.ssl.OpenSslCachingX509KeyManagerFactory;
if v4 == 0 goto label2;
v5 = virtualinvoke v0.<io.netty.handler.ssl.OpenSslCachingX509KeyManagerFactory: io.netty.handler.ssl.OpenSslKeyMaterialProvider newProvider(java.lang.String)>(v1);
return v5;
label2:
v6 = new io.netty.handler.ssl.OpenSslKeyMaterialProvider;
v7 = virtualinvoke v0.<javax.net.ssl.KeyManagerFactory: javax.net.ssl.KeyManager[] getKeyManagers()>();
v8 = staticinvoke <io.netty.handler.ssl.ReferenceCountedOpenSslContext: javax.net.ssl.X509KeyManager chooseX509KeyManager(javax.net.ssl.KeyManager[])>(v7);
specialinvoke v6.<io.netty.handler.ssl.OpenSslKeyMaterialProvider: void <init>(javax.net.ssl.X509KeyManager,java.lang.String)>(v8, v1);
return v6;
}
private static io.netty.handler.ssl.ReferenceCountedOpenSslEngine retrieveEngine(io.netty.handler.ssl.OpenSslEngineMap, long) throws javax.net.ssl.SSLException
{
io.netty.handler.ssl.ReferenceCountedOpenSslEngine v2;
javax.net.ssl.SSLException v3;
io.netty.handler.ssl.OpenSslEngineMap v0;
long v1;
java.lang.String v4, v5;
v0 := @parameter0: io.netty.handler.ssl.OpenSslEngineMap;
v1 := @parameter1: long;
v2 = interfaceinvoke v0.<io.netty.handler.ssl.OpenSslEngineMap: io.netty.handler.ssl.ReferenceCountedOpenSslEngine get(long)>(v1);
if v2 != null goto label1;
v3 = new javax.net.ssl.SSLException;
v4 = staticinvoke <io.netty.util.internal.StringUtil: java.lang.String simpleClassName(java.lang.Class)>(class "Lio/netty/handler/ssl/ReferenceCountedOpenSslEngine;");
v5 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,long)>(v4, v1) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Could not find a \u0001 for sslPointer \u0001");
specialinvoke v3.<javax.net.ssl.SSLException: void <init>(java.lang.String)>(v5);
throw v3;
label1:
return v2;
}
private static byte[] verifyResult(byte[]) throws java.security.SignatureException
{
byte[] v0;
java.security.SignatureException v1;
v0 := @parameter0: byte[];
if v0 != null goto label1;
v1 = new java.security.SignatureException;
specialinvoke v1.<java.security.SignatureException: void <init>()>();
throw v1;
label1:
return v0;
}
static void <clinit>()
{
java.lang.Throwable v18;
java.lang.Integer v13;
io.netty.handler.ssl.ReferenceCountedOpenSslContext$2 v12;
int v1, v2;
java.lang.String v14, v17;
boolean v10, v11, v3, v6, v7, v8, v9;
java.lang.NumberFormatException v15;
io.netty.util.ResourceLeakDetector v5;
io.netty.util.internal.logging.InternalLogger v0, v16;
io.netty.util.ResourceLeakDetectorFactory v4;
v0 = staticinvoke <io.netty.util.internal.logging.InternalLoggerFactory: io.netty.util.internal.logging.InternalLogger getInstance(java.lang.Class)>(class "Lio/netty/handler/ssl/ReferenceCountedOpenSslContext;");
<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.util.internal.logging.InternalLogger logger> = v0;
v1 = staticinvoke <io.netty.util.internal.SystemPropertyUtil: int getInt(java.lang.String,int)>("io.netty.handler.ssl.openssl.bioNonApplicationBufferSize", 2048);
v2 = staticinvoke <java.lang.Math: int max(int,int)>(1, v1);
<io.netty.handler.ssl.ReferenceCountedOpenSslContext: int DEFAULT_BIO_NON_APPLICATION_BUFFER_SIZE> = v2;
v3 = staticinvoke <io.netty.util.internal.SystemPropertyUtil: boolean getBoolean(java.lang.String,boolean)>("io.netty.handler.ssl.openssl.useTasks", 1);
<io.netty.handler.ssl.ReferenceCountedOpenSslContext: boolean USE_TASKS> = v3;
v4 = staticinvoke <io.netty.util.ResourceLeakDetectorFactory: io.netty.util.ResourceLeakDetectorFactory instance()>();
v5 = virtualinvoke v4.<io.netty.util.ResourceLeakDetectorFactory: io.netty.util.ResourceLeakDetector newResourceLeakDetector(java.lang.Class)>(class "Lio/netty/handler/ssl/ReferenceCountedOpenSslContext;");
<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.util.ResourceLeakDetector leakDetector> = v5;
v6 = staticinvoke <io.netty.util.internal.SystemPropertyUtil: boolean getBoolean(java.lang.String,boolean)>("jdk.tls.client.enableSessionTicketExtension", 0);
<io.netty.handler.ssl.ReferenceCountedOpenSslContext: boolean CLIENT_ENABLE_SESSION_TICKET> = v6;
v7 = staticinvoke <io.netty.util.internal.SystemPropertyUtil: boolean getBoolean(java.lang.String,boolean)>("jdk.tls.client.enableSessionTicketExtension", 1);
<io.netty.handler.ssl.ReferenceCountedOpenSslContext: boolean CLIENT_ENABLE_SESSION_TICKET_TLSV13> = v7;
v8 = staticinvoke <io.netty.util.internal.SystemPropertyUtil: boolean getBoolean(java.lang.String,boolean)>("jdk.tls.server.enableSessionTicketExtension", 0);
<io.netty.handler.ssl.ReferenceCountedOpenSslContext: boolean SERVER_ENABLE_SESSION_TICKET> = v8;
v9 = staticinvoke <io.netty.util.internal.SystemPropertyUtil: boolean getBoolean(java.lang.String,boolean)>("jdk.tls.server.enableSessionTicketExtension", 1);
<io.netty.handler.ssl.ReferenceCountedOpenSslContext: boolean SERVER_ENABLE_SESSION_TICKET_TLSV13> = v9;
v10 = staticinvoke <io.netty.util.internal.SystemPropertyUtil: boolean getBoolean(java.lang.String,boolean)>("io.netty.handler.ssl.openssl.sessionCacheServer", 1);
<io.netty.handler.ssl.ReferenceCountedOpenSslContext: boolean SERVER_ENABLE_SESSION_CACHE> = v10;
v11 = staticinvoke <io.netty.util.internal.SystemPropertyUtil: boolean getBoolean(java.lang.String,boolean)>("io.netty.handler.ssl.openssl.sessionCacheClient", 0);
<io.netty.handler.ssl.ReferenceCountedOpenSslContext: boolean CLIENT_ENABLE_SESSION_CACHE> = v11;
v12 = new io.netty.handler.ssl.ReferenceCountedOpenSslContext$2;
specialinvoke v12.<io.netty.handler.ssl.ReferenceCountedOpenSslContext$2: void <init>()>();
<io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.handler.ssl.OpenSslApplicationProtocolNegotiator NONE_PROTOCOL_NEGOTIATOR> = v12;
v13 = null;
label1:
v14 = staticinvoke <io.netty.util.internal.SystemPropertyUtil: java.lang.String get(java.lang.String)>("jdk.tls.ephemeralDHKeySize");
if v14 == null goto label7;
label2:
v13 = staticinvoke <java.lang.Integer: java.lang.Integer valueOf(java.lang.String)>(v14);
label3:
goto label7;
label4:
v15 := @caughtexception;
v16 = <io.netty.handler.ssl.ReferenceCountedOpenSslContext: io.netty.util.internal.logging.InternalLogger logger>;
v17 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v14) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("ReferenceCountedOpenSslContext supports -Djdk.tls.ephemeralDHKeySize={int}, but got: \u0001");
interfaceinvoke v16.<io.netty.util.internal.logging.InternalLogger: void debug(java.lang.String)>(v17);
label5:
goto label7;
label6:
v18 := @caughtexception;
label7:
<io.netty.handler.ssl.ReferenceCountedOpenSslContext: java.lang.Integer DH_KEY_LENGTH> = v13;
return;
catch java.lang.NumberFormatException from label2 to label3 with label4;
catch java.lang.Throwable from label1 to label5 with label6;
}
}