public final class io.netty.util.internal.Hidden$NettyBlockHoundIntegration extends java.lang.Object implements reactor.blockhound.integration.BlockHoundIntegration
{
public void <init>()
{
io.netty.util.internal.Hidden$NettyBlockHoundIntegration v0;
v0 := @this: io.netty.util.internal.Hidden$NettyBlockHoundIntegration;
specialinvoke v0.<java.lang.Object: void <init>()>();
return;
}
public void applyTo(reactor.blockhound.BlockHound$Builder)
{
io.netty.util.internal.Hidden$NettyBlockHoundIntegration v0;
io.netty.util.internal.Hidden$NettyBlockHoundIntegration$1 v2;
reactor.blockhound.BlockHound$Builder v1;
v0 := @this: io.netty.util.internal.Hidden$NettyBlockHoundIntegration;
v1 := @parameter0: reactor.blockhound.BlockHound$Builder;
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.channel.nio.NioEventLoop", "handleLoopException");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.channel.kqueue.KQueueEventLoop", "handleLoopException");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.channel.epoll.EpollEventLoop", "handleLoopException");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.util.HashedWheelTimer", "start");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.util.HashedWheelTimer", "stop");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.util.HashedWheelTimer$Worker", "waitForNextTick");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.util.concurrent.SingleThreadEventExecutor", "confirmShutdown");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.buffer.PoolArena", "lock");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.buffer.PoolSubpage", "lock");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.buffer.PoolChunk", "allocateRun");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.buffer.PoolChunk", "free");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.handler.ssl.SslHandler", "handshake");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.handler.ssl.SslHandler", "runAllDelegatedTasks");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.handler.ssl.SslHandler", "runDelegatedTasks");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.util.concurrent.GlobalEventExecutor", "takeTask");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.util.concurrent.GlobalEventExecutor", "addTask");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.util.concurrent.SingleThreadEventExecutor", "takeTask");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.util.concurrent.SingleThreadEventExecutor", "addTask");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.handler.ssl.ReferenceCountedOpenSslClientContext$ExtendedTrustManagerVerifyCallback", "verify");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.handler.ssl.JdkSslContext$Defaults", "init");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("sun.security.ssl.SSLEngineImpl", "unwrap");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("sun.security.ssl.SSLEngineImpl", "wrap");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.resolver.dns.UnixResolverDnsServerAddressStreamProvider", "parse");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.resolver.dns.UnixResolverDnsServerAddressStreamProvider", "parseEtcResolverSearchDomains");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.resolver.dns.UnixResolverDnsServerAddressStreamProvider", "parseEtcResolverOptions");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.resolver.HostsFileEntriesProvider$ParserImpl", "parse");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.util.NetUtil$SoMaxConnAction", "run");
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder allowBlockingCallsInside(java.lang.String,java.lang.String)>("io.netty.util.internal.PlatformDependent", "createTempFile");
v2 = new io.netty.util.internal.Hidden$NettyBlockHoundIntegration$1;
specialinvoke v2.<io.netty.util.internal.Hidden$NettyBlockHoundIntegration$1: void <init>(io.netty.util.internal.Hidden$NettyBlockHoundIntegration)>(v0);
virtualinvoke v1.<reactor.blockhound.BlockHound$Builder: reactor.blockhound.BlockHound$Builder nonBlockingThreadPredicate(java.util.function.Function)>(v2);
return;
}
public int compareTo(reactor.blockhound.integration.BlockHoundIntegration)
{
io.netty.util.internal.Hidden$NettyBlockHoundIntegration v0;
reactor.blockhound.integration.BlockHoundIntegration v1;
v0 := @this: io.netty.util.internal.Hidden$NettyBlockHoundIntegration;
v1 := @parameter0: reactor.blockhound.integration.BlockHoundIntegration;
return 0;
}
}