final class io.netty.util.internal.shaded.org.jctools.queues.atomic.AtomicQueueUtil extends java.lang.Object
{
void <init>()
{
io.netty.util.internal.shaded.org.jctools.queues.atomic.AtomicQueueUtil v0;
v0 := @this: io.netty.util.internal.shaded.org.jctools.queues.atomic.AtomicQueueUtil;
specialinvoke v0.<java.lang.Object: void <init>()>();
return;
}
static java.lang.Object lvRefElement(java.util.concurrent.atomic.AtomicReferenceArray, int)
{
int v1;
java.lang.Object v2;
java.util.concurrent.atomic.AtomicReferenceArray v0;
v0 := @parameter0: java.util.concurrent.atomic.AtomicReferenceArray;
v1 := @parameter1: int;
v2 = virtualinvoke v0.<java.util.concurrent.atomic.AtomicReferenceArray: java.lang.Object get(int)>(v1);
return v2;
}
static java.lang.Object lpRefElement(java.util.concurrent.atomic.AtomicReferenceArray, int)
{
int v1;
java.lang.Object v2;
java.util.concurrent.atomic.AtomicReferenceArray v0;
v0 := @parameter0: java.util.concurrent.atomic.AtomicReferenceArray;
v1 := @parameter1: int;
v2 = virtualinvoke v0.<java.util.concurrent.atomic.AtomicReferenceArray: java.lang.Object get(int)>(v1);
return v2;
}
static void spRefElement(java.util.concurrent.atomic.AtomicReferenceArray, int, java.lang.Object)
{
int v1;
java.lang.Object v2;
java.util.concurrent.atomic.AtomicReferenceArray v0;
v0 := @parameter0: java.util.concurrent.atomic.AtomicReferenceArray;
v1 := @parameter1: int;
v2 := @parameter2: java.lang.Object;
virtualinvoke v0.<java.util.concurrent.atomic.AtomicReferenceArray: void lazySet(int,java.lang.Object)>(v1, v2);
return;
}
static void soRefElement(java.util.concurrent.atomic.AtomicReferenceArray, int, java.lang.Object)
{
int v1;
java.lang.Object v2;
java.util.concurrent.atomic.AtomicReferenceArray v0;
v0 := @parameter0: java.util.concurrent.atomic.AtomicReferenceArray;
v1 := @parameter1: int;
v2 := @parameter2: java.lang.Object;
virtualinvoke v0.<java.util.concurrent.atomic.AtomicReferenceArray: void lazySet(int,java.lang.Object)>(v1, v2);
return;
}
static void svRefElement(java.util.concurrent.atomic.AtomicReferenceArray, int, java.lang.Object)
{
int v1;
java.lang.Object v2;
java.util.concurrent.atomic.AtomicReferenceArray v0;
v0 := @parameter0: java.util.concurrent.atomic.AtomicReferenceArray;
v1 := @parameter1: int;
v2 := @parameter2: java.lang.Object;
virtualinvoke v0.<java.util.concurrent.atomic.AtomicReferenceArray: void set(int,java.lang.Object)>(v1, v2);
return;
}
static int calcRefElementOffset(long)
{
long v0;
v0 := @parameter0: long;
return v0;
}
static int calcCircularRefElementOffset(long, long)
{
long v0, v1, v2;
v0 := @parameter0: long;
v1 := @parameter1: long;
v2 = v0 & v1;
return v2;
}
static java.util.concurrent.atomic.AtomicReferenceArray allocateRefArray(int)
{
int v0;
java.util.concurrent.atomic.AtomicReferenceArray v1;
v0 := @parameter0: int;
v1 = new java.util.concurrent.atomic.AtomicReferenceArray;
specialinvoke v1.<java.util.concurrent.atomic.AtomicReferenceArray: void <init>(int)>(v0);
return v1;
}
static void spLongElement(java.util.concurrent.atomic.AtomicLongArray, int, long)
{
int v1;
long v2;
java.util.concurrent.atomic.AtomicLongArray v0;
v0 := @parameter0: java.util.concurrent.atomic.AtomicLongArray;
v1 := @parameter1: int;
v2 := @parameter2: long;
virtualinvoke v0.<java.util.concurrent.atomic.AtomicLongArray: void lazySet(int,long)>(v1, v2);
return;
}
static void soLongElement(java.util.concurrent.atomic.AtomicLongArray, int, long)
{
int v1;
long v2;
java.util.concurrent.atomic.AtomicLongArray v0;
v0 := @parameter0: java.util.concurrent.atomic.AtomicLongArray;
v1 := @parameter1: int;
v2 := @parameter2: long;
virtualinvoke v0.<java.util.concurrent.atomic.AtomicLongArray: void lazySet(int,long)>(v1, v2);
return;
}
static long lpLongElement(java.util.concurrent.atomic.AtomicLongArray, int)
{
int v1;
long v2;
java.util.concurrent.atomic.AtomicLongArray v0;
v0 := @parameter0: java.util.concurrent.atomic.AtomicLongArray;
v1 := @parameter1: int;
v2 = virtualinvoke v0.<java.util.concurrent.atomic.AtomicLongArray: long get(int)>(v1);
return v2;
}
static long lvLongElement(java.util.concurrent.atomic.AtomicLongArray, int)
{
int v1;
long v2;
java.util.concurrent.atomic.AtomicLongArray v0;
v0 := @parameter0: java.util.concurrent.atomic.AtomicLongArray;
v1 := @parameter1: int;
v2 = virtualinvoke v0.<java.util.concurrent.atomic.AtomicLongArray: long get(int)>(v1);
return v2;
}
static int calcLongElementOffset(long)
{
long v0;
v0 := @parameter0: long;
return v0;
}
static int calcCircularLongElementOffset(long, int)
{
int v1;
long v0, v2;
v0 := @parameter0: long;
v1 := @parameter1: int;
v2 = v0 & v1;
return v2;
}
static java.util.concurrent.atomic.AtomicLongArray allocateLongArray(int)
{
int v0;
java.util.concurrent.atomic.AtomicLongArray v1;
v0 := @parameter0: int;
v1 = new java.util.concurrent.atomic.AtomicLongArray;
specialinvoke v1.<java.util.concurrent.atomic.AtomicLongArray: void <init>(int)>(v0);
return v1;
}
static int length(java.util.concurrent.atomic.AtomicReferenceArray)
{
int v1;
java.util.concurrent.atomic.AtomicReferenceArray v0;
v0 := @parameter0: java.util.concurrent.atomic.AtomicReferenceArray;
v1 = virtualinvoke v0.<java.util.concurrent.atomic.AtomicReferenceArray: int length()>();
return v1;
}
static int modifiedCalcCircularRefElementOffset(long, long)
{
int v3;
long v0, v1, v2;
v0 := @parameter0: long;
v1 := @parameter1: long;
v2 = v0 & v1;
v3 = v2 >> 1;
return v3;
}
static int nextArrayOffset(java.util.concurrent.atomic.AtomicReferenceArray)
{
int v1, v2;
java.util.concurrent.atomic.AtomicReferenceArray v0;
v0 := @parameter0: java.util.concurrent.atomic.AtomicReferenceArray;
v1 = staticinvoke <io.netty.util.internal.shaded.org.jctools.queues.atomic.AtomicQueueUtil: int length(java.util.concurrent.atomic.AtomicReferenceArray)>(v0);
v2 = v1 - 1;
return v2;
}
}