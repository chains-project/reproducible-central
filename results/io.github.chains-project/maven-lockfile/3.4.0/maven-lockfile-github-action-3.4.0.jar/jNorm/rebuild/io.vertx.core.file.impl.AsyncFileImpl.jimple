public class io.vertx.core.file.impl.AsyncFileImpl extends java.lang.Object implements io.vertx.core.file.AsyncFile
{
private static final io.vertx.core.impl.logging.Logger log;
public static final int DEFAULT_READ_BUFFER_SIZE;
private final io.vertx.core.impl.VertxInternal vertx;
private final java.nio.channels.AsynchronousFileChannel ch;
private final io.vertx.core.impl.ContextInternal context;
private boolean closed;
private java.lang.Runnable closedDeferred;
private long writesOutstanding;
private boolean overflow;
private io.vertx.core.Handler exceptionHandler;
private io.vertx.core.Handler drainHandler;
private long writePos;
private int maxWrites;
private int lwm;
private int readBufferSize;
private io.vertx.core.streams.impl.InboundBuffer queue;
private io.vertx.core.Handler handler;
private io.vertx.core.Handler endHandler;
private long readPos;
private long readLength;
private static java.nio.channels.CompletionHandler LOCK_COMPLETION;
void <init>(io.vertx.core.impl.VertxInternal, java.lang.String, io.vertx.core.file.OpenOptions, io.vertx.core.impl.ContextInternal)
{
io.vertx.core.file.FileSystemException v47, v9;
java.nio.file.attribute.FileAttribute[] v37, v41;
java.nio.file.Path v11;
boolean v13, v15, v17, v19, v21, v23, v25, v27, v29, v43, v7, v8;
io.vertx.core.file.OpenOptions v3;
java.nio.file.StandardOpenOption v14, v16, v18, v20, v22, v24, v26, v28, v30;
java.util.Set v33;
java.nio.file.attribute.FileAttribute v34;
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.streams.impl.InboundBuffer v49, v50, v52;
io.vertx.core.impl.ContextInternal v4;
java.lang.String[] v10;
java.nio.channels.AsynchronousFileChannel v38, v42, v44;
long v45;
java.util.HashSet v12;
int v5, v6;
java.lang.String v2, v31, v32, v48;
java.util.concurrent.ExecutorService v36, v40;
io.vertx.core.impl.VertxInternal v1;
java.io.IOException v46;
io.vertx.core.impl.WorkerPool v35, v39;
io.vertx.core.Handler v51, v53;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: io.vertx.core.impl.VertxInternal;
v2 := @parameter1: java.lang.String;
v3 := @parameter2: io.vertx.core.file.OpenOptions;
v4 := @parameter3: io.vertx.core.impl.ContextInternal;
specialinvoke v0.<java.lang.Object: void <init>()>();
v0.<io.vertx.core.file.impl.AsyncFileImpl: int maxWrites> = 131072;
v5 = v0.<io.vertx.core.file.impl.AsyncFileImpl: int maxWrites>;
v6 = v5 / 2;
v0.<io.vertx.core.file.impl.AsyncFileImpl: int lwm> = v6;
v0.<io.vertx.core.file.impl.AsyncFileImpl: int readBufferSize> = 8192;
v0.<io.vertx.core.file.impl.AsyncFileImpl: long readLength> = 9223372036854775807L;
v7 = virtualinvoke v3.<io.vertx.core.file.OpenOptions: boolean isRead()>();
if v7 != 0 goto label01;
v8 = virtualinvoke v3.<io.vertx.core.file.OpenOptions: boolean isWrite()>();
if v8 != 0 goto label01;
v9 = new io.vertx.core.file.FileSystemException;
specialinvoke v9.<io.vertx.core.file.FileSystemException: void <init>(java.lang.String)>("Cannot open file for neither reading nor writing");
throw v9;
label01:
v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.impl.VertxInternal vertx> = v1;
v10 = newarray (java.lang.String)[0];
v11 = staticinvoke <java.nio.file.Paths: java.nio.file.Path get(java.lang.String,java.lang.String[])>(v2, v10);
v12 = new java.util.HashSet;
specialinvoke v12.<java.util.HashSet: void <init>()>();
v13 = virtualinvoke v3.<io.vertx.core.file.OpenOptions: boolean isRead()>();
if v13 == 0 goto label02;
v14 = <java.nio.file.StandardOpenOption: java.nio.file.StandardOpenOption READ>;
virtualinvoke v12.<java.util.HashSet: boolean add(java.lang.Object)>(v14);
label02:
v15 = virtualinvoke v3.<io.vertx.core.file.OpenOptions: boolean isWrite()>();
if v15 == 0 goto label03;
v16 = <java.nio.file.StandardOpenOption: java.nio.file.StandardOpenOption WRITE>;
virtualinvoke v12.<java.util.HashSet: boolean add(java.lang.Object)>(v16);
label03:
v17 = virtualinvoke v3.<io.vertx.core.file.OpenOptions: boolean isCreate()>();
if v17 == 0 goto label04;
v18 = <java.nio.file.StandardOpenOption: java.nio.file.StandardOpenOption CREATE>;
virtualinvoke v12.<java.util.HashSet: boolean add(java.lang.Object)>(v18);
label04:
v19 = virtualinvoke v3.<io.vertx.core.file.OpenOptions: boolean isCreateNew()>();
if v19 == 0 goto label05;
v20 = <java.nio.file.StandardOpenOption: java.nio.file.StandardOpenOption CREATE_NEW>;
virtualinvoke v12.<java.util.HashSet: boolean add(java.lang.Object)>(v20);
label05:
v21 = virtualinvoke v3.<io.vertx.core.file.OpenOptions: boolean isSync()>();
if v21 == 0 goto label06;
v22 = <java.nio.file.StandardOpenOption: java.nio.file.StandardOpenOption SYNC>;
virtualinvoke v12.<java.util.HashSet: boolean add(java.lang.Object)>(v22);
label06:
v23 = virtualinvoke v3.<io.vertx.core.file.OpenOptions: boolean isDsync()>();
if v23 == 0 goto label07;
v24 = <java.nio.file.StandardOpenOption: java.nio.file.StandardOpenOption DSYNC>;
virtualinvoke v12.<java.util.HashSet: boolean add(java.lang.Object)>(v24);
label07:
v25 = virtualinvoke v3.<io.vertx.core.file.OpenOptions: boolean isDeleteOnClose()>();
if v25 == 0 goto label08;
v26 = <java.nio.file.StandardOpenOption: java.nio.file.StandardOpenOption DELETE_ON_CLOSE>;
virtualinvoke v12.<java.util.HashSet: boolean add(java.lang.Object)>(v26);
label08:
v27 = virtualinvoke v3.<io.vertx.core.file.OpenOptions: boolean isSparse()>();
if v27 == 0 goto label09;
v28 = <java.nio.file.StandardOpenOption: java.nio.file.StandardOpenOption SPARSE>;
virtualinvoke v12.<java.util.HashSet: boolean add(java.lang.Object)>(v28);
label09:
v29 = virtualinvoke v3.<io.vertx.core.file.OpenOptions: boolean isTruncateExisting()>();
if v29 == 0 goto label10;
v30 = <java.nio.file.StandardOpenOption: java.nio.file.StandardOpenOption TRUNCATE_EXISTING>;
virtualinvoke v12.<java.util.HashSet: boolean add(java.lang.Object)>(v30);
label10:
v31 = virtualinvoke v3.<io.vertx.core.file.OpenOptions: java.lang.String getPerms()>();
if v31 == null goto label11;
v32 = virtualinvoke v3.<io.vertx.core.file.OpenOptions: java.lang.String getPerms()>();
v33 = staticinvoke <java.nio.file.attribute.PosixFilePermissions: java.util.Set fromString(java.lang.String)>(v32);
v34 = staticinvoke <java.nio.file.attribute.PosixFilePermissions: java.nio.file.attribute.FileAttribute asFileAttribute(java.util.Set)>(v33);
v35 = interfaceinvoke v1.<io.vertx.core.impl.VertxInternal: io.vertx.core.impl.WorkerPool getWorkerPool()>();
v36 = virtualinvoke v35.<io.vertx.core.impl.WorkerPool: java.util.concurrent.ExecutorService executor()>();
v37 = newarray (java.nio.file.attribute.FileAttribute)[1];
v37[0] = v34;
v38 = staticinvoke <java.nio.channels.AsynchronousFileChannel: java.nio.channels.AsynchronousFileChannel open(java.nio.file.Path,java.util.Set,java.util.concurrent.ExecutorService,java.nio.file.attribute.FileAttribute[])>(v11, v12, v36, v37);
v0.<io.vertx.core.file.impl.AsyncFileImpl: java.nio.channels.AsynchronousFileChannel ch> = v38;
goto label12;
label11:
v39 = interfaceinvoke v1.<io.vertx.core.impl.VertxInternal: io.vertx.core.impl.WorkerPool getWorkerPool()>();
v40 = virtualinvoke v39.<io.vertx.core.impl.WorkerPool: java.util.concurrent.ExecutorService executor()>();
v41 = newarray (java.nio.file.attribute.FileAttribute)[0];
v42 = staticinvoke <java.nio.channels.AsynchronousFileChannel: java.nio.channels.AsynchronousFileChannel open(java.nio.file.Path,java.util.Set,java.util.concurrent.ExecutorService,java.nio.file.attribute.FileAttribute[])>(v11, v12, v40, v41);
v0.<io.vertx.core.file.impl.AsyncFileImpl: java.nio.channels.AsynchronousFileChannel ch> = v42;
label12:
v43 = virtualinvoke v3.<io.vertx.core.file.OpenOptions: boolean isAppend()>();
if v43 == 0 goto label15;
v44 = v0.<io.vertx.core.file.impl.AsyncFileImpl: java.nio.channels.AsynchronousFileChannel ch>;
v45 = virtualinvoke v44.<java.nio.channels.AsynchronousFileChannel: long size()>();
v0.<io.vertx.core.file.impl.AsyncFileImpl: long writePos> = v45;
label13:
goto label15;
label14:
v46 := @caughtexception;
v47 = new io.vertx.core.file.FileSystemException;
v48 = staticinvoke <io.vertx.core.file.impl.FileSystemImpl: java.lang.String getFileAccessErrorMessage(java.lang.String,java.lang.String)>("open", v2);
specialinvoke v47.<io.vertx.core.file.FileSystemException: void <init>(java.lang.String,java.lang.Throwable)>(v48, v46);
throw v47;
label15:
v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.impl.ContextInternal context> = v4;
v49 = new io.vertx.core.streams.impl.InboundBuffer;
specialinvoke v49.<io.vertx.core.streams.impl.InboundBuffer: void <init>(io.vertx.core.Context,long)>(v4, 0L);
v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.streams.impl.InboundBuffer queue> = v49;
v50 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.streams.impl.InboundBuffer queue>;
v51 = staticinvoke <io.vertx.core.file.impl.AsyncFileImpl$lambda_new_0__1258: io.vertx.core.Handler bootstrap$(io.vertx.core.file.impl.AsyncFileImpl)>(v0);
virtualinvoke v50.<io.vertx.core.streams.impl.InboundBuffer: io.vertx.core.streams.impl.InboundBuffer handler(io.vertx.core.Handler)>(v51);
v52 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.streams.impl.InboundBuffer queue>;
v53 = staticinvoke <io.vertx.core.file.impl.AsyncFileImpl$lambda_new_1__1259: io.vertx.core.Handler bootstrap$(io.vertx.core.file.impl.AsyncFileImpl)>(v0);
virtualinvoke v52.<io.vertx.core.streams.impl.InboundBuffer: io.vertx.core.streams.impl.InboundBuffer drainHandler(io.vertx.core.Handler)>(v53);
return;
catch java.io.IOException from label10 to label13 with label14;
}
public io.vertx.core.Future close()
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.impl.future.PromiseInternal v2;
io.vertx.core.impl.ContextInternal v1;
io.vertx.core.Future v3;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.impl.ContextInternal context>;
v2 = interfaceinvoke v1.<io.vertx.core.impl.ContextInternal: io.vertx.core.impl.future.PromiseInternal promise()>();
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void closeInternal(io.vertx.core.Handler)>(v2);
v3 = interfaceinvoke v2.<io.vertx.core.Promise: io.vertx.core.Future future()>();
return v3;
}
public void close(io.vertx.core.Handler)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.Handler v1;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: io.vertx.core.Handler;
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void closeInternal(io.vertx.core.Handler)>(v1);
return;
}
public io.vertx.core.Future end()
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.impl.future.PromiseInternal v2;
io.vertx.core.impl.ContextInternal v1;
io.vertx.core.Future v3;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.impl.ContextInternal context>;
v2 = interfaceinvoke v1.<io.vertx.core.impl.ContextInternal: io.vertx.core.impl.future.PromiseInternal promise()>();
virtualinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void close(io.vertx.core.Handler)>(v2);
v3 = interfaceinvoke v2.<io.vertx.core.Promise: io.vertx.core.Future future()>();
return v3;
}
public void end(io.vertx.core.Handler)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.Handler v1;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: io.vertx.core.Handler;
virtualinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void close(io.vertx.core.Handler)>(v1);
return;
}
public synchronized io.vertx.core.file.AsyncFile read(io.vertx.core.buffer.Buffer, int, long, int, io.vertx.core.Handler)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.buffer.Buffer v1;
int v2, v4;
long v3;
io.vertx.core.Handler v5;
io.vertx.core.Future v6;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: io.vertx.core.buffer.Buffer;
v2 := @parameter1: int;
v3 := @parameter2: long;
v4 := @parameter3: int;
v5 := @parameter4: io.vertx.core.Handler;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v5, "handler");
v6 = virtualinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.Future read(io.vertx.core.buffer.Buffer,int,long,int)>(v1, v2, v3, v4);
interfaceinvoke v6.<io.vertx.core.Future: io.vertx.core.Future onComplete(io.vertx.core.Handler)>(v5);
return v0;
}
public io.vertx.core.Future read(io.vertx.core.buffer.Buffer, int, long, int)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.impl.future.PromiseInternal v6;
io.vertx.core.impl.ContextInternal v5;
long v3;
io.vertx.core.Future v12;
java.nio.ByteBuffer v11;
byte v8;
io.vertx.core.buffer.Buffer v1;
int v2, v4;
boolean v10, v7, v9;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: io.vertx.core.buffer.Buffer;
v2 := @parameter1: int;
v3 := @parameter2: long;
v4 := @parameter3: int;
v5 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.impl.ContextInternal context>;
v6 = interfaceinvoke v5.<io.vertx.core.impl.ContextInternal: io.vertx.core.impl.future.PromiseInternal promise()>();
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v1, "buffer");
if v2 < 0 goto label1;
v7 = 1;
goto label2;
label1:
v7 = 0;
label2:
staticinvoke <io.vertx.core.impl.Arguments: void require(boolean,java.lang.String)>(v7, "offset must be >= 0");
v8 = v3 cmp 0L;
if v8 < 0 goto label3;
v9 = 1;
goto label4;
label3:
v9 = 0;
label4:
staticinvoke <io.vertx.core.impl.Arguments: void require(boolean,java.lang.String)>(v9, "position must be >= 0");
if v4 < 0 goto label5;
v10 = 1;
goto label6;
label5:
v10 = 0;
label6:
staticinvoke <io.vertx.core.impl.Arguments: void require(boolean,java.lang.String)>(v10, "length must be >= 0");
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void check()>();
v11 = staticinvoke <java.nio.ByteBuffer: java.nio.ByteBuffer allocate(int)>(v4);
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void doRead(io.vertx.core.buffer.Buffer,int,java.nio.ByteBuffer,long,io.vertx.core.Promise)>(v1, v2, v11, v3, v6);
v12 = interfaceinvoke v6.<io.vertx.core.Promise: io.vertx.core.Future future()>();
return v12;
}
public io.vertx.core.file.AsyncFile fetch(long)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
long v1;
io.vertx.core.streams.impl.InboundBuffer v2;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: long;
v2 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.streams.impl.InboundBuffer queue>;
virtualinvoke v2.<io.vertx.core.streams.impl.InboundBuffer: boolean fetch(long)>(v1);
return v0;
}
public void write(io.vertx.core.buffer.Buffer, long, io.vertx.core.Handler)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.buffer.Buffer v1;
long v2;
io.vertx.core.Handler v3;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: io.vertx.core.buffer.Buffer;
v2 := @parameter1: long;
v3 := @parameter2: io.vertx.core.Handler;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v3, "handler");
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void doWrite(io.vertx.core.buffer.Buffer,long,io.vertx.core.Handler)>(v1, v2, v3);
return;
}
public io.vertx.core.Future write(io.vertx.core.buffer.Buffer, long)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.impl.future.PromiseInternal v4;
io.vertx.core.buffer.Buffer v1;
io.vertx.core.impl.ContextInternal v3;
long v2;
io.vertx.core.Future v5;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: io.vertx.core.buffer.Buffer;
v2 := @parameter1: long;
v3 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.impl.ContextInternal context>;
v4 = interfaceinvoke v3.<io.vertx.core.impl.ContextInternal: io.vertx.core.impl.future.PromiseInternal promise()>();
virtualinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void write(io.vertx.core.buffer.Buffer,long,io.vertx.core.Handler)>(v1, v2, v4);
v5 = interfaceinvoke v4.<io.vertx.core.Promise: io.vertx.core.Future future()>();
return v5;
}
private synchronized void doWrite(io.vertx.core.buffer.Buffer, long, io.vertx.core.Handler)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
java.nio.ByteBuffer[] v9;
long v2;
java.nio.ByteBuffer v10;
byte v4;
io.netty.buffer.ByteBuf v7;
io.vertx.core.buffer.Buffer v1;
int v11, v8;
io.vertx.core.Handler v3, v6;
boolean v5;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: io.vertx.core.buffer.Buffer;
v2 := @parameter1: long;
v3 := @parameter2: io.vertx.core.Handler;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v1, "buffer");
v4 = v2 cmp 0L;
if v4 < 0 goto label1;
v5 = 1;
goto label2;
label1:
v5 = 0;
label2:
staticinvoke <io.vertx.core.impl.Arguments: void require(boolean,java.lang.String)>(v5, "position must be >= 0");
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void check()>();
v6 = staticinvoke <io.vertx.core.file.impl.AsyncFileImpl$lambda_doWrite_3__1260: io.vertx.core.Handler bootstrap$(io.vertx.core.file.impl.AsyncFileImpl,io.vertx.core.Handler)>(v0, v3);
v7 = interfaceinvoke v1.<io.vertx.core.buffer.Buffer: io.netty.buffer.ByteBuf getByteBuf()>();
v8 = virtualinvoke v7.<io.netty.buffer.ByteBuf: int nioBufferCount()>();
if v8 <= 1 goto label3;
v9 = virtualinvoke v7.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer[] nioBuffers()>();
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void doWrite(java.nio.ByteBuffer[],long,io.vertx.core.Handler)>(v9, v2, v6);
goto label4;
label3:
v10 = virtualinvoke v7.<io.netty.buffer.ByteBuf: java.nio.ByteBuffer nioBuffer()>();
v11 = virtualinvoke v10.<java.nio.ByteBuffer: int limit()>();
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void doWrite(java.nio.ByteBuffer,long,long,io.vertx.core.Handler)>(v10, v2, v11, v6);
label4:
return;
}
public io.vertx.core.Future write(io.vertx.core.buffer.Buffer)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.impl.future.PromiseInternal v3;
io.vertx.core.buffer.Buffer v1;
io.vertx.core.impl.ContextInternal v2;
io.vertx.core.Future v4;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: io.vertx.core.buffer.Buffer;
v2 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.impl.ContextInternal context>;
v3 = interfaceinvoke v2.<io.vertx.core.impl.ContextInternal: io.vertx.core.impl.future.PromiseInternal promise()>();
virtualinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void write(io.vertx.core.buffer.Buffer,io.vertx.core.Handler)>(v1, v3);
v4 = interfaceinvoke v3.<io.vertx.core.Promise: io.vertx.core.Future future()>();
return v4;
}
public synchronized void write(io.vertx.core.buffer.Buffer, io.vertx.core.Handler)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.buffer.Buffer v1;
int v3;
long v4, v5, v6;
io.vertx.core.Handler v2;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: io.vertx.core.buffer.Buffer;
v2 := @parameter1: io.vertx.core.Handler;
v3 = interfaceinvoke v1.<io.vertx.core.buffer.Buffer: int length()>();
v4 = v0.<io.vertx.core.file.impl.AsyncFileImpl: long writePos>;
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void doWrite(io.vertx.core.buffer.Buffer,long,io.vertx.core.Handler)>(v1, v4, v2);
v5 = v0.<io.vertx.core.file.impl.AsyncFileImpl: long writePos>;
v6 = v5 + v3;
v0.<io.vertx.core.file.impl.AsyncFileImpl: long writePos> = v6;
return;
}
public synchronized io.vertx.core.file.AsyncFile setWriteQueueMaxSize(int)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
int v1, v3, v4;
boolean v2;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: int;
if v1 < 2 goto label1;
v2 = 1;
goto label2;
label1:
v2 = 0;
label2:
staticinvoke <io.vertx.core.impl.Arguments: void require(boolean,java.lang.String)>(v2, "maxSize must be >= 2");
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void check()>();
v0.<io.vertx.core.file.impl.AsyncFileImpl: int maxWrites> = v1;
v3 = v0.<io.vertx.core.file.impl.AsyncFileImpl: int maxWrites>;
v4 = v3 / 2;
v0.<io.vertx.core.file.impl.AsyncFileImpl: int lwm> = v4;
return v0;
}
public synchronized io.vertx.core.file.AsyncFile setReadBufferSize(int)
{
int v1;
io.vertx.core.file.impl.AsyncFileImpl v0;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: int;
v0.<io.vertx.core.file.impl.AsyncFileImpl: int readBufferSize> = v1;
return v0;
}
public synchronized boolean writeQueueFull()
{
io.vertx.core.file.impl.AsyncFileImpl v0;
boolean v1;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void check()>();
v1 = v0.<io.vertx.core.file.impl.AsyncFileImpl: boolean overflow>;
return v1;
}
public synchronized io.vertx.core.file.AsyncFile drainHandler(io.vertx.core.Handler)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.Handler v1;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: io.vertx.core.Handler;
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void check()>();
v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.Handler drainHandler> = v1;
return v0;
}
public synchronized io.vertx.core.file.AsyncFile exceptionHandler(io.vertx.core.Handler)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.Handler v1;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: io.vertx.core.Handler;
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void check()>();
v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.Handler exceptionHandler> = v1;
return v0;
}
public synchronized io.vertx.core.file.AsyncFile handler(io.vertx.core.Handler)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.streams.impl.InboundBuffer v3;
io.vertx.core.Handler v1;
boolean v2;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: io.vertx.core.Handler;
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void check()>();
v2 = v0.<io.vertx.core.file.impl.AsyncFileImpl: boolean closed>;
if v2 == 0 goto label1;
return v0;
label1:
v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.Handler handler> = v1;
if v1 == null goto label2;
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void doRead()>();
goto label3;
label2:
v3 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.streams.impl.InboundBuffer queue>;
virtualinvoke v3.<io.vertx.core.streams.impl.InboundBuffer: io.vertx.core.streams.impl.InboundBuffer clear()>();
label3:
return v0;
}
public synchronized io.vertx.core.file.AsyncFile endHandler(io.vertx.core.Handler)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.Handler v1;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: io.vertx.core.Handler;
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void check()>();
v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.Handler endHandler> = v1;
return v0;
}
public synchronized io.vertx.core.file.AsyncFile pause()
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.streams.impl.InboundBuffer v1;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void check()>();
v1 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.streams.impl.InboundBuffer queue>;
virtualinvoke v1.<io.vertx.core.streams.impl.InboundBuffer: io.vertx.core.streams.impl.InboundBuffer pause()>();
return v0;
}
public synchronized io.vertx.core.file.AsyncFile resume()
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.streams.impl.InboundBuffer v2;
boolean v1;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void check()>();
v1 = v0.<io.vertx.core.file.impl.AsyncFileImpl: boolean closed>;
if v1 != 0 goto label1;
v2 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.streams.impl.InboundBuffer queue>;
virtualinvoke v2.<io.vertx.core.streams.impl.InboundBuffer: boolean resume()>();
label1:
return v0;
}
public io.vertx.core.Future flush()
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.impl.future.PromiseInternal v2;
io.vertx.core.impl.ContextInternal v1;
io.vertx.core.Future v3;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.impl.ContextInternal context>;
v2 = interfaceinvoke v1.<io.vertx.core.impl.ContextInternal: io.vertx.core.impl.future.PromiseInternal promise()>();
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void doFlush(io.vertx.core.Handler)>(v2);
v3 = interfaceinvoke v2.<io.vertx.core.Promise: io.vertx.core.Future future()>();
return v3;
}
public io.vertx.core.file.AsyncFile flush(io.vertx.core.Handler)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.Handler v1;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: io.vertx.core.Handler;
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void doFlush(io.vertx.core.Handler)>(v1);
return v0;
}
public synchronized io.vertx.core.file.AsyncFile setReadPos(long)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
long v1;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: long;
v0.<io.vertx.core.file.impl.AsyncFileImpl: long readPos> = v1;
return v0;
}
public synchronized io.vertx.core.file.AsyncFile setReadLength(long)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
long v1;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: long;
v0.<io.vertx.core.file.impl.AsyncFileImpl: long readLength> = v1;
return v0;
}
public synchronized long getReadLength()
{
io.vertx.core.file.impl.AsyncFileImpl v0;
long v1;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 = v0.<io.vertx.core.file.impl.AsyncFileImpl: long readLength>;
return v1;
}
public synchronized io.vertx.core.file.AsyncFile setWritePos(long)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
long v1;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: long;
v0.<io.vertx.core.file.impl.AsyncFileImpl: long writePos> = v1;
return v0;
}
public synchronized long getWritePos()
{
io.vertx.core.file.impl.AsyncFileImpl v0;
long v1;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 = v0.<io.vertx.core.file.impl.AsyncFileImpl: long writePos>;
return v1;
}
private void handleException(java.lang.Throwable)
{
io.vertx.core.impl.logging.Logger v5;
java.lang.Throwable v1;
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.Handler v2, v4;
boolean v3;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: java.lang.Throwable;
v2 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.Handler exceptionHandler>;
if v2 == null goto label1;
v3 = v1 instanceof java.lang.Exception;
if v3 == 0 goto label1;
v4 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.Handler exceptionHandler>;
interfaceinvoke v4.<io.vertx.core.Handler: void handle(java.lang.Object)>(v1);
goto label2;
label1:
v5 = <io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.impl.logging.Logger log>;
interfaceinvoke v5.<io.vertx.core.impl.logging.Logger: void error(java.lang.Object,java.lang.Throwable)>("Unhandled exception", v1);
label2:
return;
}
private synchronized void doWrite(java.nio.ByteBuffer[], long, io.vertx.core.Handler)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
java.nio.ByteBuffer[] v1;
java.util.concurrent.atomic.AtomicBoolean v5;
long v2;
java.nio.ByteBuffer v8;
java.util.concurrent.atomic.AtomicInteger v4;
int v6, v7, v9;
io.vertx.core.Handler v10, v3;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: java.nio.ByteBuffer[];
v2 := @parameter1: long;
v3 := @parameter2: io.vertx.core.Handler;
v4 = new java.util.concurrent.atomic.AtomicInteger;
specialinvoke v4.<java.util.concurrent.atomic.AtomicInteger: void <init>()>();
v5 = new java.util.concurrent.atomic.AtomicBoolean;
specialinvoke v5.<java.util.concurrent.atomic.AtomicBoolean: void <init>()>();
v6 = lengthof v1;
v7 = 0;
label1:
if v7 >= v6 goto label2;
v8 = v1[v7];
v9 = virtualinvoke v8.<java.nio.ByteBuffer: int limit()>();
v10 = staticinvoke <io.vertx.core.file.impl.AsyncFileImpl$lambda_doWrite_4__1261: io.vertx.core.Handler bootstrap$(java.util.concurrent.atomic.AtomicInteger,java.nio.ByteBuffer[],io.vertx.core.Handler,java.util.concurrent.atomic.AtomicBoolean)>(v4, v1, v3, v5);
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void doWrite(java.nio.ByteBuffer,long,long,io.vertx.core.Handler)>(v8, v2, v9, v10);
v2 = v2 + v9;
v7 = v7 + 1;
goto label1;
label2:
return;
}
private void doRead()
{
int v1;
io.vertx.core.file.impl.AsyncFileImpl v0;
java.nio.ByteBuffer v2;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 = v0.<io.vertx.core.file.impl.AsyncFileImpl: int readBufferSize>;
v2 = staticinvoke <java.nio.ByteBuffer: java.nio.ByteBuffer allocate(int)>(v1);
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void doRead(java.nio.ByteBuffer)>(v2);
return;
}
private synchronized void doRead(java.nio.ByteBuffer)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.impl.future.PromiseInternal v8;
io.vertx.core.impl.ContextInternal v7;
long v11, v5, v6;
io.vertx.core.Future v9;
java.nio.ByteBuffer v1;
io.vertx.core.buffer.Buffer v3;
int v2, v4;
io.vertx.core.Handler v10;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: java.nio.ByteBuffer;
v2 = v0.<io.vertx.core.file.impl.AsyncFileImpl: int readBufferSize>;
v3 = staticinvoke <io.vertx.core.buffer.Buffer: io.vertx.core.buffer.Buffer buffer(int)>(v2);
v4 = v0.<io.vertx.core.file.impl.AsyncFileImpl: int readBufferSize>;
v5 = v0.<io.vertx.core.file.impl.AsyncFileImpl: long readLength>;
v6 = staticinvoke <java.lang.Math: long min(long,long)>(v4, v5);
virtualinvoke v1.<java.nio.ByteBuffer: java.nio.ByteBuffer limit(int)>(v6);
v7 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.impl.ContextInternal context>;
v8 = interfaceinvoke v7.<io.vertx.core.impl.ContextInternal: io.vertx.core.impl.future.PromiseInternal promise()>();
v9 = interfaceinvoke v8.<io.vertx.core.Promise: io.vertx.core.Future future()>();
v10 = staticinvoke <io.vertx.core.file.impl.AsyncFileImpl$lambda_doRead_5__1262: io.vertx.core.Handler bootstrap$(io.vertx.core.file.impl.AsyncFileImpl,java.nio.ByteBuffer)>(v0, v1);
interfaceinvoke v9.<io.vertx.core.Future: io.vertx.core.Future onComplete(io.vertx.core.Handler)>(v10);
v11 = v0.<io.vertx.core.file.impl.AsyncFileImpl: long readPos>;
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void doRead(io.vertx.core.buffer.Buffer,int,java.nio.ByteBuffer,long,io.vertx.core.Promise)>(v3, 0, v1, v11, v8);
return;
}
private void handleBuffer(io.vertx.core.buffer.Buffer)
{
java.lang.Throwable v3;
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.buffer.Buffer v1;
io.vertx.core.Handler v2;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: io.vertx.core.buffer.Buffer;
entermonitor v0;
label1:
v2 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.Handler handler>;
exitmonitor v0;
label2:
goto label4;
label3:
v3 := @caughtexception;
exitmonitor v0;
throw v3;
label4:
if v2 == null goto label5;
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void checkContext()>();
interfaceinvoke v2.<io.vertx.core.Handler: void handle(java.lang.Object)>(v1);
label5:
return;
catch java.lang.Throwable from label1 to label2 with label3;
}
private void handleEnd()
{
java.lang.Throwable v2;
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.Handler v1;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
entermonitor v0;
label1:
v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.Handler handler> = null;
v1 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.Handler endHandler>;
exitmonitor v0;
label2:
goto label4;
label3:
v2 := @caughtexception;
exitmonitor v0;
throw v2;
label4:
if v1 == null goto label5;
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void checkContext()>();
interfaceinvoke v1.<io.vertx.core.Handler: void handle(java.lang.Object)>(null);
label5:
return;
catch java.lang.Throwable from label1 to label2 with label3;
}
private synchronized void doFlush(io.vertx.core.Handler)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.impl.ContextInternal v2;
io.vertx.core.Handler v1, v3;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: io.vertx.core.Handler;
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void checkClosed()>();
v2 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.impl.ContextInternal context>;
v3 = staticinvoke <io.vertx.core.file.impl.AsyncFileImpl$lambda_doFlush_6__1263: io.vertx.core.Handler bootstrap$(io.vertx.core.file.impl.AsyncFileImpl)>(v0);
interfaceinvoke v2.<io.vertx.core.impl.ContextInternal: void executeBlockingInternal(io.vertx.core.Handler,io.vertx.core.Handler)>(v3, v1);
return;
}
private void doWrite(java.nio.ByteBuffer, long, long, io.vertx.core.Handler)
{
java.lang.Throwable v14;
io.vertx.core.file.impl.AsyncFileImpl v0;
long v2, v3, v6, v7, v9;
java.nio.ByteBuffer v1;
byte v11, v5;
int v10;
boolean v12, v13, v8;
io.vertx.core.Future v15;
io.vertx.core.Handler v4;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: java.nio.ByteBuffer;
v2 := @parameter1: long;
v3 := @parameter2: long;
v4 := @parameter3: io.vertx.core.Handler;
v5 = v3 cmp 0L;
if v5 <= 0 goto label7;
entermonitor v0;
label1:
v6 = v0.<io.vertx.core.file.impl.AsyncFileImpl: long writesOutstanding>;
v7 = v6 + v3;
v0.<io.vertx.core.file.impl.AsyncFileImpl: long writesOutstanding> = v7;
v8 = v0.<io.vertx.core.file.impl.AsyncFileImpl: boolean overflow>;
v9 = v0.<io.vertx.core.file.impl.AsyncFileImpl: long writesOutstanding>;
v10 = v0.<io.vertx.core.file.impl.AsyncFileImpl: int maxWrites>;
v11 = v9 cmp v10;
if v11 < 0 goto label2;
v12 = 1;
goto label3;
label2:
v12 = 0;
label3:
v13 = v8 | v12;
v0.<io.vertx.core.file.impl.AsyncFileImpl: boolean overflow> = v13;
exitmonitor v0;
label4:
goto label6;
label5:
v14 := @caughtexception;
exitmonitor v0;
throw v14;
label6:
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void writeInternal(java.nio.ByteBuffer,long,io.vertx.core.Handler)>(v1, v2, v4);
goto label8;
label7:
v15 = staticinvoke <io.vertx.core.Future: io.vertx.core.Future succeededFuture()>();
interfaceinvoke v4.<io.vertx.core.Handler: void handle(java.lang.Object)>(v15);
label8:
return;
catch java.lang.Throwable from label1 to label4 with label5;
}
private void writeInternal(java.nio.ByteBuffer, long, io.vertx.core.Handler)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.file.impl.AsyncFileImpl$1 v5;
java.nio.channels.AsynchronousFileChannel v4;
long v2;
io.vertx.core.Handler v3;
java.nio.ByteBuffer v1;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: java.nio.ByteBuffer;
v2 := @parameter1: long;
v3 := @parameter2: io.vertx.core.Handler;
v4 = v0.<io.vertx.core.file.impl.AsyncFileImpl: java.nio.channels.AsynchronousFileChannel ch>;
v5 = new io.vertx.core.file.impl.AsyncFileImpl$1;
specialinvoke v5.<io.vertx.core.file.impl.AsyncFileImpl$1: void <init>(io.vertx.core.file.impl.AsyncFileImpl,long,java.nio.ByteBuffer,io.vertx.core.Handler)>(v0, v2, v1, v3);
virtualinvoke v4.<java.nio.channels.AsynchronousFileChannel: void write(java.nio.ByteBuffer,long,java.lang.Object,java.nio.channels.CompletionHandler)>(v1, v2, null, v5);
return;
}
private void doRead(io.vertx.core.buffer.Buffer, int, java.nio.ByteBuffer, long, io.vertx.core.Promise)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.Promise v5;
java.nio.channels.AsynchronousFileChannel v6;
long v4;
io.vertx.core.file.impl.AsyncFileImpl$2 v7;
java.nio.ByteBuffer v3;
io.vertx.core.buffer.Buffer v1;
int v2;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: io.vertx.core.buffer.Buffer;
v2 := @parameter1: int;
v3 := @parameter2: java.nio.ByteBuffer;
v4 := @parameter3: long;
v5 := @parameter4: io.vertx.core.Promise;
v6 = v0.<io.vertx.core.file.impl.AsyncFileImpl: java.nio.channels.AsynchronousFileChannel ch>;
v7 = new io.vertx.core.file.impl.AsyncFileImpl$2;
specialinvoke v7.<io.vertx.core.file.impl.AsyncFileImpl$2: void <init>(io.vertx.core.file.impl.AsyncFileImpl,long,java.nio.ByteBuffer,io.vertx.core.buffer.Buffer,int,io.vertx.core.Promise)>(v0, v4, v3, v1, v2, v5);
virtualinvoke v6.<java.nio.channels.AsynchronousFileChannel: void read(java.nio.ByteBuffer,long,java.lang.Object,java.nio.channels.CompletionHandler)>(v3, v4, null, v7);
return;
}
private void check()
{
io.vertx.core.file.impl.AsyncFileImpl v0;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void checkClosed()>();
return;
}
private void checkClosed()
{
io.vertx.core.file.impl.AsyncFileImpl v0;
java.lang.IllegalStateException v2;
boolean v1;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 = v0.<io.vertx.core.file.impl.AsyncFileImpl: boolean closed>;
if v1 == 0 goto label1;
v2 = new java.lang.IllegalStateException;
specialinvoke v2.<java.lang.IllegalStateException: void <init>(java.lang.String)>("File handle is closed");
throw v2;
label1:
return;
}
private void checkContext()
{
io.vertx.core.file.impl.AsyncFileImpl v0;
java.lang.IllegalStateException v5;
io.vertx.core.impl.VertxInternal v1, v7;
io.vertx.core.impl.ContextInternal v2, v3, v6, v8;
java.lang.String v9;
boolean v4;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.impl.VertxInternal vertx>;
v2 = interfaceinvoke v1.<io.vertx.core.impl.VertxInternal: io.vertx.core.impl.ContextInternal getContext()>();
v3 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.impl.ContextInternal context>;
v4 = virtualinvoke v2.<java.lang.Object: boolean equals(java.lang.Object)>(v3);
if v4 != 0 goto label1;
v5 = new java.lang.IllegalStateException;
v6 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.impl.ContextInternal context>;
v7 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.impl.VertxInternal vertx>;
v8 = interfaceinvoke v7.<io.vertx.core.impl.VertxInternal: io.vertx.core.impl.ContextInternal getContext()>();
v9 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (io.vertx.core.impl.ContextInternal,io.vertx.core.impl.ContextInternal)>(v6, v8) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("AsyncFile must only be used in the context that created it, expected: \u0001 actual \u0001");
specialinvoke v5.<java.lang.IllegalStateException: void <init>(java.lang.String)>(v9);
throw v5;
label1:
return;
}
private void doClose(io.vertx.core.Handler)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.impl.ContextInternal v2;
io.vertx.core.Handler v1, v3;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: io.vertx.core.Handler;
v2 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.impl.ContextInternal context>;
v3 = staticinvoke <io.vertx.core.file.impl.AsyncFileImpl$lambda_doClose_7__1264: io.vertx.core.Handler bootstrap$(io.vertx.core.file.impl.AsyncFileImpl)>(v0);
interfaceinvoke v2.<io.vertx.core.impl.ContextInternal: void executeBlockingInternal(io.vertx.core.Handler,io.vertx.core.Handler)>(v3, v1);
return;
}
private synchronized void closeInternal(io.vertx.core.Handler)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
byte v3;
long v2;
io.vertx.core.Handler v1;
java.lang.Runnable v4;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: io.vertx.core.Handler;
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void check()>();
v0.<io.vertx.core.file.impl.AsyncFileImpl: boolean closed> = 1;
v2 = v0.<io.vertx.core.file.impl.AsyncFileImpl: long writesOutstanding>;
v3 = v2 cmp 0L;
if v3 != 0 goto label1;
specialinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: void doClose(io.vertx.core.Handler)>(v1);
goto label2;
label1:
v4 = staticinvoke <io.vertx.core.file.impl.AsyncFileImpl$lambda_closeInternal_8__1265: java.lang.Runnable bootstrap$(io.vertx.core.file.impl.AsyncFileImpl,io.vertx.core.Handler)>(v0, v1);
v0.<io.vertx.core.file.impl.AsyncFileImpl: java.lang.Runnable closedDeferred> = v4;
label2:
return;
}
public long sizeBlocking()
{
io.vertx.core.file.impl.AsyncFileImpl v0;
java.io.IOException v3;
java.nio.channels.AsynchronousFileChannel v1;
long v2;
io.vertx.core.file.FileSystemException v4;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
label1:
v1 = v0.<io.vertx.core.file.impl.AsyncFileImpl: java.nio.channels.AsynchronousFileChannel ch>;
v2 = virtualinvoke v1.<java.nio.channels.AsynchronousFileChannel: long size()>();
label2:
return v2;
label3:
v3 := @caughtexception;
v4 = new io.vertx.core.file.FileSystemException;
specialinvoke v4.<io.vertx.core.file.FileSystemException: void <init>(java.lang.Throwable)>(v3);
throw v4;
catch java.io.IOException from label1 to label2 with label3;
}
public io.vertx.core.Future size()
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.impl.VertxInternal v1;
io.vertx.core.impl.ContextInternal v2;
io.vertx.core.Handler v3;
io.vertx.core.Future v4;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.impl.VertxInternal vertx>;
v2 = interfaceinvoke v1.<io.vertx.core.impl.VertxInternal: io.vertx.core.impl.ContextInternal getOrCreateContext()>();
v3 = staticinvoke <io.vertx.core.file.impl.AsyncFileImpl$lambda_size_9__1266: io.vertx.core.Handler bootstrap$(io.vertx.core.file.impl.AsyncFileImpl)>(v0);
v4 = interfaceinvoke v2.<io.vertx.core.impl.ContextInternal: io.vertx.core.Future executeBlockingInternal(io.vertx.core.Handler)>(v3);
return v4;
}
public io.vertx.core.file.AsyncFileLock tryLock()
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.file.impl.AsyncFileLockImpl v1;
io.vertx.core.impl.VertxInternal v2;
java.io.IOException v5;
java.nio.channels.AsynchronousFileChannel v3;
io.vertx.core.file.FileSystemException v6;
java.nio.channels.FileLock v4;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
label1:
v1 = new io.vertx.core.file.impl.AsyncFileLockImpl;
v2 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.impl.VertxInternal vertx>;
v3 = v0.<io.vertx.core.file.impl.AsyncFileImpl: java.nio.channels.AsynchronousFileChannel ch>;
v4 = virtualinvoke v3.<java.nio.channels.AsynchronousFileChannel: java.nio.channels.FileLock tryLock()>();
specialinvoke v1.<io.vertx.core.file.impl.AsyncFileLockImpl: void <init>(io.vertx.core.impl.VertxInternal,java.nio.channels.FileLock)>(v2, v4);
label2:
return v1;
label3:
v5 := @caughtexception;
v6 = new io.vertx.core.file.FileSystemException;
specialinvoke v6.<io.vertx.core.file.FileSystemException: void <init>(java.lang.Throwable)>(v5);
throw v6;
catch java.io.IOException from label1 to label2 with label3;
}
public io.vertx.core.file.AsyncFileLock tryLock(long, long, boolean)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.file.impl.AsyncFileLockImpl v4;
io.vertx.core.impl.VertxInternal v5;
java.io.IOException v8;
java.nio.channels.AsynchronousFileChannel v6;
long v1, v2;
io.vertx.core.file.FileSystemException v9;
java.nio.channels.FileLock v7;
boolean v3;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: long;
v2 := @parameter1: long;
v3 := @parameter2: boolean;
label1:
v4 = new io.vertx.core.file.impl.AsyncFileLockImpl;
v5 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.impl.VertxInternal vertx>;
v6 = v0.<io.vertx.core.file.impl.AsyncFileImpl: java.nio.channels.AsynchronousFileChannel ch>;
v7 = virtualinvoke v6.<java.nio.channels.AsynchronousFileChannel: java.nio.channels.FileLock tryLock(long,long,boolean)>(v1, v2, v3);
specialinvoke v4.<io.vertx.core.file.impl.AsyncFileLockImpl: void <init>(io.vertx.core.impl.VertxInternal,java.nio.channels.FileLock)>(v5, v7);
label2:
return v4;
label3:
v8 := @caughtexception;
v9 = new io.vertx.core.file.FileSystemException;
specialinvoke v9.<io.vertx.core.file.FileSystemException: void <init>(java.lang.Throwable)>(v8);
throw v9;
catch java.io.IOException from label1 to label2 with label3;
}
public io.vertx.core.Future lock()
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.Future v1;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 = virtualinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.Future lock(long,long,boolean)>(0L, 9223372036854775807L, 0);
return v1;
}
public void lock(io.vertx.core.Handler)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.Handler v1;
io.vertx.core.Future v2;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: io.vertx.core.Handler;
v2 = virtualinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.Future lock()>();
if v1 == null goto label1;
interfaceinvoke v2.<io.vertx.core.Future: io.vertx.core.Future onComplete(io.vertx.core.Handler)>(v1);
label1:
return;
}
public io.vertx.core.Future lock(long, long, boolean)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
io.vertx.core.impl.VertxInternal v4, v6;
io.vertx.core.impl.future.PromiseInternal v5;
long v1, v2;
io.vertx.core.Future v9;
io.vertx.core.Handler v7, v8;
boolean v3;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: long;
v2 := @parameter1: long;
v3 := @parameter2: boolean;
v4 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.impl.VertxInternal vertx>;
v5 = interfaceinvoke v4.<io.vertx.core.impl.VertxInternal: io.vertx.core.impl.future.PromiseInternal promise()>();
v6 = v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.impl.VertxInternal vertx>;
v7 = staticinvoke <io.vertx.core.file.impl.AsyncFileImpl$lambda_lock_10__1267: io.vertx.core.Handler bootstrap$(io.vertx.core.file.impl.AsyncFileImpl,long,long,boolean,io.vertx.core.impl.future.PromiseInternal)>(v0, v1, v2, v3, v5);
v8 = staticinvoke <io.vertx.core.file.impl.AsyncFileImpl$lambda_lock_11__1268: io.vertx.core.Handler bootstrap$(io.vertx.core.impl.future.PromiseInternal)>(v5);
interfaceinvoke v6.<io.vertx.core.impl.VertxInternal: void executeBlockingInternal(io.vertx.core.Handler,io.vertx.core.Handler)>(v7, v8);
v9 = interfaceinvoke v5.<io.vertx.core.impl.future.PromiseInternal: io.vertx.core.Future future()>();
return v9;
}
public void lock(long, long, boolean, io.vertx.core.Handler)
{
io.vertx.core.file.impl.AsyncFileImpl v0;
long v1, v2;
io.vertx.core.Handler v4;
io.vertx.core.Future v5;
boolean v3;
v0 := @this: io.vertx.core.file.impl.AsyncFileImpl;
v1 := @parameter0: long;
v2 := @parameter1: long;
v3 := @parameter2: boolean;
v4 := @parameter3: io.vertx.core.Handler;
v5 = virtualinvoke v0.<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.Future lock(long,long,boolean)>(v1, v2, v3);
if v4 == null goto label1;
interfaceinvoke v5.<io.vertx.core.Future: io.vertx.core.Future onComplete(io.vertx.core.Handler)>(v4);
label1:
return;
}
static void <clinit>()
{
io.vertx.core.impl.logging.Logger v0;
io.vertx.core.file.impl.AsyncFileImpl$3 v1;
v0 = staticinvoke <io.vertx.core.impl.logging.LoggerFactory: io.vertx.core.impl.logging.Logger getLogger(java.lang.Class)>(class "Lio/vertx/core/file/AsyncFile;");
<io.vertx.core.file.impl.AsyncFileImpl: io.vertx.core.impl.logging.Logger log> = v0;
v1 = new io.vertx.core.file.impl.AsyncFileImpl$3;
specialinvoke v1.<io.vertx.core.file.impl.AsyncFileImpl$3: void <init>()>();
<io.vertx.core.file.impl.AsyncFileImpl: java.nio.channels.CompletionHandler LOCK_COMPLETION> = v1;
return;
}
}