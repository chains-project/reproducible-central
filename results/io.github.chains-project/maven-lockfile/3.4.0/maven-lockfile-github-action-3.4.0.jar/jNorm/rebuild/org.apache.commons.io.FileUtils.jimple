public class org.apache.commons.io.FileUtils extends java.lang.Object
{
public static final long ONE_KB;
public static final java.math.BigInteger ONE_KB_BI;
public static final long ONE_MB;
public static final java.math.BigInteger ONE_MB_BI;
public static final long ONE_GB;
public static final java.math.BigInteger ONE_GB_BI;
public static final long ONE_TB;
public static final java.math.BigInteger ONE_TB_BI;
public static final long ONE_PB;
public static final java.math.BigInteger ONE_PB_BI;
public static final long ONE_EB;
public static final java.math.BigInteger ONE_EB_BI;
public static final java.math.BigInteger ONE_ZB;
public static final java.math.BigInteger ONE_YB;
public static final java.io.File[] EMPTY_FILE_ARRAY;
private static transient java.nio.file.CopyOption[] addCopyAttributes(java.nio.file.CopyOption[])
{
java.nio.file.CopyOption[] v0;
java.lang.Object[] v3;
java.nio.file.StandardCopyOption v10, v6;
int v1, v2, v4, v5, v7, v8, v9;
v0 := @parameter0: java.nio.file.CopyOption[];
v1 = lengthof v0;
v2 = v1 + 1;
v3 = staticinvoke <java.util.Arrays: java.lang.Object[] copyOf(java.lang.Object[],int)>(v0, v2);
v4 = lengthof v0;
staticinvoke <java.util.Arrays: void sort(java.lang.Object[],int,int)>(v3, 0, v4);
v5 = lengthof v0;
v6 = <java.nio.file.StandardCopyOption: java.nio.file.StandardCopyOption COPY_ATTRIBUTES>;
v7 = staticinvoke <java.util.Arrays: int binarySearch(java.lang.Object[],int,int,java.lang.Object)>(v0, 0, v5, v6);
if v7 < 0 goto label1;
return v0;
label1:
v8 = lengthof v3;
v9 = v8 - 1;
v10 = <java.nio.file.StandardCopyOption: java.nio.file.StandardCopyOption COPY_ATTRIBUTES>;
v3[v9] = v10;
return v3;
}
public static java.lang.String byteCountToDisplaySize(java.math.BigInteger)
{
java.math.BigInteger v0, v1, v10, v12, v13, v14, v15, v16, v18, v19, v2, v20, v21, v22, v24, v25, v26, v27, v28, v3, v30, v31, v32, v33, v34, v36, v37, v5, v6, v8, v9;
int v11, v17, v23, v29, v35, v4;
java.lang.String v7;
v0 := @parameter0: java.math.BigInteger;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "size");
v1 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_EB_BI>;
v2 = virtualinvoke v0.<java.math.BigInteger: java.math.BigInteger divide(java.math.BigInteger)>(v1);
v3 = <java.math.BigInteger: java.math.BigInteger ZERO>;
v4 = virtualinvoke v2.<java.math.BigInteger: int compareTo(java.math.BigInteger)>(v3);
if v4 <= 0 goto label1;
v5 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_EB_BI>;
v6 = virtualinvoke v0.<java.math.BigInteger: java.math.BigInteger divide(java.math.BigInteger)>(v5);
v7 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.math.BigInteger)>(v6) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001 EB");
goto label7;
label1:
v8 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_PB_BI>;
v9 = virtualinvoke v0.<java.math.BigInteger: java.math.BigInteger divide(java.math.BigInteger)>(v8);
v10 = <java.math.BigInteger: java.math.BigInteger ZERO>;
v11 = virtualinvoke v9.<java.math.BigInteger: int compareTo(java.math.BigInteger)>(v10);
if v11 <= 0 goto label2;
v12 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_PB_BI>;
v13 = virtualinvoke v0.<java.math.BigInteger: java.math.BigInteger divide(java.math.BigInteger)>(v12);
v7 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.math.BigInteger)>(v13) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001 PB");
goto label7;
label2:
v14 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_TB_BI>;
v15 = virtualinvoke v0.<java.math.BigInteger: java.math.BigInteger divide(java.math.BigInteger)>(v14);
v16 = <java.math.BigInteger: java.math.BigInteger ZERO>;
v17 = virtualinvoke v15.<java.math.BigInteger: int compareTo(java.math.BigInteger)>(v16);
if v17 <= 0 goto label3;
v18 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_TB_BI>;
v19 = virtualinvoke v0.<java.math.BigInteger: java.math.BigInteger divide(java.math.BigInteger)>(v18);
v7 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.math.BigInteger)>(v19) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001 TB");
goto label7;
label3:
v20 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_GB_BI>;
v21 = virtualinvoke v0.<java.math.BigInteger: java.math.BigInteger divide(java.math.BigInteger)>(v20);
v22 = <java.math.BigInteger: java.math.BigInteger ZERO>;
v23 = virtualinvoke v21.<java.math.BigInteger: int compareTo(java.math.BigInteger)>(v22);
if v23 <= 0 goto label4;
v24 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_GB_BI>;
v25 = virtualinvoke v0.<java.math.BigInteger: java.math.BigInteger divide(java.math.BigInteger)>(v24);
v7 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.math.BigInteger)>(v25) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001 GB");
goto label7;
label4:
v26 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_MB_BI>;
v27 = virtualinvoke v0.<java.math.BigInteger: java.math.BigInteger divide(java.math.BigInteger)>(v26);
v28 = <java.math.BigInteger: java.math.BigInteger ZERO>;
v29 = virtualinvoke v27.<java.math.BigInteger: int compareTo(java.math.BigInteger)>(v28);
if v29 <= 0 goto label5;
v30 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_MB_BI>;
v31 = virtualinvoke v0.<java.math.BigInteger: java.math.BigInteger divide(java.math.BigInteger)>(v30);
v7 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.math.BigInteger)>(v31) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001 MB");
goto label7;
label5:
v32 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_KB_BI>;
v33 = virtualinvoke v0.<java.math.BigInteger: java.math.BigInteger divide(java.math.BigInteger)>(v32);
v34 = <java.math.BigInteger: java.math.BigInteger ZERO>;
v35 = virtualinvoke v33.<java.math.BigInteger: int compareTo(java.math.BigInteger)>(v34);
if v35 <= 0 goto label6;
v36 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_KB_BI>;
v37 = virtualinvoke v0.<java.math.BigInteger: java.math.BigInteger divide(java.math.BigInteger)>(v36);
v7 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.math.BigInteger)>(v37) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001 KB");
goto label7;
label6:
v7 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.math.BigInteger)>(v0) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001 bytes");
label7:
return v7;
}
public static java.lang.String byteCountToDisplaySize(long)
{
java.math.BigInteger v1;
long v0;
java.lang.String v2;
v0 := @parameter0: long;
v1 = staticinvoke <java.math.BigInteger: java.math.BigInteger valueOf(long)>(v0);
v2 = staticinvoke <org.apache.commons.io.FileUtils: java.lang.String byteCountToDisplaySize(java.math.BigInteger)>(v1);
return v2;
}
public static java.util.zip.Checksum checksum(java.io.File, java.util.zip.Checksum) throws java.io.IOException
{
java.lang.Throwable v6;
java.util.zip.Checksum v1;
java.util.zip.CheckedInputStream v2;
java.nio.file.OpenOption[] v4;
java.nio.file.Path v3;
java.io.File v0;
java.io.InputStream v5;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.util.zip.Checksum;
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireExistsChecked(java.io.File,java.lang.String)>(v0, "file");
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireFile(java.io.File,java.lang.String)>(v0, "file");
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v1, "checksum");
v2 = new java.util.zip.CheckedInputStream;
v3 = virtualinvoke v0.<java.io.File: java.nio.file.Path toPath()>();
v4 = newarray (java.nio.file.OpenOption)[0];
v5 = staticinvoke <java.nio.file.Files: java.io.InputStream newInputStream(java.nio.file.Path,java.nio.file.OpenOption[])>(v3, v4);
specialinvoke v2.<java.util.zip.CheckedInputStream: void <init>(java.io.InputStream,java.util.zip.Checksum)>(v5, v1);
label1:
staticinvoke <org.apache.commons.io.IOUtils: long consume(java.io.InputStream)>(v2);
label2:
virtualinvoke v2.<java.io.InputStream: void close()>();
goto label4;
label3:
v6 := @caughtexception;
throw v6;
label4:
return v1;
catch java.lang.Throwable from label1 to label2 with label3;
}
public static long checksumCRC32(java.io.File) throws java.io.IOException
{
java.util.zip.Checksum v2;
java.util.zip.CRC32 v1;
long v3;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 = new java.util.zip.CRC32;
specialinvoke v1.<java.util.zip.CRC32: void <init>()>();
v2 = staticinvoke <org.apache.commons.io.FileUtils: java.util.zip.Checksum checksum(java.io.File,java.util.zip.Checksum)>(v0, v1);
v3 = interfaceinvoke v2.<java.util.zip.Checksum: long getValue()>();
return v3;
}
public static void cleanDirectory(java.io.File) throws java.io.IOException
{
java.io.IOException v6;
java.io.File v0, v5;
java.util.ArrayList v2;
org.apache.commons.io.IOExceptionList v8;
int v3, v4;
java.lang.String v9;
java.io.File[] v1;
boolean v7;
v0 := @parameter0: java.io.File;
v1 = staticinvoke <org.apache.commons.io.FileUtils: java.io.File[] listFiles(java.io.File,java.io.FileFilter)>(v0, null);
v2 = new java.util.ArrayList;
specialinvoke v2.<java.util.ArrayList: void <init>()>();
v3 = lengthof v1;
v4 = 0;
label1:
if v4 >= v3 goto label6;
v5 = v1[v4];
label2:
staticinvoke <org.apache.commons.io.FileUtils: void forceDelete(java.io.File)>(v5);
label3:
goto label5;
label4:
v6 := @caughtexception;
interfaceinvoke v2.<java.util.List: boolean add(java.lang.Object)>(v6);
label5:
v4 = v4 + 1;
goto label1;
label6:
v7 = interfaceinvoke v2.<java.util.List: boolean isEmpty()>();
if v7 != 0 goto label7;
v8 = new org.apache.commons.io.IOExceptionList;
v9 = virtualinvoke v0.<java.io.File: java.lang.String toString()>();
specialinvoke v8.<org.apache.commons.io.IOExceptionList: void <init>(java.lang.String,java.util.List)>(v9, v2);
throw v8;
label7:
return;
catch java.io.IOException from label2 to label3 with label4;
}
private static void cleanDirectoryOnExit(java.io.File) throws java.io.IOException
{
java.io.IOException v6;
java.io.File v0, v5;
java.util.ArrayList v2;
org.apache.commons.io.IOExceptionList v8;
int v3, v4;
java.io.File[] v1;
boolean v7;
v0 := @parameter0: java.io.File;
v1 = staticinvoke <org.apache.commons.io.FileUtils: java.io.File[] listFiles(java.io.File,java.io.FileFilter)>(v0, null);
v2 = new java.util.ArrayList;
specialinvoke v2.<java.util.ArrayList: void <init>()>();
v3 = lengthof v1;
v4 = 0;
label1:
if v4 >= v3 goto label6;
v5 = v1[v4];
label2:
staticinvoke <org.apache.commons.io.FileUtils: void forceDeleteOnExit(java.io.File)>(v5);
label3:
goto label5;
label4:
v6 := @caughtexception;
interfaceinvoke v2.<java.util.List: boolean add(java.lang.Object)>(v6);
label5:
v4 = v4 + 1;
goto label1;
label6:
v7 = interfaceinvoke v2.<java.util.List: boolean isEmpty()>();
if v7 != 0 goto label7;
v8 = new org.apache.commons.io.IOExceptionList;
specialinvoke v8.<org.apache.commons.io.IOExceptionList: void <init>(java.util.List)>(v2);
throw v8;
label7:
return;
catch java.io.IOException from label2 to label3 with label4;
}
public static boolean contentEquals(java.io.File, java.io.File) throws java.io.IOException
{
java.lang.Throwable v17, v18;
long v4, v5;
byte v6;
java.nio.file.OpenOption[] v11, v14;
java.nio.file.Path v10, v13;
boolean v16, v2, v3, v9;
java.io.File v0, v1, v7, v8;
java.io.InputStream v12, v15;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
if v0 != null goto label01;
if v1 != null goto label01;
return 1;
label01:
if v0 == null goto label02;
if v1 != null goto label03;
label02:
return 0;
label03:
v2 = virtualinvoke v0.<java.io.File: boolean exists()>();
v3 = virtualinvoke v1.<java.io.File: boolean exists()>();
if v2 == v3 goto label04;
return 0;
label04:
if v2 != 0 goto label05;
return 1;
label05:
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireFile(java.io.File,java.lang.String)>(v0, "file1");
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireFile(java.io.File,java.lang.String)>(v1, "file2");
v4 = virtualinvoke v0.<java.io.File: long length()>();
v5 = virtualinvoke v1.<java.io.File: long length()>();
v6 = v4 cmp v5;
if v6 == 0 goto label06;
return 0;
label06:
v7 = virtualinvoke v0.<java.io.File: java.io.File getCanonicalFile()>();
v8 = virtualinvoke v1.<java.io.File: java.io.File getCanonicalFile()>();
v9 = virtualinvoke v7.<java.io.File: boolean equals(java.lang.Object)>(v8);
if v9 == 0 goto label07;
return 1;
label07:
v10 = virtualinvoke v0.<java.io.File: java.nio.file.Path toPath()>();
v11 = newarray (java.nio.file.OpenOption)[0];
v12 = staticinvoke <java.nio.file.Files: java.io.InputStream newInputStream(java.nio.file.Path,java.nio.file.OpenOption[])>(v10, v11);
label08:
v13 = virtualinvoke v1.<java.io.File: java.nio.file.Path toPath()>();
v14 = newarray (java.nio.file.OpenOption)[0];
v15 = staticinvoke <java.nio.file.Files: java.io.InputStream newInputStream(java.nio.file.Path,java.nio.file.OpenOption[])>(v13, v14);
label09:
v16 = staticinvoke <org.apache.commons.io.IOUtils: boolean contentEquals(java.io.InputStream,java.io.InputStream)>(v12, v15);
label10:
if v15 == null goto label11;
virtualinvoke v15.<java.io.InputStream: void close()>();
label11:
if v12 == null goto label12;
virtualinvoke v12.<java.io.InputStream: void close()>();
label12:
return v16;
label13:
v17 := @caughtexception;
throw v17;
label14:
v18 := @caughtexception;
throw v18;
catch java.lang.Throwable from label09 to label10 with label13;
catch java.lang.Throwable from label08 to label11 with label14;
}
public static boolean contentEqualsIgnoreEOL(java.io.File, java.io.File, java.lang.String) throws java.io.IOException
{
java.lang.Throwable v18, v19;
java.nio.charset.Charset v8;
java.nio.file.OpenOption[] v11, v15;
java.lang.String v2;
java.nio.file.Path v10, v14;
boolean v17, v3, v4, v7;
java.io.InputStreamReader v13, v9;
java.io.File v0, v1, v5, v6;
java.io.InputStream v12, v16;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
v2 := @parameter2: java.lang.String;
if v0 != null goto label01;
if v1 != null goto label01;
return 1;
label01:
if v0 == null goto label02;
if v1 != null goto label03;
label02:
return 0;
label03:
v3 = virtualinvoke v0.<java.io.File: boolean exists()>();
v4 = virtualinvoke v1.<java.io.File: boolean exists()>();
if v3 == v4 goto label04;
return 0;
label04:
if v3 != 0 goto label05;
return 1;
label05:
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireFile(java.io.File,java.lang.String)>(v0, "file1");
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireFile(java.io.File,java.lang.String)>(v1, "file2");
v5 = virtualinvoke v0.<java.io.File: java.io.File getCanonicalFile()>();
v6 = virtualinvoke v1.<java.io.File: java.io.File getCanonicalFile()>();
v7 = virtualinvoke v5.<java.io.File: boolean equals(java.lang.Object)>(v6);
if v7 == 0 goto label06;
return 1;
label06:
v8 = staticinvoke <org.apache.commons.io.Charsets: java.nio.charset.Charset toCharset(java.lang.String)>(v2);
v9 = new java.io.InputStreamReader;
v10 = virtualinvoke v0.<java.io.File: java.nio.file.Path toPath()>();
v11 = newarray (java.nio.file.OpenOption)[0];
v12 = staticinvoke <java.nio.file.Files: java.io.InputStream newInputStream(java.nio.file.Path,java.nio.file.OpenOption[])>(v10, v11);
specialinvoke v9.<java.io.InputStreamReader: void <init>(java.io.InputStream,java.nio.charset.Charset)>(v12, v8);
label07:
v13 = new java.io.InputStreamReader;
v14 = virtualinvoke v1.<java.io.File: java.nio.file.Path toPath()>();
v15 = newarray (java.nio.file.OpenOption)[0];
v16 = staticinvoke <java.nio.file.Files: java.io.InputStream newInputStream(java.nio.file.Path,java.nio.file.OpenOption[])>(v14, v15);
specialinvoke v13.<java.io.InputStreamReader: void <init>(java.io.InputStream,java.nio.charset.Charset)>(v16, v8);
label08:
v17 = staticinvoke <org.apache.commons.io.IOUtils: boolean contentEqualsIgnoreEOL(java.io.Reader,java.io.Reader)>(v9, v13);
label09:
virtualinvoke v13.<java.io.Reader: void close()>();
label10:
virtualinvoke v9.<java.io.Reader: void close()>();
return v17;
label11:
v18 := @caughtexception;
throw v18;
label12:
v19 := @caughtexception;
throw v19;
catch java.lang.Throwable from label08 to label09 with label11;
catch java.lang.Throwable from label07 to label10 with label12;
}
public static java.io.File[] convertFileCollectionToFileArray(java.util.Collection)
{
java.lang.Object[] v2;
java.io.File[] v1;
java.util.Collection v0;
v0 := @parameter0: java.util.Collection;
v1 = <org.apache.commons.io.FileUtils: java.io.File[] EMPTY_FILE_ARRAY>;
v2 = interfaceinvoke v0.<java.util.Collection: java.lang.Object[] toArray(java.lang.Object[])>(v1);
return v2;
}
public static void copyDirectory(java.io.File, java.io.File) throws java.io.IOException
{
java.io.File v0, v1;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
staticinvoke <org.apache.commons.io.FileUtils: void copyDirectory(java.io.File,java.io.File,boolean)>(v0, v1, 1);
return;
}
public static void copyDirectory(java.io.File, java.io.File, boolean) throws java.io.IOException
{
java.io.File v0, v1;
boolean v2;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
v2 := @parameter2: boolean;
staticinvoke <org.apache.commons.io.FileUtils: void copyDirectory(java.io.File,java.io.File,java.io.FileFilter,boolean)>(v0, v1, null, v2);
return;
}
public static void copyDirectory(java.io.File, java.io.File, java.io.FileFilter) throws java.io.IOException
{
java.io.FileFilter v2;
java.io.File v0, v1;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
v2 := @parameter2: java.io.FileFilter;
staticinvoke <org.apache.commons.io.FileUtils: void copyDirectory(java.io.File,java.io.File,java.io.FileFilter,boolean)>(v0, v1, v2, 1);
return;
}
public static void copyDirectory(java.io.File, java.io.File, java.io.FileFilter, boolean) throws java.io.IOException
{
java.nio.file.CopyOption[] v4;
java.io.FileFilter v2;
java.io.File v0, v1;
boolean v3;
java.nio.file.StandardCopyOption v5;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
v2 := @parameter2: java.io.FileFilter;
v3 := @parameter3: boolean;
v4 = newarray (java.nio.file.CopyOption)[1];
v5 = <java.nio.file.StandardCopyOption: java.nio.file.StandardCopyOption REPLACE_EXISTING>;
v4[0] = v5;
staticinvoke <org.apache.commons.io.FileUtils: void copyDirectory(java.io.File,java.io.File,java.io.FileFilter,boolean,java.nio.file.CopyOption[])>(v0, v1, v2, v3, v4);
return;
}
public static transient void copyDirectory(java.io.File, java.io.File, java.io.FileFilter, boolean, java.nio.file.CopyOption[]) throws java.io.IOException
{
java.nio.file.CopyOption[] v20, v4;
java.util.ArrayList v11, v19, v5;
int v10, v12, v13, v14;
java.lang.String v17, v18, v6, v7;
boolean v3, v8;
java.io.File v0, v1, v15, v16;
java.io.FileFilter v2;
java.io.File[] v9;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
v2 := @parameter2: java.io.FileFilter;
v3 := @parameter3: boolean;
v4 := @parameter4: java.nio.file.CopyOption[];
staticinvoke <org.apache.commons.io.FileUtils: void requireFileCopy(java.io.File,java.io.File)>(v0, v1);
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireDirectory(java.io.File,java.lang.String)>(v0, "srcDir");
staticinvoke <org.apache.commons.io.FileUtils: void requireCanonicalPathsNotEquals(java.io.File,java.io.File)>(v0, v1);
v5 = null;
v6 = virtualinvoke v0.<java.io.File: java.lang.String getCanonicalPath()>();
v7 = virtualinvoke v1.<java.io.File: java.lang.String getCanonicalPath()>();
v8 = virtualinvoke v7.<java.lang.String: boolean startsWith(java.lang.String)>(v6);
if v8 == 0 goto label2;
v9 = staticinvoke <org.apache.commons.io.FileUtils: java.io.File[] listFiles(java.io.File,java.io.FileFilter)>(v0, v2);
v10 = lengthof v9;
if v10 <= 0 goto label2;
v11 = new java.util.ArrayList;
v12 = lengthof v9;
specialinvoke v11.<java.util.ArrayList: void <init>(int)>(v12);
v5 = v11;
v13 = lengthof v9;
v14 = 0;
label1:
if v14 >= v13 goto label2;
v15 = v9[v14];
v16 = new java.io.File;
v17 = virtualinvoke v15.<java.io.File: java.lang.String getName()>();
specialinvoke v16.<java.io.File: void <init>(java.io.File,java.lang.String)>(v1, v17);
v18 = virtualinvoke v16.<java.io.File: java.lang.String getCanonicalPath()>();
interfaceinvoke v11.<java.util.List: boolean add(java.lang.Object)>(v18);
v14 = v14 + 1;
goto label1;
label2:
v19 = v5;
if v3 == 0 goto label3;
v20 = staticinvoke <org.apache.commons.io.FileUtils: java.nio.file.CopyOption[] addCopyAttributes(java.nio.file.CopyOption[])>(v4);
goto label4;
label3:
v20 = v4;
label4:
staticinvoke <org.apache.commons.io.FileUtils: void doCopyDirectory(java.io.File,java.io.File,java.io.FileFilter,java.util.List,boolean,java.nio.file.CopyOption[])>(v0, v1, v2, v19, v3, v20);
return;
}
public static void copyDirectoryToDirectory(java.io.File, java.io.File) throws java.io.IOException
{
java.lang.String v3;
java.io.File v0, v1, v2;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireDirectoryIfExists(java.io.File,java.lang.String)>(v0, "sourceDir");
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireDirectoryIfExists(java.io.File,java.lang.String)>(v1, "destinationDir");
v2 = new java.io.File;
v3 = virtualinvoke v0.<java.io.File: java.lang.String getName()>();
specialinvoke v2.<java.io.File: void <init>(java.io.File,java.lang.String)>(v1, v3);
staticinvoke <org.apache.commons.io.FileUtils: void copyDirectory(java.io.File,java.io.File,boolean)>(v0, v2, 1);
return;
}
public static void copyFile(java.io.File, java.io.File) throws java.io.IOException
{
java.nio.file.CopyOption[] v2;
java.io.File v0, v1;
java.nio.file.StandardCopyOption v3, v4;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
v2 = newarray (java.nio.file.CopyOption)[2];
v3 = <java.nio.file.StandardCopyOption: java.nio.file.StandardCopyOption COPY_ATTRIBUTES>;
v2[0] = v3;
v4 = <java.nio.file.StandardCopyOption: java.nio.file.StandardCopyOption REPLACE_EXISTING>;
v2[1] = v4;
staticinvoke <org.apache.commons.io.FileUtils: void copyFile(java.io.File,java.io.File,java.nio.file.CopyOption[])>(v0, v1, v2);
return;
}
public static void copyFile(java.io.File, java.io.File, boolean) throws java.io.IOException
{
java.nio.file.CopyOption[] v3;
java.io.File v0, v1;
boolean v2;
java.nio.file.StandardCopyOption v4, v5, v6;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
v2 := @parameter2: boolean;
if v2 == 0 goto label1;
v3 = newarray (java.nio.file.CopyOption)[2];
v4 = <java.nio.file.StandardCopyOption: java.nio.file.StandardCopyOption COPY_ATTRIBUTES>;
v3[0] = v4;
v5 = <java.nio.file.StandardCopyOption: java.nio.file.StandardCopyOption REPLACE_EXISTING>;
v3[1] = v5;
goto label2;
label1:
v3 = newarray (java.nio.file.CopyOption)[1];
v6 = <java.nio.file.StandardCopyOption: java.nio.file.StandardCopyOption REPLACE_EXISTING>;
v3[0] = v6;
label2:
staticinvoke <org.apache.commons.io.FileUtils: void copyFile(java.io.File,java.io.File,java.nio.file.CopyOption[])>(v0, v1, v3);
return;
}
public static transient void copyFile(java.io.File, java.io.File, boolean, java.nio.file.CopyOption[]) throws java.io.IOException
{
java.nio.file.CopyOption[] v3, v4;
java.io.File v0, v1;
boolean v2;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
v2 := @parameter2: boolean;
v3 := @parameter3: java.nio.file.CopyOption[];
if v2 == 0 goto label1;
v4 = staticinvoke <org.apache.commons.io.FileUtils: java.nio.file.CopyOption[] addCopyAttributes(java.nio.file.CopyOption[])>(v3);
goto label2;
label1:
v4 = v3;
label2:
staticinvoke <org.apache.commons.io.FileUtils: void copyFile(java.io.File,java.io.File,java.nio.file.CopyOption[])>(v0, v1, v4);
return;
}
public static transient void copyFile(java.io.File, java.io.File, java.nio.file.CopyOption[]) throws java.io.IOException
{
java.nio.file.CopyOption[] v2;
long v6, v7;
java.io.File v0, v1;
java.nio.file.Path v4, v5;
boolean v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
v2 := @parameter2: java.nio.file.CopyOption[];
staticinvoke <org.apache.commons.io.FileUtils: void requireFileCopy(java.io.File,java.io.File)>(v0, v1);
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireFile(java.io.File,java.lang.String)>(v0, "srcFile");
staticinvoke <org.apache.commons.io.FileUtils: void requireCanonicalPathsNotEquals(java.io.File,java.io.File)>(v0, v1);
staticinvoke <org.apache.commons.io.FileUtils: java.io.File createParentDirectories(java.io.File)>(v1);
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireFileIfExists(java.io.File,java.lang.String)>(v1, "destFile");
v3 = virtualinvoke v1.<java.io.File: boolean exists()>();
if v3 == 0 goto label1;
staticinvoke <org.apache.commons.io.FileUtils: void requireCanWrite(java.io.File,java.lang.String)>(v1, "destFile");
label1:
v4 = virtualinvoke v0.<java.io.File: java.nio.file.Path toPath()>();
v5 = virtualinvoke v1.<java.io.File: java.nio.file.Path toPath()>();
staticinvoke <java.nio.file.Files: java.nio.file.Path copy(java.nio.file.Path,java.nio.file.Path,java.nio.file.CopyOption[])>(v4, v5, v2);
v6 = virtualinvoke v0.<java.io.File: long length()>();
v7 = virtualinvoke v1.<java.io.File: long length()>();
staticinvoke <org.apache.commons.io.FileUtils: void requireEqualSizes(java.io.File,java.io.File,long,long)>(v0, v1, v6, v7);
return;
}
public static long copyFile(java.io.File, java.io.OutputStream) throws java.io.IOException
{
java.io.OutputStream v1;
java.lang.Throwable v6;
java.nio.file.OpenOption[] v3;
long v5;
java.nio.file.Path v2;
java.io.File v0;
java.io.InputStream v4;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.OutputStream;
v2 = virtualinvoke v0.<java.io.File: java.nio.file.Path toPath()>();
v3 = newarray (java.nio.file.OpenOption)[0];
v4 = staticinvoke <java.nio.file.Files: java.io.InputStream newInputStream(java.nio.file.Path,java.nio.file.OpenOption[])>(v2, v3);
label1:
v5 = staticinvoke <org.apache.commons.io.IOUtils: long copyLarge(java.io.InputStream,java.io.OutputStream)>(v4, v1);
label2:
if v4 == null goto label3;
virtualinvoke v4.<java.io.InputStream: void close()>();
label3:
return v5;
label4:
v6 := @caughtexception;
throw v6;
catch java.lang.Throwable from label1 to label2 with label4;
}
public static void copyFileToDirectory(java.io.File, java.io.File) throws java.io.IOException
{
java.io.File v0, v1;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
staticinvoke <org.apache.commons.io.FileUtils: void copyFileToDirectory(java.io.File,java.io.File,boolean)>(v0, v1, 1);
return;
}
public static void copyFileToDirectory(java.io.File, java.io.File, boolean) throws java.io.IOException
{
java.lang.String v4;
java.io.File v0, v1, v3;
boolean v2;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
v2 := @parameter2: boolean;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "sourceFile");
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireDirectoryIfExists(java.io.File,java.lang.String)>(v1, "destinationDir");
v3 = new java.io.File;
v4 = virtualinvoke v0.<java.io.File: java.lang.String getName()>();
specialinvoke v3.<java.io.File: void <init>(java.io.File,java.lang.String)>(v1, v4);
staticinvoke <org.apache.commons.io.FileUtils: void copyFile(java.io.File,java.io.File,boolean)>(v0, v3, v2);
return;
}
public static void copyInputStreamToFile(java.io.InputStream, java.io.File) throws java.io.IOException
{
java.lang.Throwable v2;
java.io.File v1;
java.io.InputStream v0;
v0 := @parameter0: java.io.InputStream;
v1 := @parameter1: java.io.File;
label1:
staticinvoke <org.apache.commons.io.FileUtils: void copyToFile(java.io.InputStream,java.io.File)>(v0, v1);
label2:
if v0 == null goto label4;
virtualinvoke v0.<java.io.InputStream: void close()>();
goto label4;
label3:
v2 := @caughtexception;
throw v2;
label4:
return;
catch java.lang.Throwable from label1 to label2 with label3;
}
public static void copyToDirectory(java.io.File, java.io.File) throws java.io.IOException
{
java.lang.String v5;
java.io.File v0, v1;
java.io.FileNotFoundException v4;
boolean v2, v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "sourceFile");
v2 = virtualinvoke v0.<java.io.File: boolean isFile()>();
if v2 == 0 goto label1;
staticinvoke <org.apache.commons.io.FileUtils: void copyFileToDirectory(java.io.File,java.io.File)>(v0, v1);
goto label3;
label1:
v3 = virtualinvoke v0.<java.io.File: boolean isDirectory()>();
if v3 == 0 goto label2;
staticinvoke <org.apache.commons.io.FileUtils: void copyDirectoryToDirectory(java.io.File,java.io.File)>(v0, v1);
goto label3;
label2:
v4 = new java.io.FileNotFoundException;
v5 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.io.File)>(v0) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("The source \u0001 does not exist");
specialinvoke v4.<java.io.FileNotFoundException: void <init>(java.lang.String)>(v5);
throw v4;
label3:
return;
}
public static void copyToDirectory(java.lang.Iterable, java.io.File) throws java.io.IOException
{
java.util.Iterator v2;
java.lang.Object v4;
java.io.File v1;
java.lang.Iterable v0;
boolean v3;
v0 := @parameter0: java.lang.Iterable;
v1 := @parameter1: java.io.File;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "sourceIterable");
v2 = interfaceinvoke v0.<java.lang.Iterable: java.util.Iterator iterator()>();
label1:
v3 = interfaceinvoke v2.<java.util.Iterator: boolean hasNext()>();
if v3 == 0 goto label2;
v4 = interfaceinvoke v2.<java.util.Iterator: java.lang.Object next()>();
staticinvoke <org.apache.commons.io.FileUtils: void copyFileToDirectory(java.io.File,java.io.File)>(v4, v1);
goto label1;
label2:
return;
}
public static void copyToFile(java.io.InputStream, java.io.File) throws java.io.IOException
{
java.lang.Throwable v3;
java.io.FileOutputStream v2;
java.io.File v1;
java.io.InputStream v0;
v0 := @parameter0: java.io.InputStream;
v1 := @parameter1: java.io.File;
v2 = staticinvoke <org.apache.commons.io.FileUtils: java.io.FileOutputStream openOutputStream(java.io.File)>(v1);
label1:
staticinvoke <org.apache.commons.io.IOUtils: int copy(java.io.InputStream,java.io.OutputStream)>(v0, v2);
label2:
if v2 == null goto label4;
virtualinvoke v2.<java.io.OutputStream: void close()>();
goto label4;
label3:
v3 := @caughtexception;
throw v3;
label4:
return;
catch java.lang.Throwable from label1 to label2 with label3;
}
public static void copyURLToFile(java.net.URL, java.io.File) throws java.io.IOException
{
java.lang.Throwable v3;
java.net.URL v0;
java.io.File v1;
java.io.InputStream v2;
v0 := @parameter0: java.net.URL;
v1 := @parameter1: java.io.File;
v2 = virtualinvoke v0.<java.net.URL: java.io.InputStream openStream()>();
label1:
staticinvoke <org.apache.commons.io.FileUtils: void copyInputStreamToFile(java.io.InputStream,java.io.File)>(v2, v1);
label2:
if v2 == null goto label4;
virtualinvoke v2.<java.io.InputStream: void close()>();
goto label4;
label3:
v3 := @caughtexception;
throw v3;
label4:
return;
catch java.lang.Throwable from label1 to label2 with label3;
}
public static void copyURLToFile(java.net.URL, java.io.File, int, int) throws java.io.IOException
{
java.lang.Throwable v6;
java.net.URL v0;
java.net.URLConnection v4;
int v2, v3;
java.io.File v1;
java.io.InputStream v5;
v0 := @parameter0: java.net.URL;
v1 := @parameter1: java.io.File;
v2 := @parameter2: int;
v3 := @parameter3: int;
v4 = virtualinvoke v0.<java.net.URL: java.net.URLConnection openConnection()>();
virtualinvoke v4.<java.net.URLConnection: void setConnectTimeout(int)>(v2);
virtualinvoke v4.<java.net.URLConnection: void setReadTimeout(int)>(v3);
v5 = virtualinvoke v4.<java.net.URLConnection: java.io.InputStream getInputStream()>();
label1:
staticinvoke <org.apache.commons.io.FileUtils: void copyInputStreamToFile(java.io.InputStream,java.io.File)>(v5, v1);
label2:
if v5 == null goto label4;
virtualinvoke v5.<java.io.InputStream: void close()>();
goto label4;
label3:
v6 := @caughtexception;
throw v6;
label4:
return;
catch java.lang.Throwable from label1 to label2 with label3;
}
public static java.io.File createParentDirectories(java.io.File) throws java.io.IOException
{
java.io.File v0, v1, v2;
v0 := @parameter0: java.io.File;
v1 = staticinvoke <org.apache.commons.io.FileUtils: java.io.File getParentFile(java.io.File)>(v0);
v2 = staticinvoke <org.apache.commons.io.FileUtils: java.io.File mkdirs(java.io.File)>(v1);
return v2;
}
static java.lang.String decodeUrl(java.lang.String)
{
java.lang.Throwable v22;
java.nio.ByteBuffer v5;
java.nio.charset.Charset v14, v19, v24;
int v11, v13, v18, v2, v23, v27, v3, v6, v8, v9;
java.lang.String v0, v1, v10, v16, v21, v26;
java.nio.CharBuffer v15, v20, v25;
char v12, v28, v7;
java.lang.RuntimeException v17;
java.lang.StringBuilder v4;
v0 := @parameter0: java.lang.String;
v1 = v0;
if v0 == null goto label10;
v2 = virtualinvoke v0.<java.lang.String: int indexOf(int)>(37);
if v2 < 0 goto label10;
v3 = virtualinvoke v0.<java.lang.String: int length()>();
v4 = new java.lang.StringBuilder;
specialinvoke v4.<java.lang.StringBuilder: void <init>()>();
v5 = staticinvoke <java.nio.ByteBuffer: java.nio.ByteBuffer allocate(int)>(v3);
v6 = 0;
label01:
if v6 >= v3 goto label09;
v7 = virtualinvoke v0.<java.lang.String: char charAt(int)>(v6);
if v7 != 37 goto label08;
label02:
v8 = v6 + 1;
v9 = v6 + 3;
v10 = virtualinvoke v0.<java.lang.String: java.lang.String substring(int,int)>(v8, v9);
v11 = staticinvoke <java.lang.Integer: int parseInt(java.lang.String,int)>(v10, 16);
virtualinvoke v5.<java.nio.ByteBuffer: java.nio.ByteBuffer put(byte)>(v11);
v6 = v6 + 3;
if v6 >= v3 goto label03;
v12 = virtualinvoke v0.<java.lang.String: char charAt(int)>(v6);
if v12 == 37 goto label02;
label03:
v13 = virtualinvoke v5.<java.nio.ByteBuffer: int position()>();
if v13 <= 0 goto label01;
virtualinvoke v5.<java.nio.ByteBuffer: java.nio.ByteBuffer flip()>();
v14 = <java.nio.charset.StandardCharsets: java.nio.charset.Charset UTF_8>;
v15 = virtualinvoke v14.<java.nio.charset.Charset: java.nio.CharBuffer decode(java.nio.ByteBuffer)>(v5);
v16 = virtualinvoke v15.<java.nio.CharBuffer: java.lang.String toString()>();
virtualinvoke v4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(v16);
virtualinvoke v5.<java.nio.ByteBuffer: java.nio.ByteBuffer clear()>();
goto label01;
label04:
v17 := @caughtexception;
label05:
v18 = virtualinvoke v5.<java.nio.ByteBuffer: int position()>();
if v18 <= 0 goto label08;
virtualinvoke v5.<java.nio.ByteBuffer: java.nio.ByteBuffer flip()>();
v19 = <java.nio.charset.StandardCharsets: java.nio.charset.Charset UTF_8>;
v20 = virtualinvoke v19.<java.nio.charset.Charset: java.nio.CharBuffer decode(java.nio.ByteBuffer)>(v5);
v21 = virtualinvoke v20.<java.nio.CharBuffer: java.lang.String toString()>();
virtualinvoke v4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(v21);
virtualinvoke v5.<java.nio.ByteBuffer: java.nio.ByteBuffer clear()>();
goto label08;
label06:
v22 := @caughtexception;
v23 = virtualinvoke v5.<java.nio.ByteBuffer: int position()>();
if v23 <= 0 goto label07;
virtualinvoke v5.<java.nio.ByteBuffer: java.nio.ByteBuffer flip()>();
v24 = <java.nio.charset.StandardCharsets: java.nio.charset.Charset UTF_8>;
v25 = virtualinvoke v24.<java.nio.charset.Charset: java.nio.CharBuffer decode(java.nio.ByteBuffer)>(v5);
v26 = virtualinvoke v25.<java.nio.CharBuffer: java.lang.String toString()>();
virtualinvoke v4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(v26);
virtualinvoke v5.<java.nio.ByteBuffer: java.nio.ByteBuffer clear()>();
label07:
throw v22;
label08:
v27 = v6;
v6 = v6 + 1;
v28 = virtualinvoke v0.<java.lang.String: char charAt(int)>(v27);
virtualinvoke v4.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(v28);
goto label01;
label09:
v1 = virtualinvoke v4.<java.lang.StringBuilder: java.lang.String toString()>();
label10:
return v1;
catch java.lang.RuntimeException from label02 to label03 with label04;
catch java.lang.Throwable from label02 to label03 with label06;
catch java.lang.Throwable from label04 to label05 with label06;
}
public static java.io.File delete(java.io.File) throws java.io.IOException
{
java.nio.file.Path v1;
java.io.File v0;
v0 := @parameter0: java.io.File;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "file");
v1 = virtualinvoke v0.<java.io.File: java.nio.file.Path toPath()>();
staticinvoke <java.nio.file.Files: void delete(java.nio.file.Path)>(v1);
return v0;
}
public static void deleteDirectory(java.io.File) throws java.io.IOException
{
java.io.File v0;
boolean v1, v2;
v0 := @parameter0: java.io.File;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "directory");
v1 = virtualinvoke v0.<java.io.File: boolean exists()>();
if v1 != 0 goto label1;
return;
label1:
v2 = staticinvoke <org.apache.commons.io.FileUtils: boolean isSymlink(java.io.File)>(v0);
if v2 != 0 goto label2;
staticinvoke <org.apache.commons.io.FileUtils: void cleanDirectory(java.io.File)>(v0);
label2:
staticinvoke <org.apache.commons.io.FileUtils: java.io.File delete(java.io.File)>(v0);
return;
}
private static void deleteDirectoryOnExit(java.io.File) throws java.io.IOException
{
java.io.File v0;
boolean v1, v2;
v0 := @parameter0: java.io.File;
v1 = virtualinvoke v0.<java.io.File: boolean exists()>();
if v1 != 0 goto label1;
return;
label1:
virtualinvoke v0.<java.io.File: void deleteOnExit()>();
v2 = staticinvoke <org.apache.commons.io.FileUtils: boolean isSymlink(java.io.File)>(v0);
if v2 != 0 goto label2;
staticinvoke <org.apache.commons.io.FileUtils: void cleanDirectoryOnExit(java.io.File)>(v0);
label2:
return;
}
public static boolean deleteQuietly(java.io.File)
{
java.io.File v0;
java.lang.Exception v2, v4;
boolean v1, v3;
v0 := @parameter0: java.io.File;
if v0 != null goto label1;
return 0;
label1:
v1 = virtualinvoke v0.<java.io.File: boolean isDirectory()>();
if v1 == 0 goto label4;
staticinvoke <org.apache.commons.io.FileUtils: void cleanDirectory(java.io.File)>(v0);
label2:
goto label4;
label3:
v2 := @caughtexception;
label4:
v3 = virtualinvoke v0.<java.io.File: boolean delete()>();
label5:
return v3;
label6:
v4 := @caughtexception;
return 0;
catch java.lang.Exception from label1 to label2 with label3;
catch java.lang.Exception from label4 to label5 with label6;
}
public static boolean directoryContains(java.io.File, java.io.File) throws java.io.IOException
{
java.lang.String v4, v5;
java.io.File v0, v1;
boolean v2, v3, v6;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireDirectoryExists(java.io.File,java.lang.String)>(v0, "directory");
if v1 != null goto label1;
return 0;
label1:
v2 = virtualinvoke v0.<java.io.File: boolean exists()>();
if v2 == 0 goto label2;
v3 = virtualinvoke v1.<java.io.File: boolean exists()>();
if v3 != 0 goto label3;
label2:
return 0;
label3:
v4 = virtualinvoke v0.<java.io.File: java.lang.String getCanonicalPath()>();
v5 = virtualinvoke v1.<java.io.File: java.lang.String getCanonicalPath()>();
v6 = staticinvoke <org.apache.commons.io.FilenameUtils: boolean directoryContains(java.lang.String,java.lang.String)>(v4, v5);
return v6;
}
private static transient void doCopyDirectory(java.io.File, java.io.File, java.io.FileFilter, java.util.List, boolean, java.nio.file.CopyOption[]) throws java.io.IOException
{
java.nio.file.CopyOption[] v5;
java.io.File v0, v1, v10, v9;
java.util.List v3;
java.io.FileFilter v2;
int v7, v8;
java.lang.String v11, v12;
java.io.File[] v6;
boolean v13, v14, v4;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
v2 := @parameter2: java.io.FileFilter;
v3 := @parameter3: java.util.List;
v4 := @parameter4: boolean;
v5 := @parameter5: java.nio.file.CopyOption[];
v6 = staticinvoke <org.apache.commons.io.FileUtils: java.io.File[] listFiles(java.io.File,java.io.FileFilter)>(v0, v2);
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireDirectoryIfExists(java.io.File,java.lang.String)>(v1, "destDir");
staticinvoke <org.apache.commons.io.FileUtils: java.io.File mkdirs(java.io.File)>(v1);
staticinvoke <org.apache.commons.io.FileUtils: void requireCanWrite(java.io.File,java.lang.String)>(v1, "destDir");
v7 = lengthof v6;
v8 = 0;
label1:
if v8 >= v7 goto label5;
v9 = v6[v8];
v10 = new java.io.File;
v11 = virtualinvoke v9.<java.io.File: java.lang.String getName()>();
specialinvoke v10.<java.io.File: void <init>(java.io.File,java.lang.String)>(v1, v11);
if v3 == null goto label2;
v12 = virtualinvoke v9.<java.io.File: java.lang.String getCanonicalPath()>();
v13 = interfaceinvoke v3.<java.util.List: boolean contains(java.lang.Object)>(v12);
if v13 != 0 goto label4;
label2:
v14 = virtualinvoke v9.<java.io.File: boolean isDirectory()>();
if v14 == 0 goto label3;
staticinvoke <org.apache.commons.io.FileUtils: void doCopyDirectory(java.io.File,java.io.File,java.io.FileFilter,java.util.List,boolean,java.nio.file.CopyOption[])>(v9, v10, v2, v3, v4, v5);
goto label4;
label3:
staticinvoke <org.apache.commons.io.FileUtils: void copyFile(java.io.File,java.io.File,java.nio.file.CopyOption[])>(v9, v10, v5);
label4:
v8 = v8 + 1;
goto label1;
label5:
if v4 == 0 goto label6;
staticinvoke <org.apache.commons.io.FileUtils: void setLastModified(java.io.File,java.io.File)>(v0, v1);
label6:
return;
}
public static void forceDelete(java.io.File) throws java.io.IOException
{
long v10, v13;
org.apache.commons.io.file.DeleteOption[] v3;
byte v11, v14;
java.lang.String v16, v8;
java.nio.file.Path v1;
java.nio.file.LinkOption[] v2;
java.io.IOException v6, v7;
java.io.File v0;
java.io.FileNotFoundException v15;
org.apache.commons.io.file.Counters$Counter v12, v9;
org.apache.commons.io.file.Counters$PathCounters v5;
org.apache.commons.io.file.StandardDeleteOption v4;
v0 := @parameter0: java.io.File;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "file");
label1:
v1 = virtualinvoke v0.<java.io.File: java.nio.file.Path toPath()>();
v2 = <org.apache.commons.io.file.PathUtils: java.nio.file.LinkOption[] EMPTY_LINK_OPTION_ARRAY>;
v3 = newarray (org.apache.commons.io.file.DeleteOption)[1];
v4 = <org.apache.commons.io.file.StandardDeleteOption: org.apache.commons.io.file.StandardDeleteOption OVERRIDE_READ_ONLY>;
v3[0] = v4;
v5 = staticinvoke <org.apache.commons.io.file.PathUtils: org.apache.commons.io.file.Counters$PathCounters delete(java.nio.file.Path,java.nio.file.LinkOption[],org.apache.commons.io.file.DeleteOption[])>(v1, v2, v3);
label2:
goto label4;
label3:
v6 := @caughtexception;
v7 = new java.io.IOException;
v8 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.io.File)>(v0) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Cannot delete file: \u0001");
specialinvoke v7.<java.io.IOException: void <init>(java.lang.String,java.lang.Throwable)>(v8, v6);
throw v7;
label4:
v9 = interfaceinvoke v5.<org.apache.commons.io.file.Counters$PathCounters: org.apache.commons.io.file.Counters$Counter getFileCounter()>();
v10 = interfaceinvoke v9.<org.apache.commons.io.file.Counters$Counter: long get()>();
v11 = v10 cmp 1L;
if v11 >= 0 goto label5;
v12 = interfaceinvoke v5.<org.apache.commons.io.file.Counters$PathCounters: org.apache.commons.io.file.Counters$Counter getDirectoryCounter()>();
v13 = interfaceinvoke v12.<org.apache.commons.io.file.Counters$Counter: long get()>();
v14 = v13 cmp 1L;
if v14 >= 0 goto label5;
v15 = new java.io.FileNotFoundException;
v16 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.io.File)>(v0) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("File does not exist: \u0001");
specialinvoke v15.<java.io.FileNotFoundException: void <init>(java.lang.String)>(v16);
throw v15;
label5:
return;
catch java.io.IOException from label1 to label2 with label3;
}
public static void forceDeleteOnExit(java.io.File) throws java.io.IOException
{
java.io.File v0;
boolean v1;
v0 := @parameter0: java.io.File;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "file");
v1 = virtualinvoke v0.<java.io.File: boolean isDirectory()>();
if v1 == 0 goto label1;
staticinvoke <org.apache.commons.io.FileUtils: void deleteDirectoryOnExit(java.io.File)>(v0);
goto label2;
label1:
virtualinvoke v0.<java.io.File: void deleteOnExit()>();
label2:
return;
}
public static void forceMkdir(java.io.File) throws java.io.IOException
{
java.io.File v0;
v0 := @parameter0: java.io.File;
staticinvoke <org.apache.commons.io.FileUtils: java.io.File mkdirs(java.io.File)>(v0);
return;
}
public static void forceMkdirParent(java.io.File) throws java.io.IOException
{
java.io.File v0, v1;
v0 := @parameter0: java.io.File;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "file");
v1 = staticinvoke <org.apache.commons.io.FileUtils: java.io.File getParentFile(java.io.File)>(v0);
if v1 != null goto label1;
return;
label1:
staticinvoke <org.apache.commons.io.FileUtils: void forceMkdir(java.io.File)>(v1);
return;
}
public static transient java.io.File getFile(java.io.File, java.lang.String[])
{
int v3, v4;
java.lang.String[] v1;
java.lang.String v5;
java.io.File v0, v2, v6;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String[];
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "directory");
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v1, "names");
v2 = v0;
v3 = lengthof v1;
v4 = 0;
label1:
if v4 >= v3 goto label2;
v5 = v1[v4];
v6 = new java.io.File;
specialinvoke v6.<java.io.File: void <init>(java.io.File,java.lang.String)>(v2, v5);
v2 = v6;
v4 = v4 + 1;
goto label1;
label2:
return v2;
}
public static transient java.io.File getFile(java.lang.String[])
{
int v2, v3;
java.lang.String[] v0;
java.lang.String v4;
java.io.File v1, v5, v6;
v0 := @parameter0: java.lang.String[];
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "names");
v1 = null;
v2 = lengthof v0;
v3 = 0;
label1:
if v3 >= v2 goto label4;
v4 = v0[v3];
if v1 != null goto label2;
v5 = new java.io.File;
specialinvoke v5.<java.io.File: void <init>(java.lang.String)>(v4);
v1 = v5;
goto label3;
label2:
v6 = new java.io.File;
specialinvoke v6.<java.io.File: void <init>(java.io.File,java.lang.String)>(v1, v4);
v1 = v6;
label3:
v3 = v3 + 1;
goto label1;
label4:
return v1;
}
private static java.io.File getParentFile(java.io.File)
{
java.io.File v0, v1;
v0 := @parameter0: java.io.File;
if v0 != null goto label1;
v1 = null;
goto label2;
label1:
v1 = virtualinvoke v0.<java.io.File: java.io.File getParentFile()>();
label2:
return v1;
}
public static java.io.File getTempDirectory()
{
java.lang.String v1;
java.io.File v0;
v0 = new java.io.File;
v1 = staticinvoke <org.apache.commons.io.FileUtils: java.lang.String getTempDirectoryPath()>();
specialinvoke v0.<java.io.File: void <init>(java.lang.String)>(v1);
return v0;
}
public static java.lang.String getTempDirectoryPath()
{
java.lang.String v0;
v0 = staticinvoke <java.lang.System: java.lang.String getProperty(java.lang.String)>("java.io.tmpdir");
return v0;
}
public static java.io.File getUserDirectory()
{
java.lang.String v1;
java.io.File v0;
v0 = new java.io.File;
v1 = staticinvoke <org.apache.commons.io.FileUtils: java.lang.String getUserDirectoryPath()>();
specialinvoke v0.<java.io.File: void <init>(java.lang.String)>(v1);
return v0;
}
public static java.lang.String getUserDirectoryPath()
{
java.lang.String v0;
v0 = staticinvoke <java.lang.System: java.lang.String getProperty(java.lang.String)>("user.home");
return v0;
}
public static transient boolean isDirectory(java.io.File, java.nio.file.LinkOption[])
{
java.nio.file.LinkOption[] v1;
java.nio.file.Path v2;
java.io.File v0;
boolean v3, v4;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.nio.file.LinkOption[];
if v0 == null goto label1;
v2 = virtualinvoke v0.<java.io.File: java.nio.file.Path toPath()>();
v3 = staticinvoke <java.nio.file.Files: boolean isDirectory(java.nio.file.Path,java.nio.file.LinkOption[])>(v2, v1);
if v3 == 0 goto label1;
v4 = 1;
goto label2;
label1:
v4 = 0;
label2:
return v4;
}
public static boolean isEmptyDirectory(java.io.File) throws java.io.IOException
{
java.nio.file.Path v1;
java.io.File v0;
boolean v2;
v0 := @parameter0: java.io.File;
v1 = virtualinvoke v0.<java.io.File: java.nio.file.Path toPath()>();
v2 = staticinvoke <org.apache.commons.io.file.PathUtils: boolean isEmptyDirectory(java.nio.file.Path)>(v1);
return v2;
}
public static boolean isFileNewer(java.io.File, java.time.chrono.ChronoLocalDate)
{
java.time.chrono.ChronoLocalDate v1;
java.time.LocalTime v2;
java.io.File v0;
boolean v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.time.chrono.ChronoLocalDate;
v2 = staticinvoke <java.time.LocalTime: java.time.LocalTime now()>();
v3 = staticinvoke <org.apache.commons.io.FileUtils: boolean isFileNewer(java.io.File,java.time.chrono.ChronoLocalDate,java.time.LocalTime)>(v0, v1, v2);
return v3;
}
public static boolean isFileNewer(java.io.File, java.time.chrono.ChronoLocalDate, java.time.LocalTime)
{
java.time.chrono.ChronoLocalDate v1;
java.time.chrono.ChronoLocalDateTime v3;
java.time.LocalTime v2;
java.io.File v0;
boolean v4;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.time.chrono.ChronoLocalDate;
v2 := @parameter2: java.time.LocalTime;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v1, "chronoLocalDate");
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v2, "localTime");
v3 = interfaceinvoke v1.<java.time.chrono.ChronoLocalDate: java.time.chrono.ChronoLocalDateTime atTime(java.time.LocalTime)>(v2);
v4 = staticinvoke <org.apache.commons.io.FileUtils: boolean isFileNewer(java.io.File,java.time.chrono.ChronoLocalDateTime)>(v0, v3);
return v4;
}
public static boolean isFileNewer(java.io.File, java.time.chrono.ChronoLocalDateTime)
{
java.time.chrono.ChronoLocalDateTime v1;
java.io.File v0;
java.time.ZoneId v2;
boolean v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.time.chrono.ChronoLocalDateTime;
v2 = staticinvoke <java.time.ZoneId: java.time.ZoneId systemDefault()>();
v3 = staticinvoke <org.apache.commons.io.FileUtils: boolean isFileNewer(java.io.File,java.time.chrono.ChronoLocalDateTime,java.time.ZoneId)>(v0, v1, v2);
return v3;
}
public static boolean isFileNewer(java.io.File, java.time.chrono.ChronoLocalDateTime, java.time.ZoneId)
{
java.time.chrono.ChronoZonedDateTime v3;
java.time.chrono.ChronoLocalDateTime v1;
java.io.File v0;
java.time.ZoneId v2;
boolean v4;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.time.chrono.ChronoLocalDateTime;
v2 := @parameter2: java.time.ZoneId;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v1, "chronoLocalDateTime");
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v2, "zoneId");
v3 = interfaceinvoke v1.<java.time.chrono.ChronoLocalDateTime: java.time.chrono.ChronoZonedDateTime atZone(java.time.ZoneId)>(v2);
v4 = staticinvoke <org.apache.commons.io.FileUtils: boolean isFileNewer(java.io.File,java.time.chrono.ChronoZonedDateTime)>(v0, v3);
return v4;
}
public static boolean isFileNewer(java.io.File, java.time.chrono.ChronoZonedDateTime)
{
java.time.chrono.ChronoZonedDateTime v1;
java.time.Instant v2;
java.io.File v0;
boolean v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.time.chrono.ChronoZonedDateTime;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v1, "chronoZonedDateTime");
v2 = interfaceinvoke v1.<java.time.chrono.ChronoZonedDateTime: java.time.Instant toInstant()>();
v3 = staticinvoke <org.apache.commons.io.FileUtils: boolean isFileNewer(java.io.File,java.time.Instant)>(v0, v2);
return v3;
}
public static boolean isFileNewer(java.io.File, java.util.Date)
{
java.util.Date v1;
long v2;
java.io.File v0;
boolean v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.util.Date;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v1, "date");
v2 = virtualinvoke v1.<java.util.Date: long getTime()>();
v3 = staticinvoke <org.apache.commons.io.FileUtils: boolean isFileNewer(java.io.File,long)>(v0, v2);
return v3;
}
public static boolean isFileNewer(java.io.File, java.io.File)
{
long v2;
java.io.File v0, v1;
boolean v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireExists(java.io.File,java.lang.String)>(v1, "reference");
v2 = staticinvoke <org.apache.commons.io.FileUtils: long lastModifiedUnchecked(java.io.File)>(v1);
v3 = staticinvoke <org.apache.commons.io.FileUtils: boolean isFileNewer(java.io.File,long)>(v0, v2);
return v3;
}
public static boolean isFileNewer(java.io.File, java.time.Instant)
{
long v2;
java.time.Instant v1;
java.io.File v0;
boolean v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.time.Instant;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v1, "instant");
v2 = virtualinvoke v1.<java.time.Instant: long toEpochMilli()>();
v3 = staticinvoke <org.apache.commons.io.FileUtils: boolean isFileNewer(java.io.File,long)>(v0, v2);
return v3;
}
public static boolean isFileNewer(java.io.File, long)
{
byte v4;
long v1, v3;
java.io.File v0;
boolean v2, v5;
v0 := @parameter0: java.io.File;
v1 := @parameter1: long;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "file");
v2 = virtualinvoke v0.<java.io.File: boolean exists()>();
if v2 == 0 goto label1;
v3 = staticinvoke <org.apache.commons.io.FileUtils: long lastModifiedUnchecked(java.io.File)>(v0);
v4 = v3 cmp v1;
if v4 <= 0 goto label1;
v5 = 1;
goto label2;
label1:
v5 = 0;
label2:
return v5;
}
public static boolean isFileOlder(java.io.File, java.time.chrono.ChronoLocalDate)
{
java.time.chrono.ChronoLocalDate v1;
java.time.LocalTime v2;
java.io.File v0;
boolean v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.time.chrono.ChronoLocalDate;
v2 = staticinvoke <java.time.LocalTime: java.time.LocalTime now()>();
v3 = staticinvoke <org.apache.commons.io.FileUtils: boolean isFileOlder(java.io.File,java.time.chrono.ChronoLocalDate,java.time.LocalTime)>(v0, v1, v2);
return v3;
}
public static boolean isFileOlder(java.io.File, java.time.chrono.ChronoLocalDate, java.time.LocalTime)
{
java.time.chrono.ChronoLocalDate v1;
java.time.chrono.ChronoLocalDateTime v3;
java.time.LocalTime v2;
java.io.File v0;
boolean v4;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.time.chrono.ChronoLocalDate;
v2 := @parameter2: java.time.LocalTime;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v1, "chronoLocalDate");
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v2, "localTime");
v3 = interfaceinvoke v1.<java.time.chrono.ChronoLocalDate: java.time.chrono.ChronoLocalDateTime atTime(java.time.LocalTime)>(v2);
v4 = staticinvoke <org.apache.commons.io.FileUtils: boolean isFileOlder(java.io.File,java.time.chrono.ChronoLocalDateTime)>(v0, v3);
return v4;
}
public static boolean isFileOlder(java.io.File, java.time.chrono.ChronoLocalDateTime)
{
java.time.chrono.ChronoLocalDateTime v1;
java.io.File v0;
java.time.ZoneId v2;
boolean v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.time.chrono.ChronoLocalDateTime;
v2 = staticinvoke <java.time.ZoneId: java.time.ZoneId systemDefault()>();
v3 = staticinvoke <org.apache.commons.io.FileUtils: boolean isFileOlder(java.io.File,java.time.chrono.ChronoLocalDateTime,java.time.ZoneId)>(v0, v1, v2);
return v3;
}
public static boolean isFileOlder(java.io.File, java.time.chrono.ChronoLocalDateTime, java.time.ZoneId)
{
java.time.chrono.ChronoZonedDateTime v3;
java.time.chrono.ChronoLocalDateTime v1;
java.io.File v0;
java.time.ZoneId v2;
boolean v4;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.time.chrono.ChronoLocalDateTime;
v2 := @parameter2: java.time.ZoneId;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v1, "chronoLocalDateTime");
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v2, "zoneId");
v3 = interfaceinvoke v1.<java.time.chrono.ChronoLocalDateTime: java.time.chrono.ChronoZonedDateTime atZone(java.time.ZoneId)>(v2);
v4 = staticinvoke <org.apache.commons.io.FileUtils: boolean isFileOlder(java.io.File,java.time.chrono.ChronoZonedDateTime)>(v0, v3);
return v4;
}
public static boolean isFileOlder(java.io.File, java.time.chrono.ChronoZonedDateTime)
{
java.time.chrono.ChronoZonedDateTime v1;
java.time.Instant v2;
java.io.File v0;
boolean v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.time.chrono.ChronoZonedDateTime;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v1, "chronoZonedDateTime");
v2 = interfaceinvoke v1.<java.time.chrono.ChronoZonedDateTime: java.time.Instant toInstant()>();
v3 = staticinvoke <org.apache.commons.io.FileUtils: boolean isFileOlder(java.io.File,java.time.Instant)>(v0, v2);
return v3;
}
public static boolean isFileOlder(java.io.File, java.util.Date)
{
java.util.Date v1;
long v2;
java.io.File v0;
boolean v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.util.Date;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v1, "date");
v2 = virtualinvoke v1.<java.util.Date: long getTime()>();
v3 = staticinvoke <org.apache.commons.io.FileUtils: boolean isFileOlder(java.io.File,long)>(v0, v2);
return v3;
}
public static boolean isFileOlder(java.io.File, java.io.File)
{
long v2;
java.io.File v0, v1;
boolean v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireExists(java.io.File,java.lang.String)>(v1, "reference");
v2 = staticinvoke <org.apache.commons.io.FileUtils: long lastModifiedUnchecked(java.io.File)>(v1);
v3 = staticinvoke <org.apache.commons.io.FileUtils: boolean isFileOlder(java.io.File,long)>(v0, v2);
return v3;
}
public static boolean isFileOlder(java.io.File, java.time.Instant)
{
long v2;
java.time.Instant v1;
java.io.File v0;
boolean v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.time.Instant;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v1, "instant");
v2 = virtualinvoke v1.<java.time.Instant: long toEpochMilli()>();
v3 = staticinvoke <org.apache.commons.io.FileUtils: boolean isFileOlder(java.io.File,long)>(v0, v2);
return v3;
}
public static boolean isFileOlder(java.io.File, long)
{
byte v4;
long v1, v3;
java.io.File v0;
boolean v2, v5;
v0 := @parameter0: java.io.File;
v1 := @parameter1: long;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "file");
v2 = virtualinvoke v0.<java.io.File: boolean exists()>();
if v2 == 0 goto label1;
v3 = staticinvoke <org.apache.commons.io.FileUtils: long lastModifiedUnchecked(java.io.File)>(v0);
v4 = v3 cmp v1;
if v4 >= 0 goto label1;
v5 = 1;
goto label2;
label1:
v5 = 0;
label2:
return v5;
}
public static transient boolean isRegularFile(java.io.File, java.nio.file.LinkOption[])
{
java.nio.file.LinkOption[] v1;
java.nio.file.Path v2;
java.io.File v0;
boolean v3, v4;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.nio.file.LinkOption[];
if v0 == null goto label1;
v2 = virtualinvoke v0.<java.io.File: java.nio.file.Path toPath()>();
v3 = staticinvoke <java.nio.file.Files: boolean isRegularFile(java.nio.file.Path,java.nio.file.LinkOption[])>(v2, v1);
if v3 == 0 goto label1;
v4 = 1;
goto label2;
label1:
v4 = 0;
label2:
return v4;
}
public static boolean isSymlink(java.io.File)
{
java.nio.file.Path v1;
java.io.File v0;
boolean v2, v3;
v0 := @parameter0: java.io.File;
if v0 == null goto label1;
v1 = virtualinvoke v0.<java.io.File: java.nio.file.Path toPath()>();
v2 = staticinvoke <java.nio.file.Files: boolean isSymbolicLink(java.nio.file.Path)>(v1);
if v2 == 0 goto label1;
v3 = 1;
goto label2;
label1:
v3 = 0;
label2:
return v3;
}
public static java.util.Iterator iterateFiles(java.io.File, org.apache.commons.io.filefilter.IOFileFilter, org.apache.commons.io.filefilter.IOFileFilter)
{
org.apache.commons.io.filefilter.IOFileFilter v1, v2;
java.util.Iterator v4;
java.util.Collection v3;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 := @parameter1: org.apache.commons.io.filefilter.IOFileFilter;
v2 := @parameter2: org.apache.commons.io.filefilter.IOFileFilter;
v3 = staticinvoke <org.apache.commons.io.FileUtils: java.util.Collection listFiles(java.io.File,org.apache.commons.io.filefilter.IOFileFilter,org.apache.commons.io.filefilter.IOFileFilter)>(v0, v1, v2);
v4 = interfaceinvoke v3.<java.util.Collection: java.util.Iterator iterator()>();
return v4;
}
public static java.util.Iterator iterateFiles(java.io.File, java.lang.String[], boolean)
{
java.util.Iterator v4;
java.io.IOException v5;
java.lang.String[] v1;
java.io.File v0;
java.io.UncheckedIOException v6;
java.util.stream.Stream v3;
java.lang.String v7;
boolean v2;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String[];
v2 := @parameter2: boolean;
label1:
v3 = staticinvoke <org.apache.commons.io.FileUtils: java.util.stream.Stream streamFiles(java.io.File,boolean,java.lang.String[])>(v0, v2, v1);
v4 = staticinvoke <org.apache.commons.io.StreamIterator: java.util.Iterator iterator(java.util.stream.Stream)>(v3);
label2:
return v4;
label3:
v5 := @caughtexception;
v6 = new java.io.UncheckedIOException;
v7 = virtualinvoke v0.<java.io.File: java.lang.String toString()>();
specialinvoke v6.<java.io.UncheckedIOException: void <init>(java.lang.String,java.io.IOException)>(v7, v5);
throw v6;
catch java.io.IOException from label1 to label2 with label3;
}
public static java.util.Iterator iterateFilesAndDirs(java.io.File, org.apache.commons.io.filefilter.IOFileFilter, org.apache.commons.io.filefilter.IOFileFilter)
{
org.apache.commons.io.filefilter.IOFileFilter v1, v2;
java.util.Iterator v4;
java.util.Collection v3;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 := @parameter1: org.apache.commons.io.filefilter.IOFileFilter;
v2 := @parameter2: org.apache.commons.io.filefilter.IOFileFilter;
v3 = staticinvoke <org.apache.commons.io.FileUtils: java.util.Collection listFilesAndDirs(java.io.File,org.apache.commons.io.filefilter.IOFileFilter,org.apache.commons.io.filefilter.IOFileFilter)>(v0, v1, v2);
v4 = interfaceinvoke v3.<java.util.Collection: java.util.Iterator iterator()>();
return v4;
}
public static long lastModified(java.io.File) throws java.io.IOException
{
java.nio.file.LinkOption[] v3;
java.nio.file.attribute.FileTime v4;
java.lang.Object v2;
long v5;
java.nio.file.Path v1;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 = virtualinvoke v0.<java.io.File: java.nio.file.Path toPath()>();
v2 = staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v1, "file");
v3 = newarray (java.nio.file.LinkOption)[0];
v4 = staticinvoke <java.nio.file.Files: java.nio.file.attribute.FileTime getLastModifiedTime(java.nio.file.Path,java.nio.file.LinkOption[])>(v2, v3);
v5 = virtualinvoke v4.<java.nio.file.attribute.FileTime: long toMillis()>();
return v5;
}
public static long lastModifiedUnchecked(java.io.File)
{
java.io.UncheckedIOException v3;
java.io.IOException v2;
long v1;
java.lang.String v4;
java.io.File v0;
v0 := @parameter0: java.io.File;
label1:
v1 = staticinvoke <org.apache.commons.io.FileUtils: long lastModified(java.io.File)>(v0);
label2:
return v1;
label3:
v2 := @caughtexception;
v3 = new java.io.UncheckedIOException;
v4 = virtualinvoke v0.<java.io.File: java.lang.String toString()>();
specialinvoke v3.<java.io.UncheckedIOException: void <init>(java.lang.String,java.io.IOException)>(v4, v2);
throw v3;
catch java.io.IOException from label1 to label2 with label3;
}
public static org.apache.commons.io.LineIterator lineIterator(java.io.File) throws java.io.IOException
{
org.apache.commons.io.LineIterator v1;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 = staticinvoke <org.apache.commons.io.FileUtils: org.apache.commons.io.LineIterator lineIterator(java.io.File,java.lang.String)>(v0, null);
return v1;
}
public static org.apache.commons.io.LineIterator lineIterator(java.io.File, java.lang.String) throws java.io.IOException
{
java.util.function.Consumer v5;
org.apache.commons.io.LineIterator v3;
java.io.FileInputStream v2;
java.lang.String v1;
java.io.File v0;
java.lang.Exception v4;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
v2 = null;
label1:
v2 = staticinvoke <org.apache.commons.io.FileUtils: java.io.FileInputStream openInputStream(java.io.File)>(v0);
v3 = staticinvoke <org.apache.commons.io.IOUtils: org.apache.commons.io.LineIterator lineIterator(java.io.InputStream,java.lang.String)>(v2, v1);
label2:
return v3;
label3:
v4 := @caughtexception;
virtualinvoke v4.<java.lang.Object: java.lang.Class getClass()>();
v5 = staticinvoke <org.apache.commons.io.FileUtils$addSuppressed__258: java.util.function.Consumer bootstrap$(java.lang.Exception)>(v4);
staticinvoke <org.apache.commons.io.IOUtils: void closeQuietly(java.io.Closeable,java.util.function.Consumer)>(v2, v5);
throw v4;
catch java.io.IOException from label1 to label2 with label3;
catch java.lang.RuntimeException from label1 to label2 with label3;
}
private static org.apache.commons.io.file.AccumulatorPathVisitor listAccumulate(java.io.File, org.apache.commons.io.filefilter.IOFileFilter, org.apache.commons.io.filefilter.IOFileFilter) throws java.io.IOException
{
org.apache.commons.io.filefilter.IOFileFilter v1, v2, v6;
org.apache.commons.io.filefilter.FileEqualsFileFilter v5;
java.util.Set v10;
java.io.File v0;
org.apache.commons.io.file.Counters$PathCounters v8;
int v11;
java.nio.file.Path v9;
org.apache.commons.io.file.AccumulatorPathVisitor v7;
boolean v3, v4;
v0 := @parameter0: java.io.File;
v1 := @parameter1: org.apache.commons.io.filefilter.IOFileFilter;
v2 := @parameter2: org.apache.commons.io.filefilter.IOFileFilter;
if v2 == null goto label1;
v3 = 1;
goto label2;
label1:
v3 = 0;
label2:
v4 = v3;
v5 = new org.apache.commons.io.filefilter.FileEqualsFileFilter;
specialinvoke v5.<org.apache.commons.io.filefilter.FileEqualsFileFilter: void <init>(java.io.File)>(v0);
if v3 == 0 goto label3;
v6 = virtualinvoke v5.<org.apache.commons.io.filefilter.FileEqualsFileFilter: org.apache.commons.io.filefilter.IOFileFilter or(org.apache.commons.io.filefilter.IOFileFilter)>(v2);
goto label4;
label3:
v6 = v5;
label4:
v7 = new org.apache.commons.io.file.AccumulatorPathVisitor;
v8 = staticinvoke <org.apache.commons.io.file.Counters: org.apache.commons.io.file.Counters$PathCounters noopPathCounters()>();
specialinvoke v7.<org.apache.commons.io.file.AccumulatorPathVisitor: void <init>(org.apache.commons.io.file.Counters$PathCounters,org.apache.commons.io.file.PathFilter,org.apache.commons.io.file.PathFilter)>(v8, v1, v6);
v9 = virtualinvoke v0.<java.io.File: java.nio.file.Path toPath()>();
v10 = staticinvoke <java.util.Collections: java.util.Set emptySet()>();
v11 = staticinvoke <org.apache.commons.io.FileUtils: int toMaxDepth(boolean)>(v4);
staticinvoke <java.nio.file.Files: java.nio.file.Path walkFileTree(java.nio.file.Path,java.util.Set,int,java.nio.file.FileVisitor)>(v9, v10, v11, v7);
return v7;
}
private static java.io.File[] listFiles(java.io.File, java.io.FileFilter) throws java.io.IOException
{
java.io.FileFilter v1;
java.io.IOException v3;
java.lang.String v4;
java.io.File[] v2;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.FileFilter;
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireDirectoryExists(java.io.File,java.lang.String)>(v0, "directory");
if v1 != null goto label1;
v2 = virtualinvoke v0.<java.io.File: java.io.File[] listFiles()>();
goto label2;
label1:
v2 = virtualinvoke v0.<java.io.File: java.io.File[] listFiles(java.io.FileFilter)>(v1);
label2:
if v2 != null goto label3;
v3 = new java.io.IOException;
v4 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.io.File)>(v0) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Unknown I/O error listing contents of directory: \u0001");
specialinvoke v3.<java.io.IOException: void <init>(java.lang.String)>(v4);
throw v3;
label3:
return v2;
}
public static java.util.Collection listFiles(java.io.File, org.apache.commons.io.filefilter.IOFileFilter, org.apache.commons.io.filefilter.IOFileFilter)
{
org.apache.commons.io.filefilter.IOFileFilter v1, v2;
java.io.IOException v10;
java.util.function.Function v6;
java.io.File v0;
java.io.UncheckedIOException v11;
java.util.List v4;
java.util.stream.Stream v5, v7;
java.lang.Object v9;
java.lang.String v12;
java.util.stream.Collector v8;
org.apache.commons.io.file.AccumulatorPathVisitor v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: org.apache.commons.io.filefilter.IOFileFilter;
v2 := @parameter2: org.apache.commons.io.filefilter.IOFileFilter;
label1:
v3 = staticinvoke <org.apache.commons.io.FileUtils: org.apache.commons.io.file.AccumulatorPathVisitor listAccumulate(java.io.File,org.apache.commons.io.filefilter.IOFileFilter,org.apache.commons.io.filefilter.IOFileFilter)>(v0, v1, v2);
v4 = virtualinvoke v3.<org.apache.commons.io.file.AccumulatorPathVisitor: java.util.List getFileList()>();
v5 = interfaceinvoke v4.<java.util.List: java.util.stream.Stream stream()>();
v6 = staticinvoke <org.apache.commons.io.FileUtils$toFile__259: java.util.function.Function bootstrap$()>();
v7 = interfaceinvoke v5.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v6);
v8 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector toList()>();
v9 = interfaceinvoke v7.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v8);
label2:
return v9;
label3:
v10 := @caughtexception;
v11 = new java.io.UncheckedIOException;
v12 = virtualinvoke v0.<java.io.File: java.lang.String toString()>();
specialinvoke v11.<java.io.UncheckedIOException: void <init>(java.lang.String,java.io.IOException)>(v12, v10);
throw v11;
catch java.io.IOException from label1 to label2 with label3;
}
public static java.util.Collection listFiles(java.io.File, java.lang.String[], boolean)
{
java.io.IOException v5;
java.lang.String[] v1;
java.io.File v0;
java.io.UncheckedIOException v6;
java.util.List v4;
java.util.stream.Stream v3;
java.lang.String v7;
boolean v2;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String[];
v2 := @parameter2: boolean;
label1:
v3 = staticinvoke <org.apache.commons.io.FileUtils: java.util.stream.Stream streamFiles(java.io.File,boolean,java.lang.String[])>(v0, v2, v1);
v4 = staticinvoke <org.apache.commons.io.FileUtils: java.util.List toList(java.util.stream.Stream)>(v3);
label2:
return v4;
label3:
v5 := @caughtexception;
v6 = new java.io.UncheckedIOException;
v7 = virtualinvoke v0.<java.io.File: java.lang.String toString()>();
specialinvoke v6.<java.io.UncheckedIOException: void <init>(java.lang.String,java.io.IOException)>(v7, v5);
throw v6;
catch java.io.IOException from label1 to label2 with label3;
}
public static java.util.Collection listFilesAndDirs(java.io.File, org.apache.commons.io.filefilter.IOFileFilter, org.apache.commons.io.filefilter.IOFileFilter)
{
org.apache.commons.io.filefilter.IOFileFilter v1, v2;
java.io.IOException v11;
java.util.function.Function v7;
java.io.File v0;
java.io.UncheckedIOException v12;
java.util.List v4, v5;
java.util.stream.Stream v6, v8;
java.lang.Object v10;
java.lang.String v13;
java.util.stream.Collector v9;
org.apache.commons.io.file.AccumulatorPathVisitor v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: org.apache.commons.io.filefilter.IOFileFilter;
v2 := @parameter2: org.apache.commons.io.filefilter.IOFileFilter;
label1:
v3 = staticinvoke <org.apache.commons.io.FileUtils: org.apache.commons.io.file.AccumulatorPathVisitor listAccumulate(java.io.File,org.apache.commons.io.filefilter.IOFileFilter,org.apache.commons.io.filefilter.IOFileFilter)>(v0, v1, v2);
v4 = virtualinvoke v3.<org.apache.commons.io.file.AccumulatorPathVisitor: java.util.List getFileList()>();
v5 = virtualinvoke v3.<org.apache.commons.io.file.AccumulatorPathVisitor: java.util.List getDirList()>();
interfaceinvoke v4.<java.util.List: boolean addAll(java.util.Collection)>(v5);
v6 = interfaceinvoke v4.<java.util.List: java.util.stream.Stream stream()>();
v7 = staticinvoke <org.apache.commons.io.FileUtils$toFile__260: java.util.function.Function bootstrap$()>();
v8 = interfaceinvoke v6.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v7);
v9 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector toList()>();
v10 = interfaceinvoke v8.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v9);
label2:
return v10;
label3:
v11 := @caughtexception;
v12 = new java.io.UncheckedIOException;
v13 = virtualinvoke v0.<java.io.File: java.lang.String toString()>();
specialinvoke v12.<java.io.UncheckedIOException: void <init>(java.lang.String,java.io.IOException)>(v13, v11);
throw v12;
catch java.io.IOException from label1 to label2 with label3;
}
private static java.io.File mkdirs(java.io.File) throws java.io.IOException
{
java.io.IOException v3;
java.lang.String v4;
java.io.File v0;
boolean v1, v2;
v0 := @parameter0: java.io.File;
if v0 == null goto label1;
v1 = virtualinvoke v0.<java.io.File: boolean mkdirs()>();
if v1 != 0 goto label1;
v2 = virtualinvoke v0.<java.io.File: boolean isDirectory()>();
if v2 != 0 goto label1;
v3 = new java.io.IOException;
v4 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.io.File)>(v0) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Cannot create directory \'\u0001\'.");
specialinvoke v3.<java.io.IOException: void <init>(java.lang.String)>(v4);
throw v3;
label1:
return v0;
}
public static void moveDirectory(java.io.File, java.io.File) throws java.io.IOException
{
java.io.IOException v11, v8;
java.io.File v0, v1;
java.lang.String v12, v3, v4, v5, v6, v9;
boolean v10, v2, v7;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
staticinvoke <org.apache.commons.io.FileUtils: void validateMoveParameters(java.io.File,java.io.File)>(v0, v1);
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireDirectory(java.io.File,java.lang.String)>(v0, "srcDir");
staticinvoke <org.apache.commons.io.FileUtils: void requireAbsent(java.io.File,java.lang.String)>(v1, "destDir");
v2 = virtualinvoke v0.<java.io.File: boolean renameTo(java.io.File)>(v1);
if v2 != 0 goto label2;
v3 = virtualinvoke v1.<java.io.File: java.lang.String getCanonicalPath()>();
v4 = virtualinvoke v0.<java.io.File: java.lang.String getCanonicalPath()>();
v5 = <java.io.File: java.lang.String separator>;
v6 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v4, v5) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001\u0001");
v7 = virtualinvoke v3.<java.lang.String: boolean startsWith(java.lang.String)>(v6);
if v7 == 0 goto label1;
v8 = new java.io.IOException;
v9 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.io.File,java.io.File)>(v0, v1) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Cannot move directory: \u0001 to a subdirectory of itself: \u0001");
specialinvoke v8.<java.io.IOException: void <init>(java.lang.String)>(v9);
throw v8;
label1:
staticinvoke <org.apache.commons.io.FileUtils: void copyDirectory(java.io.File,java.io.File)>(v0, v1);
staticinvoke <org.apache.commons.io.FileUtils: void deleteDirectory(java.io.File)>(v0);
v10 = virtualinvoke v0.<java.io.File: boolean exists()>();
if v10 == 0 goto label2;
v11 = new java.io.IOException;
v12 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.io.File,java.io.File)>(v0, v1) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Failed to delete original directory \'\u0001\' after copy to \'\u0001\'");
specialinvoke v11.<java.io.IOException: void <init>(java.lang.String)>(v12);
throw v11;
label2:
return;
}
public static void moveDirectoryToDirectory(java.io.File, java.io.File, boolean) throws java.io.IOException
{
java.io.IOException v5;
java.io.File v0, v1, v9;
java.io.FileNotFoundException v7;
java.lang.String v10, v6, v8;
boolean v2, v3, v4;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
v2 := @parameter2: boolean;
staticinvoke <org.apache.commons.io.FileUtils: void validateMoveParameters(java.io.File,java.io.File)>(v0, v1);
v3 = virtualinvoke v1.<java.io.File: boolean isDirectory()>();
if v3 != 0 goto label3;
v4 = virtualinvoke v1.<java.io.File: boolean exists()>();
if v4 == 0 goto label1;
v5 = new java.io.IOException;
v6 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.io.File)>(v1) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Destination \'\u0001\' is not a directory");
specialinvoke v5.<java.io.IOException: void <init>(java.lang.String)>(v6);
throw v5;
label1:
if v2 != 0 goto label2;
v7 = new java.io.FileNotFoundException;
v8 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.io.File)>(v1) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Destination directory \'\u0001\' does not exist [createDestDir=false]");
specialinvoke v7.<java.io.FileNotFoundException: void <init>(java.lang.String)>(v8);
throw v7;
label2:
staticinvoke <org.apache.commons.io.FileUtils: java.io.File mkdirs(java.io.File)>(v1);
label3:
v9 = new java.io.File;
v10 = virtualinvoke v0.<java.io.File: java.lang.String getName()>();
specialinvoke v9.<java.io.File: void <init>(java.io.File,java.lang.String)>(v1, v10);
staticinvoke <org.apache.commons.io.FileUtils: void moveDirectory(java.io.File,java.io.File)>(v0, v9);
return;
}
public static void moveFile(java.io.File, java.io.File) throws java.io.IOException
{
java.nio.file.CopyOption[] v2;
java.io.File v0, v1;
java.nio.file.StandardCopyOption v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
v2 = newarray (java.nio.file.CopyOption)[1];
v3 = <java.nio.file.StandardCopyOption: java.nio.file.StandardCopyOption COPY_ATTRIBUTES>;
v2[0] = v3;
staticinvoke <org.apache.commons.io.FileUtils: void moveFile(java.io.File,java.io.File,java.nio.file.CopyOption[])>(v0, v1, v2);
return;
}
public static transient void moveFile(java.io.File, java.io.File, java.nio.file.CopyOption[]) throws java.io.IOException
{
java.nio.file.CopyOption[] v2;
java.io.IOException v5;
java.lang.String v6;
java.io.File v0, v1;
boolean v3, v4;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
v2 := @parameter2: java.nio.file.CopyOption[];
staticinvoke <org.apache.commons.io.FileUtils: void validateMoveParameters(java.io.File,java.io.File)>(v0, v1);
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireFile(java.io.File,java.lang.String)>(v0, "srcFile");
staticinvoke <org.apache.commons.io.FileUtils: void requireAbsent(java.io.File,java.lang.String)>(v1, null);
v3 = virtualinvoke v0.<java.io.File: boolean renameTo(java.io.File)>(v1);
if v3 != 0 goto label1;
staticinvoke <org.apache.commons.io.FileUtils: void copyFile(java.io.File,java.io.File,java.nio.file.CopyOption[])>(v0, v1, v2);
v4 = virtualinvoke v0.<java.io.File: boolean delete()>();
if v4 != 0 goto label1;
staticinvoke <org.apache.commons.io.FileUtils: boolean deleteQuietly(java.io.File)>(v1);
v5 = new java.io.IOException;
v6 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.io.File,java.io.File)>(v0, v1) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Failed to delete original file \'\u0001\' after copy to \'\u0001\'");
specialinvoke v5.<java.io.IOException: void <init>(java.lang.String)>(v6);
throw v5;
label1:
return;
}
public static void moveFileToDirectory(java.io.File, java.io.File, boolean) throws java.io.IOException
{
java.lang.String v5;
java.io.File v0, v1, v4;
boolean v2, v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
v2 := @parameter2: boolean;
staticinvoke <org.apache.commons.io.FileUtils: void validateMoveParameters(java.io.File,java.io.File)>(v0, v1);
v3 = virtualinvoke v1.<java.io.File: boolean exists()>();
if v3 != 0 goto label1;
if v2 == 0 goto label1;
staticinvoke <org.apache.commons.io.FileUtils: java.io.File mkdirs(java.io.File)>(v1);
label1:
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireExistsChecked(java.io.File,java.lang.String)>(v1, "destDir");
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireDirectory(java.io.File,java.lang.String)>(v1, "destDir");
v4 = new java.io.File;
v5 = virtualinvoke v0.<java.io.File: java.lang.String getName()>();
specialinvoke v4.<java.io.File: void <init>(java.io.File,java.lang.String)>(v1, v5);
staticinvoke <org.apache.commons.io.FileUtils: void moveFile(java.io.File,java.io.File)>(v0, v4);
return;
}
public static void moveToDirectory(java.io.File, java.io.File, boolean) throws java.io.IOException
{
java.io.File v0, v1;
boolean v2, v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
v2 := @parameter2: boolean;
staticinvoke <org.apache.commons.io.FileUtils: void validateMoveParameters(java.io.File,java.io.File)>(v0, v1);
v3 = virtualinvoke v0.<java.io.File: boolean isDirectory()>();
if v3 == 0 goto label1;
staticinvoke <org.apache.commons.io.FileUtils: void moveDirectoryToDirectory(java.io.File,java.io.File,boolean)>(v0, v1, v2);
goto label2;
label1:
staticinvoke <org.apache.commons.io.FileUtils: void moveFileToDirectory(java.io.File,java.io.File,boolean)>(v0, v1, v2);
label2:
return;
}
public static java.io.FileInputStream openInputStream(java.io.File) throws java.io.IOException
{
java.io.FileInputStream v1;
java.io.File v0;
v0 := @parameter0: java.io.File;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "file");
v1 = new java.io.FileInputStream;
specialinvoke v1.<java.io.FileInputStream: void <init>(java.io.File)>(v0);
return v1;
}
public static java.io.FileOutputStream openOutputStream(java.io.File) throws java.io.IOException
{
java.io.FileOutputStream v1;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 = staticinvoke <org.apache.commons.io.FileUtils: java.io.FileOutputStream openOutputStream(java.io.File,boolean)>(v0, 0);
return v1;
}
public static java.io.FileOutputStream openOutputStream(java.io.File, boolean) throws java.io.IOException
{
java.io.FileOutputStream v3;
java.io.File v0;
boolean v1, v2;
v0 := @parameter0: java.io.File;
v1 := @parameter1: boolean;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "file");
v2 = virtualinvoke v0.<java.io.File: boolean exists()>();
if v2 == 0 goto label1;
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireFile(java.io.File,java.lang.String)>(v0, "file");
staticinvoke <org.apache.commons.io.FileUtils: void requireCanWrite(java.io.File,java.lang.String)>(v0, "file");
goto label2;
label1:
staticinvoke <org.apache.commons.io.FileUtils: java.io.File createParentDirectories(java.io.File)>(v0);
label2:
v3 = new java.io.FileOutputStream;
specialinvoke v3.<java.io.FileOutputStream: void <init>(java.io.File,boolean)>(v0, v1);
return v3;
}
public static byte[] readFileToByteArray(java.io.File) throws java.io.IOException
{
java.lang.Throwable v6;
byte[] v4, v5;
byte v3;
long v2;
java.io.FileInputStream v1;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 = staticinvoke <org.apache.commons.io.FileUtils: java.io.FileInputStream openInputStream(java.io.File)>(v0);
label1:
v2 = virtualinvoke v0.<java.io.File: long length()>();
v3 = v2 cmp 0L;
if v3 <= 0 goto label2;
v4 = staticinvoke <org.apache.commons.io.IOUtils: byte[] toByteArray(java.io.InputStream,long)>(v1, v2);
goto label3;
label2:
v4 = staticinvoke <org.apache.commons.io.IOUtils: byte[] toByteArray(java.io.InputStream)>(v1);
label3:
v5 = v4;
label4:
if v1 == null goto label5;
virtualinvoke v1.<java.io.InputStream: void close()>();
label5:
return v5;
label6:
v6 := @caughtexception;
throw v6;
catch java.lang.Throwable from label1 to label4 with label6;
}
public static java.lang.String readFileToString(java.io.File) throws java.io.IOException
{
java.lang.String v2;
java.nio.charset.Charset v1;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 = staticinvoke <java.nio.charset.Charset: java.nio.charset.Charset defaultCharset()>();
v2 = staticinvoke <org.apache.commons.io.FileUtils: java.lang.String readFileToString(java.io.File,java.nio.charset.Charset)>(v0, v1);
return v2;
}
public static java.lang.String readFileToString(java.io.File, java.nio.charset.Charset) throws java.io.IOException
{
java.lang.Throwable v5;
java.nio.charset.Charset v1, v3;
java.io.FileInputStream v2;
java.lang.String v4;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.nio.charset.Charset;
v2 = staticinvoke <org.apache.commons.io.FileUtils: java.io.FileInputStream openInputStream(java.io.File)>(v0);
label1:
v3 = staticinvoke <org.apache.commons.io.Charsets: java.nio.charset.Charset toCharset(java.nio.charset.Charset)>(v1);
v4 = staticinvoke <org.apache.commons.io.IOUtils: java.lang.String toString(java.io.InputStream,java.nio.charset.Charset)>(v2, v3);
label2:
if v2 == null goto label3;
virtualinvoke v2.<java.io.InputStream: void close()>();
label3:
return v4;
label4:
v5 := @caughtexception;
throw v5;
catch java.lang.Throwable from label1 to label2 with label4;
}
public static java.lang.String readFileToString(java.io.File, java.lang.String) throws java.io.IOException
{
java.nio.charset.Charset v2;
java.lang.String v1, v3;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
v2 = staticinvoke <org.apache.commons.io.Charsets: java.nio.charset.Charset toCharset(java.lang.String)>(v1);
v3 = staticinvoke <org.apache.commons.io.FileUtils: java.lang.String readFileToString(java.io.File,java.nio.charset.Charset)>(v0, v2);
return v3;
}
public static java.util.List readLines(java.io.File) throws java.io.IOException
{
java.util.List v2;
java.nio.charset.Charset v1;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 = staticinvoke <java.nio.charset.Charset: java.nio.charset.Charset defaultCharset()>();
v2 = staticinvoke <org.apache.commons.io.FileUtils: java.util.List readLines(java.io.File,java.nio.charset.Charset)>(v0, v1);
return v2;
}
public static java.util.List readLines(java.io.File, java.nio.charset.Charset) throws java.io.IOException
{
java.lang.Throwable v5;
java.util.List v4;
java.nio.charset.Charset v1, v3;
java.io.FileInputStream v2;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.nio.charset.Charset;
v2 = staticinvoke <org.apache.commons.io.FileUtils: java.io.FileInputStream openInputStream(java.io.File)>(v0);
label1:
v3 = staticinvoke <org.apache.commons.io.Charsets: java.nio.charset.Charset toCharset(java.nio.charset.Charset)>(v1);
v4 = staticinvoke <org.apache.commons.io.IOUtils: java.util.List readLines(java.io.InputStream,java.nio.charset.Charset)>(v2, v3);
label2:
if v2 == null goto label3;
virtualinvoke v2.<java.io.InputStream: void close()>();
label3:
return v4;
label4:
v5 := @caughtexception;
throw v5;
catch java.lang.Throwable from label1 to label2 with label4;
}
public static java.util.List readLines(java.io.File, java.lang.String) throws java.io.IOException
{
java.util.List v3;
java.nio.charset.Charset v2;
java.lang.String v1;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
v2 = staticinvoke <org.apache.commons.io.Charsets: java.nio.charset.Charset toCharset(java.lang.String)>(v1);
v3 = staticinvoke <org.apache.commons.io.FileUtils: java.util.List readLines(java.io.File,java.nio.charset.Charset)>(v0, v2);
return v3;
}
private static void requireAbsent(java.io.File, java.lang.String) throws org.apache.commons.io.FileExistsException
{
java.lang.Object[] v4;
org.apache.commons.io.FileExistsException v3;
java.lang.String v1, v5;
java.io.File v0;
boolean v2;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
v2 = virtualinvoke v0.<java.io.File: boolean exists()>();
if v2 == 0 goto label1;
v3 = new org.apache.commons.io.FileExistsException;
v4 = newarray (java.lang.Object)[2];
v4[0] = v1;
v4[1] = v0;
v5 = staticinvoke <java.lang.String: java.lang.String format(java.lang.String,java.lang.Object[])>("File element in parameter \'%s\' already exists: \'%s\'", v4);
specialinvoke v3.<org.apache.commons.io.FileExistsException: void <init>(java.lang.String)>(v5);
throw v3;
label1:
return;
}
private static void requireCanonicalPathsNotEquals(java.io.File, java.io.File) throws java.io.IOException
{
java.lang.Object[] v6;
java.lang.IllegalArgumentException v5;
java.io.File v0, v1;
java.lang.String v2, v3, v7;
boolean v4;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
v2 = virtualinvoke v0.<java.io.File: java.lang.String getCanonicalPath()>();
v3 = virtualinvoke v1.<java.io.File: java.lang.String getCanonicalPath()>();
v4 = virtualinvoke v2.<java.lang.String: boolean equals(java.lang.Object)>(v3);
if v4 == 0 goto label1;
v5 = new java.lang.IllegalArgumentException;
v6 = newarray (java.lang.Object)[3];
v6[0] = v2;
v6[1] = v0;
v6[2] = v1;
v7 = staticinvoke <java.lang.String: java.lang.String format(java.lang.String,java.lang.Object[])>("File canonical paths are equal: \'%s\' (file1=\'%s\', file2=\'%s\')", v6);
specialinvoke v5.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(v7);
throw v5;
label1:
return;
}
private static void requireCanWrite(java.io.File, java.lang.String)
{
java.lang.String v1, v4;
java.lang.IllegalArgumentException v3;
java.io.File v0;
boolean v2;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "file");
v2 = virtualinvoke v0.<java.io.File: boolean canWrite()>();
if v2 != 0 goto label1;
v3 = new java.lang.IllegalArgumentException;
v4 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.io.File)>(v1, v0) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("File parameter \'\u0001 is not writable: \'\u0001\'");
specialinvoke v3.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(v4);
throw v3;
label1:
return;
}
private static java.io.File requireDirectory(java.io.File, java.lang.String)
{
java.lang.String v1, v4;
java.lang.IllegalArgumentException v3;
java.io.File v0;
boolean v2;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, v1);
v2 = virtualinvoke v0.<java.io.File: boolean isDirectory()>();
if v2 != 0 goto label1;
v3 = new java.lang.IllegalArgumentException;
v4 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.io.File)>(v1, v0) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Parameter \'\u0001\' is not a directory: \'\u0001\'");
specialinvoke v3.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(v4);
throw v3;
label1:
return v0;
}
private static java.io.File requireDirectoryExists(java.io.File, java.lang.String)
{
java.lang.String v1;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireExists(java.io.File,java.lang.String)>(v0, v1);
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireDirectory(java.io.File,java.lang.String)>(v0, v1);
return v0;
}
private static java.io.File requireDirectoryIfExists(java.io.File, java.lang.String)
{
java.lang.String v1;
java.io.File v0;
boolean v2;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, v1);
v2 = virtualinvoke v0.<java.io.File: boolean exists()>();
if v2 == 0 goto label1;
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireDirectory(java.io.File,java.lang.String)>(v0, v1);
label1:
return v0;
}
private static void requireEqualSizes(java.io.File, java.io.File, long, long) throws java.io.IOException
{
byte v4;
java.io.IOException v5;
long v2, v3;
java.lang.String v6;
java.io.File v0, v1;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
v2 := @parameter2: long;
v3 := @parameter3: long;
v4 = v2 cmp v3;
if v4 == 0 goto label1;
v5 = new java.io.IOException;
v6 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.io.File,java.io.File,long,long)>(v0, v1, v2, v3) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Failed to copy full contents from \'\u0001\' to \'\u0001\' Expected length: \u0001 Actual: \u0001");
specialinvoke v5.<java.io.IOException: void <init>(java.lang.String)>(v6);
throw v5;
label1:
return;
}
private static java.io.File requireExists(java.io.File, java.lang.String)
{
java.lang.String v1, v4;
java.lang.IllegalArgumentException v3;
java.io.File v0;
boolean v2;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, v1);
v2 = virtualinvoke v0.<java.io.File: boolean exists()>();
if v2 != 0 goto label1;
v3 = new java.lang.IllegalArgumentException;
v4 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.io.File)>(v1, v0) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("File system element for parameter \'\u0001\' does not exist: \'\u0001\'");
specialinvoke v3.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(v4);
throw v3;
label1:
return v0;
}
private static java.io.File requireExistsChecked(java.io.File, java.lang.String) throws java.io.FileNotFoundException
{
java.lang.String v1, v4;
java.io.File v0;
java.io.FileNotFoundException v3;
boolean v2;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, v1);
v2 = virtualinvoke v0.<java.io.File: boolean exists()>();
if v2 != 0 goto label1;
v3 = new java.io.FileNotFoundException;
v4 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.io.File)>(v1, v0) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("File system element for parameter \'\u0001\' does not exist: \'\u0001\'");
specialinvoke v3.<java.io.FileNotFoundException: void <init>(java.lang.String)>(v4);
throw v3;
label1:
return v0;
}
private static java.io.File requireFile(java.io.File, java.lang.String)
{
java.lang.String v1, v4;
java.lang.IllegalArgumentException v3;
java.io.File v0;
boolean v2;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, v1);
v2 = virtualinvoke v0.<java.io.File: boolean isFile()>();
if v2 != 0 goto label1;
v3 = new java.lang.IllegalArgumentException;
v4 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.io.File)>(v1, v0) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Parameter \'\u0001\' is not a file: \u0001");
specialinvoke v3.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(v4);
throw v3;
label1:
return v0;
}
private static void requireFileCopy(java.io.File, java.io.File) throws java.io.FileNotFoundException
{
java.io.File v0, v1;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireExistsChecked(java.io.File,java.lang.String)>(v0, "source");
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v1, "destination");
return;
}
private static java.io.File requireFileIfExists(java.io.File, java.lang.String)
{
java.lang.String v1;
java.io.File v0, v3;
boolean v2;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, v1);
v2 = virtualinvoke v0.<java.io.File: boolean exists()>();
if v2 == 0 goto label1;
v3 = staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireFile(java.io.File,java.lang.String)>(v0, v1);
goto label2;
label1:
v3 = v0;
label2:
return v3;
}
private static void setLastModified(java.io.File, java.io.File) throws java.io.IOException
{
long v2;
java.io.File v0, v1;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "sourceFile");
v2 = staticinvoke <org.apache.commons.io.FileUtils: long lastModified(java.io.File)>(v0);
staticinvoke <org.apache.commons.io.FileUtils: void setLastModified(java.io.File,long)>(v1, v2);
return;
}
private static void setLastModified(java.io.File, long) throws java.io.IOException
{
java.lang.Object[] v4;
java.lang.Long v5;
java.io.IOException v3;
long v1;
java.lang.String v6;
java.io.File v0;
boolean v2;
v0 := @parameter0: java.io.File;
v1 := @parameter1: long;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "file");
v2 = virtualinvoke v0.<java.io.File: boolean setLastModified(long)>(v1);
if v2 != 0 goto label1;
v3 = new java.io.IOException;
v4 = newarray (java.lang.Object)[2];
v5 = staticinvoke <java.lang.Long: java.lang.Long valueOf(long)>(v1);
v4[0] = v5;
v4[1] = v0;
v6 = staticinvoke <java.lang.String: java.lang.String format(java.lang.String,java.lang.Object[])>("Failed setLastModified(%s) on \'%s\'", v4);
specialinvoke v3.<java.io.IOException: void <init>(java.lang.String)>(v6);
throw v3;
label1:
return;
}
public static long sizeOf(java.io.File)
{
long v2;
java.io.File v0;
boolean v1;
v0 := @parameter0: java.io.File;
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireExists(java.io.File,java.lang.String)>(v0, "file");
v1 = virtualinvoke v0.<java.io.File: boolean isDirectory()>();
if v1 == 0 goto label1;
v2 = staticinvoke <org.apache.commons.io.FileUtils: long sizeOfDirectory0(java.io.File)>(v0);
goto label2;
label1:
v2 = virtualinvoke v0.<java.io.File: long length()>();
label2:
return v2;
}
private static long sizeOf0(java.io.File)
{
long v2, v3;
java.io.File v0;
boolean v1;
v0 := @parameter0: java.io.File;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "file");
v1 = virtualinvoke v0.<java.io.File: boolean isDirectory()>();
if v1 == 0 goto label1;
v2 = staticinvoke <org.apache.commons.io.FileUtils: long sizeOfDirectory0(java.io.File)>(v0);
return v2;
label1:
v3 = virtualinvoke v0.<java.io.File: long length()>();
return v3;
}
public static java.math.BigInteger sizeOfAsBigInteger(java.io.File)
{
java.math.BigInteger v2;
long v3;
java.io.File v0;
boolean v1;
v0 := @parameter0: java.io.File;
staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireExists(java.io.File,java.lang.String)>(v0, "file");
v1 = virtualinvoke v0.<java.io.File: boolean isDirectory()>();
if v1 == 0 goto label1;
v2 = staticinvoke <org.apache.commons.io.FileUtils: java.math.BigInteger sizeOfDirectoryBig0(java.io.File)>(v0);
goto label2;
label1:
v3 = virtualinvoke v0.<java.io.File: long length()>();
v2 = staticinvoke <java.math.BigInteger: java.math.BigInteger valueOf(long)>(v3);
label2:
return v2;
}
private static java.math.BigInteger sizeOfBig0(java.io.File)
{
java.math.BigInteger v2;
long v3;
java.io.File v0;
boolean v1;
v0 := @parameter0: java.io.File;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "fileOrDir");
v1 = virtualinvoke v0.<java.io.File: boolean isDirectory()>();
if v1 == 0 goto label1;
v2 = staticinvoke <org.apache.commons.io.FileUtils: java.math.BigInteger sizeOfDirectoryBig0(java.io.File)>(v0);
goto label2;
label1:
v3 = virtualinvoke v0.<java.io.File: long length()>();
v2 = staticinvoke <java.math.BigInteger: java.math.BigInteger valueOf(long)>(v3);
label2:
return v2;
}
public static long sizeOfDirectory(java.io.File)
{
long v2;
java.io.File v0, v1;
v0 := @parameter0: java.io.File;
v1 = staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireDirectoryExists(java.io.File,java.lang.String)>(v0, "directory");
v2 = staticinvoke <org.apache.commons.io.FileUtils: long sizeOfDirectory0(java.io.File)>(v1);
return v2;
}
private static long sizeOfDirectory0(java.io.File)
{
long v2, v7;
java.io.File v0, v5;
byte v8;
int v3, v4;
java.io.File[] v1;
boolean v6;
v0 := @parameter0: java.io.File;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "directory");
v1 = virtualinvoke v0.<java.io.File: java.io.File[] listFiles()>();
if v1 != null goto label1;
return 0L;
label1:
v2 = 0L;
v3 = lengthof v1;
v4 = 0;
label2:
if v4 >= v3 goto label4;
v5 = v1[v4];
v6 = staticinvoke <org.apache.commons.io.FileUtils: boolean isSymlink(java.io.File)>(v5);
if v6 != 0 goto label3;
v7 = staticinvoke <org.apache.commons.io.FileUtils: long sizeOf0(java.io.File)>(v5);
v2 = v2 + v7;
v8 = v2 cmp 0L;
if v8 < 0 goto label4;
label3:
v4 = v4 + 1;
goto label2;
label4:
return v2;
}
public static java.math.BigInteger sizeOfDirectoryAsBigInteger(java.io.File)
{
java.math.BigInteger v2;
java.io.File v0, v1;
v0 := @parameter0: java.io.File;
v1 = staticinvoke <org.apache.commons.io.FileUtils: java.io.File requireDirectoryExists(java.io.File,java.lang.String)>(v0, "directory");
v2 = staticinvoke <org.apache.commons.io.FileUtils: java.math.BigInteger sizeOfDirectoryBig0(java.io.File)>(v1);
return v2;
}
private static java.math.BigInteger sizeOfDirectoryBig0(java.io.File)
{
java.io.File v0, v6;
int v4, v5;
java.math.BigInteger v2, v3, v8;
java.io.File[] v1;
boolean v7;
v0 := @parameter0: java.io.File;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "directory");
v1 = virtualinvoke v0.<java.io.File: java.io.File[] listFiles()>();
if v1 != null goto label1;
v2 = <java.math.BigInteger: java.math.BigInteger ZERO>;
return v2;
label1:
v3 = <java.math.BigInteger: java.math.BigInteger ZERO>;
v4 = lengthof v1;
v5 = 0;
label2:
if v5 >= v4 goto label4;
v6 = v1[v5];
v7 = staticinvoke <org.apache.commons.io.FileUtils: boolean isSymlink(java.io.File)>(v6);
if v7 != 0 goto label3;
v8 = staticinvoke <org.apache.commons.io.FileUtils: java.math.BigInteger sizeOfBig0(java.io.File)>(v6);
v3 = virtualinvoke v3.<java.math.BigInteger: java.math.BigInteger add(java.math.BigInteger)>(v8);
label3:
v5 = v5 + 1;
goto label2;
label4:
return v3;
}
public static transient java.util.stream.Stream streamFiles(java.io.File, boolean, java.lang.String[]) throws java.io.IOException
{
org.apache.commons.io.filefilter.IOFileFilter v3, v4;
java.nio.file.FileVisitOption[] v9;
java.lang.String[] v2, v6;
java.util.function.Function v12;
java.io.File v0;
java.util.stream.Stream v11, v13;
org.apache.commons.io.filefilter.SuffixFileFilter v5;
java.nio.file.FileVisitOption v10;
int v8;
java.nio.file.Path v7;
boolean v1;
v0 := @parameter0: java.io.File;
v1 := @parameter1: boolean;
v2 := @parameter2: java.lang.String[];
if v2 != null goto label1;
v3 = <org.apache.commons.io.filefilter.FileFileFilter: org.apache.commons.io.filefilter.IOFileFilter INSTANCE>;
goto label2;
label1:
v4 = <org.apache.commons.io.filefilter.FileFileFilter: org.apache.commons.io.filefilter.IOFileFilter INSTANCE>;
v5 = new org.apache.commons.io.filefilter.SuffixFileFilter;
v6 = staticinvoke <org.apache.commons.io.FileUtils: java.lang.String[] toSuffixes(java.lang.String[])>(v2);
specialinvoke v5.<org.apache.commons.io.filefilter.SuffixFileFilter: void <init>(java.lang.String[])>(v6);
v3 = interfaceinvoke v4.<org.apache.commons.io.filefilter.IOFileFilter: org.apache.commons.io.filefilter.IOFileFilter and(org.apache.commons.io.filefilter.IOFileFilter)>(v5);
label2:
v7 = virtualinvoke v0.<java.io.File: java.nio.file.Path toPath()>();
v8 = staticinvoke <org.apache.commons.io.FileUtils: int toMaxDepth(boolean)>(v1);
v9 = newarray (java.nio.file.FileVisitOption)[1];
v10 = <java.nio.file.FileVisitOption: java.nio.file.FileVisitOption FOLLOW_LINKS>;
v9[0] = v10;
v11 = staticinvoke <org.apache.commons.io.file.PathUtils: java.util.stream.Stream walk(java.nio.file.Path,org.apache.commons.io.file.PathFilter,int,boolean,java.nio.file.FileVisitOption[])>(v7, v3, v8, 0, v9);
v12 = staticinvoke <org.apache.commons.io.FileUtils$toFile__261: java.util.function.Function bootstrap$()>();
v13 = interfaceinvoke v11.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v12);
return v13;
}
public static java.io.File toFile(java.net.URL)
{
java.net.URL v0;
char v5;
java.io.File v7;
java.lang.String v1, v2, v4, v6, v8;
boolean v3;
v0 := @parameter0: java.net.URL;
if v0 == null goto label1;
v1 = "file";
v2 = virtualinvoke v0.<java.net.URL: java.lang.String getProtocol()>();
v3 = virtualinvoke v1.<java.lang.String: boolean equalsIgnoreCase(java.lang.String)>(v2);
if v3 != 0 goto label2;
label1:
return null;
label2:
v4 = virtualinvoke v0.<java.net.URL: java.lang.String getFile()>();
v5 = <java.io.File: char separatorChar>;
v6 = virtualinvoke v4.<java.lang.String: java.lang.String replace(char,char)>(47, v5);
v7 = new java.io.File;
v8 = staticinvoke <org.apache.commons.io.FileUtils: java.lang.String decodeUrl(java.lang.String)>(v6);
specialinvoke v7.<java.io.File: void <init>(java.lang.String)>(v8);
return v7;
}
public static transient java.io.File[] toFiles(java.net.URL[])
{
java.net.URL v7;
java.lang.IllegalArgumentException v11;
java.io.File v13;
java.net.URL[] v0;
int v1, v3, v5, v6;
java.lang.String v12, v8, v9;
java.io.File[] v2, v4;
boolean v10;
v0 := @parameter0: java.net.URL[];
v1 = staticinvoke <org.apache.commons.io.IOUtils: int length(java.lang.Object[])>(v0);
if v1 != 0 goto label1;
v2 = <org.apache.commons.io.FileUtils: java.io.File[] EMPTY_FILE_ARRAY>;
return v2;
label1:
v3 = lengthof v0;
v4 = newarray (java.io.File)[v3];
v5 = 0;
label2:
v6 = lengthof v0;
if v5 >= v6 goto label5;
v7 = v0[v5];
if v7 == null goto label4;
v8 = "file";
v9 = virtualinvoke v7.<java.net.URL: java.lang.String getProtocol()>();
v10 = virtualinvoke v8.<java.lang.String: boolean equalsIgnoreCase(java.lang.String)>(v9);
if v10 != 0 goto label3;
v11 = new java.lang.IllegalArgumentException;
v12 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.net.URL)>(v7) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Can only convert file URL to a File: \u0001");
specialinvoke v11.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(v12);
throw v11;
label3:
v13 = staticinvoke <org.apache.commons.io.FileUtils: java.io.File toFile(java.net.URL)>(v7);
v4[v5] = v13;
label4:
v5 = v5 + 1;
goto label2;
label5:
return v4;
}
private static java.util.List toList(java.util.stream.Stream)
{
java.lang.Object v2;
java.util.stream.Collector v1;
java.util.stream.Stream v0;
v0 := @parameter0: java.util.stream.Stream;
v1 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector toList()>();
v2 = interfaceinvoke v0.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v1);
return v2;
}
private static int toMaxDepth(boolean)
{
int v1;
boolean v0;
v0 := @parameter0: boolean;
if v0 == 0 goto label1;
v1 = 2147483647;
goto label2;
label1:
v1 = 1;
label2:
return v1;
}
private static transient java.lang.String[] toSuffixes(java.lang.String[])
{
int v1, v3, v4;
java.lang.String[] v0, v2;
java.lang.String v5, v6;
v0 := @parameter0: java.lang.String[];
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "extensions");
v1 = lengthof v0;
v2 = newarray (java.lang.String)[v1];
v3 = 0;
label1:
v4 = lengthof v0;
if v3 >= v4 goto label2;
v5 = v0[v3];
v6 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v5) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>(".\u0001");
v2[v3] = v6;
v3 = v3 + 1;
goto label1;
label2:
return v2;
}
public static void touch(java.io.File) throws java.io.IOException
{
java.io.FileOutputStream v2;
long v3;
java.io.File v0;
boolean v1;
v0 := @parameter0: java.io.File;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "file");
v1 = virtualinvoke v0.<java.io.File: boolean exists()>();
if v1 != 0 goto label1;
v2 = staticinvoke <org.apache.commons.io.FileUtils: java.io.FileOutputStream openOutputStream(java.io.File)>(v0);
virtualinvoke v2.<java.io.FileOutputStream: void close()>();
label1:
v3 = staticinvoke <java.lang.System: long currentTimeMillis()>();
staticinvoke <org.apache.commons.io.FileUtils: void setLastModified(java.io.File,long)>(v0, v3);
return;
}
public static transient java.net.URL[] toURLs(java.io.File[]) throws java.io.IOException
{
java.net.URL v7;
java.io.File v5;
java.net.URL[] v2;
int v1, v3, v4;
java.net.URI v6;
java.io.File[] v0;
v0 := @parameter0: java.io.File[];
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "files");
v1 = lengthof v0;
v2 = newarray (java.net.URL)[v1];
v3 = 0;
label1:
v4 = lengthof v2;
if v3 >= v4 goto label2;
v5 = v0[v3];
v6 = virtualinvoke v5.<java.io.File: java.net.URI toURI()>();
v7 = virtualinvoke v6.<java.net.URI: java.net.URL toURL()>();
v2[v3] = v7;
v3 = v3 + 1;
goto label1;
label2:
return v2;
}
private static void validateMoveParameters(java.io.File, java.io.File) throws java.io.FileNotFoundException
{
java.lang.String v4;
java.io.File v0, v1;
java.io.FileNotFoundException v3;
boolean v2;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.io.File;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "source");
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v1, "destination");
v2 = virtualinvoke v0.<java.io.File: boolean exists()>();
if v2 != 0 goto label1;
v3 = new java.io.FileNotFoundException;
v4 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.io.File)>(v0) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Source \'\u0001\' does not exist");
specialinvoke v3.<java.io.FileNotFoundException: void <init>(java.lang.String)>(v4);
throw v3;
label1:
return;
}
public static boolean waitFor(java.io.File, int)
{
java.lang.Throwable v15;
long v11, v2, v3, v4, v7, v8;
byte v9;
java.lang.Thread v10, v14, v16;
int v1;
boolean v5, v6;
java.io.File v0;
java.lang.Exception v13;
java.lang.InterruptedException v12;
v0 := @parameter0: java.io.File;
v1 := @parameter1: int;
staticinvoke <java.util.Objects: java.lang.Object requireNonNull(java.lang.Object,java.lang.String)>(v0, "file");
v2 = staticinvoke <java.lang.System: long currentTimeMillis()>();
v3 = v1 * 1000L;
v4 = v2 + v3;
v5 = 0;
label01:
v6 = virtualinvoke v0.<java.io.File: boolean exists()>();
if v6 != 0 goto label08;
v7 = staticinvoke <java.lang.System: long currentTimeMillis()>();
v8 = v4 - v7;
v9 = v8 cmp 0L;
if v9 >= 0 goto label04;
label02:
if v5 == 0 goto label03;
v10 = staticinvoke <java.lang.Thread: java.lang.Thread currentThread()>();
virtualinvoke v10.<java.lang.Thread: void interrupt()>();
label03:
return 0;
label04:
v11 = staticinvoke <java.lang.Math: long min(long,long)>(100L, v8);
staticinvoke <java.lang.Thread: void sleep(long)>(v11);
label05:
goto label01;
label06:
v12 := @caughtexception;
v5 = 1;
goto label01;
label07:
v13 := @caughtexception;
label08:
if v5 == 0 goto label11;
v14 = staticinvoke <java.lang.Thread: java.lang.Thread currentThread()>();
virtualinvoke v14.<java.lang.Thread: void interrupt()>();
goto label11;
label09:
v15 := @caughtexception;
if v5 == 0 goto label10;
v16 = staticinvoke <java.lang.Thread: java.lang.Thread currentThread()>();
virtualinvoke v16.<java.lang.Thread: void interrupt()>();
label10:
throw v15;
label11:
return 1;
catch java.lang.InterruptedException from label04 to label05 with label06;
catch java.lang.Exception from label04 to label05 with label07;
catch java.lang.Throwable from label01 to label02 with label09;
catch java.lang.Throwable from label04 to label08 with label09;
}
public static void write(java.io.File, java.lang.CharSequence) throws java.io.IOException
{
java.lang.CharSequence v1;
java.nio.charset.Charset v2;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.CharSequence;
v2 = staticinvoke <java.nio.charset.Charset: java.nio.charset.Charset defaultCharset()>();
staticinvoke <org.apache.commons.io.FileUtils: void write(java.io.File,java.lang.CharSequence,java.nio.charset.Charset,boolean)>(v0, v1, v2, 0);
return;
}
public static void write(java.io.File, java.lang.CharSequence, boolean) throws java.io.IOException
{
java.lang.CharSequence v1;
java.nio.charset.Charset v3;
java.io.File v0;
boolean v2;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.CharSequence;
v2 := @parameter2: boolean;
v3 = staticinvoke <java.nio.charset.Charset: java.nio.charset.Charset defaultCharset()>();
staticinvoke <org.apache.commons.io.FileUtils: void write(java.io.File,java.lang.CharSequence,java.nio.charset.Charset,boolean)>(v0, v1, v3, v2);
return;
}
public static void write(java.io.File, java.lang.CharSequence, java.nio.charset.Charset) throws java.io.IOException
{
java.lang.CharSequence v1;
java.nio.charset.Charset v2;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.CharSequence;
v2 := @parameter2: java.nio.charset.Charset;
staticinvoke <org.apache.commons.io.FileUtils: void write(java.io.File,java.lang.CharSequence,java.nio.charset.Charset,boolean)>(v0, v1, v2, 0);
return;
}
public static void write(java.io.File, java.lang.CharSequence, java.nio.charset.Charset, boolean) throws java.io.IOException
{
java.lang.CharSequence v1;
java.nio.charset.Charset v2;
java.lang.String v4;
java.io.File v0;
boolean v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.CharSequence;
v2 := @parameter2: java.nio.charset.Charset;
v3 := @parameter3: boolean;
v4 = staticinvoke <java.util.Objects: java.lang.String toString(java.lang.Object,java.lang.String)>(v1, null);
staticinvoke <org.apache.commons.io.FileUtils: void writeStringToFile(java.io.File,java.lang.String,java.nio.charset.Charset,boolean)>(v0, v4, v2, v3);
return;
}
public static void write(java.io.File, java.lang.CharSequence, java.lang.String) throws java.io.IOException
{
java.lang.String v2;
java.lang.CharSequence v1;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.CharSequence;
v2 := @parameter2: java.lang.String;
staticinvoke <org.apache.commons.io.FileUtils: void write(java.io.File,java.lang.CharSequence,java.lang.String,boolean)>(v0, v1, v2, 0);
return;
}
public static void write(java.io.File, java.lang.CharSequence, java.lang.String, boolean) throws java.io.IOException
{
java.lang.CharSequence v1;
java.nio.charset.Charset v4;
java.lang.String v2;
java.io.File v0;
boolean v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.CharSequence;
v2 := @parameter2: java.lang.String;
v3 := @parameter3: boolean;
v4 = staticinvoke <org.apache.commons.io.Charsets: java.nio.charset.Charset toCharset(java.lang.String)>(v2);
staticinvoke <org.apache.commons.io.FileUtils: void write(java.io.File,java.lang.CharSequence,java.nio.charset.Charset,boolean)>(v0, v1, v4, v3);
return;
}
public static void writeByteArrayToFile(java.io.File, byte[]) throws java.io.IOException
{
byte[] v1;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 := @parameter1: byte[];
staticinvoke <org.apache.commons.io.FileUtils: void writeByteArrayToFile(java.io.File,byte[],boolean)>(v0, v1, 0);
return;
}
public static void writeByteArrayToFile(java.io.File, byte[], boolean) throws java.io.IOException
{
byte[] v1;
int v3;
java.io.File v0;
boolean v2;
v0 := @parameter0: java.io.File;
v1 := @parameter1: byte[];
v2 := @parameter2: boolean;
v3 = lengthof v1;
staticinvoke <org.apache.commons.io.FileUtils: void writeByteArrayToFile(java.io.File,byte[],int,int,boolean)>(v0, v1, 0, v3, v2);
return;
}
public static void writeByteArrayToFile(java.io.File, byte[], int, int) throws java.io.IOException
{
byte[] v1;
int v2, v3;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 := @parameter1: byte[];
v2 := @parameter2: int;
v3 := @parameter3: int;
staticinvoke <org.apache.commons.io.FileUtils: void writeByteArrayToFile(java.io.File,byte[],int,int,boolean)>(v0, v1, v2, v3, 0);
return;
}
public static void writeByteArrayToFile(java.io.File, byte[], int, int, boolean) throws java.io.IOException
{
java.lang.Throwable v6;
byte[] v1;
int v2, v3;
java.io.FileOutputStream v5;
java.io.File v0;
boolean v4;
v0 := @parameter0: java.io.File;
v1 := @parameter1: byte[];
v2 := @parameter2: int;
v3 := @parameter3: int;
v4 := @parameter4: boolean;
v5 = staticinvoke <org.apache.commons.io.FileUtils: java.io.FileOutputStream openOutputStream(java.io.File,boolean)>(v0, v4);
label1:
virtualinvoke v5.<java.io.OutputStream: void write(byte[],int,int)>(v1, v2, v3);
label2:
virtualinvoke v5.<java.io.OutputStream: void close()>();
goto label4;
label3:
v6 := @caughtexception;
throw v6;
label4:
return;
catch java.lang.Throwable from label1 to label2 with label3;
}
public static void writeLines(java.io.File, java.util.Collection) throws java.io.IOException
{
java.io.File v0;
java.util.Collection v1;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.util.Collection;
staticinvoke <org.apache.commons.io.FileUtils: void writeLines(java.io.File,java.lang.String,java.util.Collection,java.lang.String,boolean)>(v0, null, v1, null, 0);
return;
}
public static void writeLines(java.io.File, java.util.Collection, boolean) throws java.io.IOException
{
java.io.File v0;
boolean v2;
java.util.Collection v1;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.util.Collection;
v2 := @parameter2: boolean;
staticinvoke <org.apache.commons.io.FileUtils: void writeLines(java.io.File,java.lang.String,java.util.Collection,java.lang.String,boolean)>(v0, null, v1, null, v2);
return;
}
public static void writeLines(java.io.File, java.util.Collection, java.lang.String) throws java.io.IOException
{
java.lang.String v2;
java.io.File v0;
java.util.Collection v1;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.util.Collection;
v2 := @parameter2: java.lang.String;
staticinvoke <org.apache.commons.io.FileUtils: void writeLines(java.io.File,java.lang.String,java.util.Collection,java.lang.String,boolean)>(v0, null, v1, v2, 0);
return;
}
public static void writeLines(java.io.File, java.util.Collection, java.lang.String, boolean) throws java.io.IOException
{
java.util.Collection v1;
java.lang.String v2;
java.io.File v0;
boolean v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.util.Collection;
v2 := @parameter2: java.lang.String;
v3 := @parameter3: boolean;
staticinvoke <org.apache.commons.io.FileUtils: void writeLines(java.io.File,java.lang.String,java.util.Collection,java.lang.String,boolean)>(v0, null, v1, v2, v3);
return;
}
public static void writeLines(java.io.File, java.lang.String, java.util.Collection) throws java.io.IOException
{
java.lang.String v1;
java.io.File v0;
java.util.Collection v2;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.util.Collection;
staticinvoke <org.apache.commons.io.FileUtils: void writeLines(java.io.File,java.lang.String,java.util.Collection,java.lang.String,boolean)>(v0, v1, v2, null, 0);
return;
}
public static void writeLines(java.io.File, java.lang.String, java.util.Collection, boolean) throws java.io.IOException
{
java.util.Collection v2;
java.lang.String v1;
java.io.File v0;
boolean v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.util.Collection;
v3 := @parameter3: boolean;
staticinvoke <org.apache.commons.io.FileUtils: void writeLines(java.io.File,java.lang.String,java.util.Collection,java.lang.String,boolean)>(v0, v1, v2, null, v3);
return;
}
public static void writeLines(java.io.File, java.lang.String, java.util.Collection, java.lang.String) throws java.io.IOException
{
java.util.Collection v2;
java.lang.String v1, v3;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.util.Collection;
v3 := @parameter3: java.lang.String;
staticinvoke <org.apache.commons.io.FileUtils: void writeLines(java.io.File,java.lang.String,java.util.Collection,java.lang.String,boolean)>(v0, v1, v2, v3, 0);
return;
}
public static void writeLines(java.io.File, java.lang.String, java.util.Collection, java.lang.String, boolean) throws java.io.IOException
{
java.lang.Throwable v7;
java.util.Collection v2;
java.io.FileOutputStream v6;
java.io.File v0;
java.io.BufferedOutputStream v5;
java.lang.String v1, v3;
boolean v4;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.util.Collection;
v3 := @parameter3: java.lang.String;
v4 := @parameter4: boolean;
v5 = new java.io.BufferedOutputStream;
v6 = staticinvoke <org.apache.commons.io.FileUtils: java.io.FileOutputStream openOutputStream(java.io.File,boolean)>(v0, v4);
specialinvoke v5.<java.io.BufferedOutputStream: void <init>(java.io.OutputStream)>(v6);
label1:
staticinvoke <org.apache.commons.io.IOUtils: void writeLines(java.util.Collection,java.lang.String,java.io.OutputStream,java.lang.String)>(v2, v3, v5, v1);
label2:
virtualinvoke v5.<java.io.OutputStream: void close()>();
goto label4;
label3:
v7 := @caughtexception;
throw v7;
label4:
return;
catch java.lang.Throwable from label1 to label2 with label3;
}
public static void writeStringToFile(java.io.File, java.lang.String) throws java.io.IOException
{
java.lang.String v1;
java.nio.charset.Charset v2;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
v2 = staticinvoke <java.nio.charset.Charset: java.nio.charset.Charset defaultCharset()>();
staticinvoke <org.apache.commons.io.FileUtils: void writeStringToFile(java.io.File,java.lang.String,java.nio.charset.Charset,boolean)>(v0, v1, v2, 0);
return;
}
public static void writeStringToFile(java.io.File, java.lang.String, boolean) throws java.io.IOException
{
java.nio.charset.Charset v3;
java.lang.String v1;
java.io.File v0;
boolean v2;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: boolean;
v3 = staticinvoke <java.nio.charset.Charset: java.nio.charset.Charset defaultCharset()>();
staticinvoke <org.apache.commons.io.FileUtils: void writeStringToFile(java.io.File,java.lang.String,java.nio.charset.Charset,boolean)>(v0, v1, v3, v2);
return;
}
public static void writeStringToFile(java.io.File, java.lang.String, java.nio.charset.Charset) throws java.io.IOException
{
java.lang.String v1;
java.nio.charset.Charset v2;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.nio.charset.Charset;
staticinvoke <org.apache.commons.io.FileUtils: void writeStringToFile(java.io.File,java.lang.String,java.nio.charset.Charset,boolean)>(v0, v1, v2, 0);
return;
}
public static void writeStringToFile(java.io.File, java.lang.String, java.nio.charset.Charset, boolean) throws java.io.IOException
{
java.lang.Throwable v5;
java.nio.charset.Charset v2;
java.io.FileOutputStream v4;
java.lang.String v1;
java.io.File v0;
boolean v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.nio.charset.Charset;
v3 := @parameter3: boolean;
v4 = staticinvoke <org.apache.commons.io.FileUtils: java.io.FileOutputStream openOutputStream(java.io.File,boolean)>(v0, v3);
label1:
staticinvoke <org.apache.commons.io.IOUtils: void write(java.lang.String,java.io.OutputStream,java.nio.charset.Charset)>(v1, v4, v2);
label2:
if v4 == null goto label4;
virtualinvoke v4.<java.io.OutputStream: void close()>();
goto label4;
label3:
v5 := @caughtexception;
throw v5;
label4:
return;
catch java.lang.Throwable from label1 to label2 with label3;
}
public static void writeStringToFile(java.io.File, java.lang.String, java.lang.String) throws java.io.IOException
{
java.lang.String v1, v2;
java.io.File v0;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.lang.String;
staticinvoke <org.apache.commons.io.FileUtils: void writeStringToFile(java.io.File,java.lang.String,java.lang.String,boolean)>(v0, v1, v2, 0);
return;
}
public static void writeStringToFile(java.io.File, java.lang.String, java.lang.String, boolean) throws java.io.IOException
{
java.nio.charset.Charset v4;
java.lang.String v1, v2;
java.io.File v0;
boolean v3;
v0 := @parameter0: java.io.File;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.lang.String;
v3 := @parameter3: boolean;
v4 = staticinvoke <org.apache.commons.io.Charsets: java.nio.charset.Charset toCharset(java.lang.String)>(v2);
staticinvoke <org.apache.commons.io.FileUtils: void writeStringToFile(java.io.File,java.lang.String,java.nio.charset.Charset,boolean)>(v0, v1, v4, v3);
return;
}
public void <init>()
{
org.apache.commons.io.FileUtils v0;
v0 := @this: org.apache.commons.io.FileUtils;
specialinvoke v0.<java.lang.Object: void <init>()>();
return;
}
static void <clinit>()
{
java.math.BigInteger v0, v1, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v2, v20, v21, v3, v4, v5, v6, v7, v8, v9;
java.io.File[] v22;
v0 = staticinvoke <java.math.BigInteger: java.math.BigInteger valueOf(long)>(1024L);
<org.apache.commons.io.FileUtils: java.math.BigInteger ONE_KB_BI> = v0;
v1 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_KB_BI>;
v2 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_KB_BI>;
v3 = virtualinvoke v1.<java.math.BigInteger: java.math.BigInteger multiply(java.math.BigInteger)>(v2);
<org.apache.commons.io.FileUtils: java.math.BigInteger ONE_MB_BI> = v3;
v4 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_KB_BI>;
v5 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_MB_BI>;
v6 = virtualinvoke v4.<java.math.BigInteger: java.math.BigInteger multiply(java.math.BigInteger)>(v5);
<org.apache.commons.io.FileUtils: java.math.BigInteger ONE_GB_BI> = v6;
v7 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_KB_BI>;
v8 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_GB_BI>;
v9 = virtualinvoke v7.<java.math.BigInteger: java.math.BigInteger multiply(java.math.BigInteger)>(v8);
<org.apache.commons.io.FileUtils: java.math.BigInteger ONE_TB_BI> = v9;
v10 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_KB_BI>;
v11 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_TB_BI>;
v12 = virtualinvoke v10.<java.math.BigInteger: java.math.BigInteger multiply(java.math.BigInteger)>(v11);
<org.apache.commons.io.FileUtils: java.math.BigInteger ONE_PB_BI> = v12;
v13 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_KB_BI>;
v14 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_PB_BI>;
v15 = virtualinvoke v13.<java.math.BigInteger: java.math.BigInteger multiply(java.math.BigInteger)>(v14);
<org.apache.commons.io.FileUtils: java.math.BigInteger ONE_EB_BI> = v15;
v16 = staticinvoke <java.math.BigInteger: java.math.BigInteger valueOf(long)>(1024L);
v17 = staticinvoke <java.math.BigInteger: java.math.BigInteger valueOf(long)>(1152921504606846976L);
v18 = virtualinvoke v16.<java.math.BigInteger: java.math.BigInteger multiply(java.math.BigInteger)>(v17);
<org.apache.commons.io.FileUtils: java.math.BigInteger ONE_ZB> = v18;
v19 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_KB_BI>;
v20 = <org.apache.commons.io.FileUtils: java.math.BigInteger ONE_ZB>;
v21 = virtualinvoke v19.<java.math.BigInteger: java.math.BigInteger multiply(java.math.BigInteger)>(v20);
<org.apache.commons.io.FileUtils: java.math.BigInteger ONE_YB> = v21;
v22 = newarray (java.io.File)[0];
<org.apache.commons.io.FileUtils: java.io.File[] EMPTY_FILE_ARRAY> = v22;
return;
}
}