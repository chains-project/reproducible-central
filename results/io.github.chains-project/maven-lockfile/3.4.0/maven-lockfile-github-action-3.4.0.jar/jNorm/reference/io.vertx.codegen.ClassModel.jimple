public class io.vertx.codegen.ClassModel extends java.lang.Object implements io.vertx.codegen.Model
{
public static final java.lang.String VERTX_READ_STREAM;
public static final java.lang.String VERTX_WRITE_STREAM;
public static final java.lang.String VERTX_ASYNC_RESULT;
public static final java.lang.String VERTX_HANDLER;
public static final java.lang.String JSON_OBJECT;
public static final java.lang.String JSON_ARRAY;
public static final java.lang.String VERTX;
public static final java.lang.String ITERABLE;
public static final java.lang.String ITERATOR;
public static final java.lang.String FUNCTION;
private static final java.util.logging.Logger logger;
private static final io.vertx.codegen.type.ClassTypeInfo ASYNC_RESULT_TYPE;
private static final io.vertx.codegen.type.ClassTypeInfo HANDLER_TYPE;
protected final javax.'annotation'.processing.ProcessingEnvironment env;
protected final io.vertx.codegen.type.AnnotationValueInfoFactory annotationValueInfoFactory;
protected final javax.'annotation'.processing.Messager messager;
protected final io.vertx.codegen.type.TypeMirrorFactory typeFactory;
protected final io.vertx.codegen.doc.Doc$Factory docFactory;
protected final javax.lang.model.element.TypeElement modelElt;
protected final javax.lang.model.util.Elements elementUtils;
protected final javax.lang.model.util.Types typeUtils;
protected boolean processed;
protected java.util.LinkedHashMap methods;
protected java.util.LinkedHashMap anyJavaTypeMethods;
protected java.util.Set futureMethods;
protected java.util.List constants;
protected java.util.Set collectedTypes;
protected java.util.Set importedTypes;
protected java.util.Set referencedTypes;
protected java.util.Set referencedDataObjectTypes;
protected java.util.Set referencedEnumTypes;
protected boolean concrete;
protected io.vertx.codegen.type.ClassTypeInfo type;
protected java.lang.String ifaceSimpleName;
protected java.lang.String ifaceFQCN;
protected java.lang.String ifacePackageName;
protected java.lang.String ifaceComment;
protected io.vertx.codegen.doc.Doc doc;
protected java.util.List superTypes;
protected io.vertx.codegen.type.TypeInfo concreteSuperType;
private java.util.List superTypeArguments;
protected java.util.List abstractSuperTypes;
protected io.vertx.codegen.type.TypeInfo handlerArg;
protected io.vertx.codegen.type.TypeInfo readStreamArg;
protected io.vertx.codegen.type.TypeInfo writeStreamArg;
protected io.vertx.codegen.type.TypeInfo iterableArg;
protected io.vertx.codegen.type.TypeInfo iteratorArg;
protected io.vertx.codegen.type.TypeInfo[] functionArgs;
protected java.util.Map methodMap;
protected java.util.Map methodAnnotationsMap;
protected java.util.List annotations;
protected boolean deprecated;
protected io.vertx.codegen.doc.Text deprecatedDesc;
public void <init>(javax.'annotation'.processing.ProcessingEnvironment, io.vertx.codegen.type.TypeMirrorFactory, javax.lang.model.element.TypeElement)
{
javax.lang.model.element.TypeElement v3;
javax.lang.model.util.Elements v16, v20;
java.util.ArrayList v13, v14, v7;
java.util.HashSet v10, v11, v12, v6, v8, v9;
java.util.LinkedHashMap v15, v4, v5;
io.vertx.codegen.type.AnnotationValueInfoFactory v23;
io.vertx.codegen.doc.Doc$Factory v18;
javax.'annotation'.processing.Messager v19, v22;
boolean v25;
io.vertx.codegen.type.TypeMirrorFactory v2;
javax.lang.model.util.Types v17, v21;
io.vertx.codegen.ClassModel v0;
java.lang.'annotation'.Annotation v24;
javax.'annotation'.processing.ProcessingEnvironment v1;
v0 := @this: io.vertx.codegen.ClassModel;
v1 := @parameter0: javax.'annotation'.processing.ProcessingEnvironment;
v2 := @parameter1: io.vertx.codegen.type.TypeMirrorFactory;
v3 := @parameter2: javax.lang.model.element.TypeElement;
specialinvoke v0.<java.lang.Object: void <init>()>();
v0.<io.vertx.codegen.ClassModel: boolean processed> = 0;
v4 = new java.util.LinkedHashMap;
specialinvoke v4.<java.util.LinkedHashMap: void <init>()>();
v0.<io.vertx.codegen.ClassModel: java.util.LinkedHashMap methods> = v4;
v5 = new java.util.LinkedHashMap;
specialinvoke v5.<java.util.LinkedHashMap: void <init>()>();
v0.<io.vertx.codegen.ClassModel: java.util.LinkedHashMap anyJavaTypeMethods> = v5;
v6 = new java.util.HashSet;
specialinvoke v6.<java.util.HashSet: void <init>()>();
v0.<io.vertx.codegen.ClassModel: java.util.Set futureMethods> = v6;
v7 = new java.util.ArrayList;
specialinvoke v7.<java.util.ArrayList: void <init>()>();
v0.<io.vertx.codegen.ClassModel: java.util.List constants> = v7;
v8 = new java.util.HashSet;
specialinvoke v8.<java.util.HashSet: void <init>()>();
v0.<io.vertx.codegen.ClassModel: java.util.Set collectedTypes> = v8;
v9 = new java.util.HashSet;
specialinvoke v9.<java.util.HashSet: void <init>()>();
v0.<io.vertx.codegen.ClassModel: java.util.Set importedTypes> = v9;
v10 = new java.util.HashSet;
specialinvoke v10.<java.util.HashSet: void <init>()>();
v0.<io.vertx.codegen.ClassModel: java.util.Set referencedTypes> = v10;
v11 = new java.util.HashSet;
specialinvoke v11.<java.util.HashSet: void <init>()>();
v0.<io.vertx.codegen.ClassModel: java.util.Set referencedDataObjectTypes> = v11;
v12 = new java.util.HashSet;
specialinvoke v12.<java.util.HashSet: void <init>()>();
v0.<io.vertx.codegen.ClassModel: java.util.Set referencedEnumTypes> = v12;
v13 = new java.util.ArrayList;
specialinvoke v13.<java.util.ArrayList: void <init>()>();
v0.<io.vertx.codegen.ClassModel: java.util.List superTypes> = v13;
v14 = new java.util.ArrayList;
specialinvoke v14.<java.util.ArrayList: void <init>()>();
v0.<io.vertx.codegen.ClassModel: java.util.List abstractSuperTypes> = v14;
v15 = new java.util.LinkedHashMap;
specialinvoke v15.<java.util.LinkedHashMap: void <init>()>();
v0.<io.vertx.codegen.ClassModel: java.util.Map methodAnnotationsMap> = v15;
v16 = interfaceinvoke v1.<javax.'annotation'.processing.ProcessingEnvironment: javax.lang.model.util.Elements getElementUtils()>();
v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Elements elementUtils> = v16;
v17 = interfaceinvoke v1.<javax.'annotation'.processing.ProcessingEnvironment: javax.lang.model.util.Types getTypeUtils()>();
v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Types typeUtils> = v17;
v0.<io.vertx.codegen.ClassModel: javax.'annotation'.processing.ProcessingEnvironment env> = v1;
v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeMirrorFactory typeFactory> = v2;
v18 = new io.vertx.codegen.doc.Doc$Factory;
v19 = interfaceinvoke v1.<javax.'annotation'.processing.ProcessingEnvironment: javax.'annotation'.processing.Messager getMessager()>();
v20 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Elements elementUtils>;
v21 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Types typeUtils>;
specialinvoke v18.<io.vertx.codegen.doc.Doc$Factory: void <init>(javax.'annotation'.processing.Messager,javax.lang.model.util.Elements,javax.lang.model.util.Types,io.vertx.codegen.type.TypeMirrorFactory,javax.lang.model.element.TypeElement)>(v19, v20, v21, v2, v3);
v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.doc.Doc$Factory docFactory> = v18;
v22 = interfaceinvoke v1.<javax.'annotation'.processing.ProcessingEnvironment: javax.'annotation'.processing.Messager getMessager()>();
v0.<io.vertx.codegen.ClassModel: javax.'annotation'.processing.Messager messager> = v22;
v0.<io.vertx.codegen.ClassModel: javax.lang.model.element.TypeElement modelElt> = v3;
v23 = new io.vertx.codegen.type.AnnotationValueInfoFactory;
specialinvoke v23.<io.vertx.codegen.type.AnnotationValueInfoFactory: void <init>(io.vertx.codegen.type.TypeMirrorFactory)>(v2);
v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.AnnotationValueInfoFactory annotationValueInfoFactory> = v23;
v24 = interfaceinvoke v3.<javax.lang.model.element.TypeElement: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Ljava/lang/Deprecated;");
if v24 == null goto label1;
v25 = 1;
goto label2;
label1:
v25 = 0;
label2:
v0.<io.vertx.codegen.ClassModel: boolean deprecated> = v25;
return;
}
public java.lang.String getKind()
{
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
return "class";
}
public java.lang.String getFqn()
{
io.vertx.codegen.type.ClassTypeInfo v1, v2;
java.lang.String v3;
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.ClassTypeInfo type>;
v2 = virtualinvoke v1.<io.vertx.codegen.type.ClassTypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v3 = virtualinvoke v2.<io.vertx.codegen.type.ClassTypeInfo: java.lang.String getName()>();
return v3;
}
public javax.lang.model.element.TypeElement getElement()
{
javax.lang.model.element.TypeElement v1;
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.element.TypeElement modelElt>;
return v1;
}
public java.util.List getMethods()
{
java.util.LinkedHashMap v2;
java.util.Collection v3;
io.vertx.codegen.ClassModel v0;
java.util.ArrayList v1;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = new java.util.ArrayList;
v2 = v0.<io.vertx.codegen.ClassModel: java.util.LinkedHashMap methods>;
v3 = virtualinvoke v2.<java.util.LinkedHashMap: java.util.Collection values()>();
specialinvoke v1.<java.util.ArrayList: void <init>(java.util.Collection)>(v3);
return v1;
}
public java.util.List getAnyJavaTypeMethods()
{
java.util.LinkedHashMap v2;
java.util.Collection v3;
io.vertx.codegen.ClassModel v0;
java.util.ArrayList v1;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = new java.util.ArrayList;
v2 = v0.<io.vertx.codegen.ClassModel: java.util.LinkedHashMap anyJavaTypeMethods>;
v3 = virtualinvoke v2.<java.util.LinkedHashMap: java.util.Collection values()>();
specialinvoke v1.<java.util.ArrayList: void <init>(java.util.Collection)>(v3);
return v1;
}
public java.util.List getStaticMethods()
{
java.util.function.Predicate v4;
java.util.Collection v2;
io.vertx.codegen.ClassModel v0;
java.util.LinkedHashMap v1;
java.util.stream.Stream v3, v5;
java.lang.Object v7;
java.util.stream.Collector v6;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: java.util.LinkedHashMap methods>;
v2 = virtualinvoke v1.<java.util.LinkedHashMap: java.util.Collection values()>();
v3 = interfaceinvoke v2.<java.util.Collection: java.util.stream.Stream stream()>();
v4 = staticinvoke <io.vertx.codegen.ClassModel$isStaticMethod__2468: java.util.function.Predicate bootstrap$()>();
v5 = interfaceinvoke v3.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v4);
v6 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector toList()>();
v7 = interfaceinvoke v5.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v6);
return v7;
}
public java.util.List getInstanceMethods()
{
java.util.function.Predicate v4;
java.util.Collection v2;
io.vertx.codegen.ClassModel v0;
java.util.LinkedHashMap v1;
java.util.stream.Stream v3, v5;
java.lang.Object v7;
java.util.stream.Collector v6;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: java.util.LinkedHashMap methods>;
v2 = virtualinvoke v1.<java.util.LinkedHashMap: java.util.Collection values()>();
v3 = interfaceinvoke v2.<java.util.Collection: java.util.stream.Stream stream()>();
v4 = staticinvoke <io.vertx.codegen.ClassModel$lambda_getInstanceMethods_0__2469: java.util.function.Predicate bootstrap$()>();
v5 = interfaceinvoke v3.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v4);
v6 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector toList()>();
v7 = interfaceinvoke v5.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v6);
return v7;
}
public java.util.List getConstants()
{
java.util.List v1;
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: java.util.List constants>;
return v1;
}
public boolean isConcrete()
{
io.vertx.codegen.ClassModel v0;
boolean v1;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: boolean concrete>;
return v1;
}
public java.util.Set getImportedTypes()
{
java.util.Set v1;
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: java.util.Set importedTypes>;
return v1;
}
public java.util.Set getReferencedTypes()
{
java.util.Set v1;
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: java.util.Set referencedTypes>;
return v1;
}
public java.util.Set getReferencedDataObjectTypes()
{
java.util.Set v1;
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: java.util.Set referencedDataObjectTypes>;
return v1;
}
public java.util.Set getReferencedEnumTypes()
{
java.util.Set v1;
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: java.util.Set referencedEnumTypes>;
return v1;
}
public java.lang.String getIfaceSimpleName()
{
java.lang.String v1;
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: java.lang.String ifaceSimpleName>;
return v1;
}
public java.lang.String getIfaceFQCN()
{
java.lang.String v1;
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: java.lang.String ifaceFQCN>;
return v1;
}
public java.lang.String getIfacePackageName()
{
java.lang.String v1;
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: java.lang.String ifacePackageName>;
return v1;
}
public java.lang.String getIfaceComment()
{
java.lang.String v1;
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: java.lang.String ifaceComment>;
return v1;
}
public io.vertx.codegen.doc.Doc getDoc()
{
io.vertx.codegen.doc.Doc v1;
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.doc.Doc doc>;
return v1;
}
public io.vertx.codegen.type.ClassTypeInfo getType()
{
io.vertx.codegen.type.ClassTypeInfo v1;
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.ClassTypeInfo type>;
return v1;
}
public io.vertx.codegen.ModuleInfo getModule()
{
io.vertx.codegen.type.ClassTypeInfo v1, v2;
io.vertx.codegen.ModuleInfo v3;
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.ClassTypeInfo type>;
v2 = virtualinvoke v1.<io.vertx.codegen.type.ClassTypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v3 = virtualinvoke v2.<io.vertx.codegen.type.ClassTypeInfo: io.vertx.codegen.ModuleInfo getModule()>();
return v3;
}
public java.util.List getSuperTypes()
{
java.util.List v1;
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: java.util.List superTypes>;
return v1;
}
public io.vertx.codegen.type.TypeInfo getConcreteSuperType()
{
io.vertx.codegen.ClassModel v0;
io.vertx.codegen.type.TypeInfo v1;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo concreteSuperType>;
return v1;
}
public java.util.List getAbstractSuperTypes()
{
java.util.List v1;
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: java.util.List abstractSuperTypes>;
return v1;
}
public java.util.Map getMethodMap()
{
io.vertx.codegen.ClassModel v0;
java.util.Map v1;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: java.util.Map methodMap>;
return v1;
}
public java.util.List getTypeParams()
{
io.vertx.codegen.type.ClassTypeInfo v1, v2;
java.util.List v3;
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.ClassTypeInfo type>;
v2 = virtualinvoke v1.<io.vertx.codegen.type.ClassTypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v3 = virtualinvoke v2.<io.vertx.codegen.type.ClassTypeInfo: java.util.List getParams()>();
return v3;
}
public java.util.List getSuperTypeArguments()
{
java.util.List v1;
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: java.util.List superTypeArguments>;
return v1;
}
public java.util.List getAnnotations()
{
java.util.List v1;
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: java.util.List annotations>;
return v1;
}
public java.util.Map getMethodAnnotations()
{
io.vertx.codegen.ClassModel v0;
java.util.Map v1;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: java.util.Map methodAnnotationsMap>;
return v1;
}
private void sortMethodMap(java.util.Map)
{
java.util.Iterator v3;
java.util.Collection v2;
java.util.function.ToIntFunction v6;
io.vertx.codegen.ClassModel v0;
java.util.Map v1;
java.lang.Object v5;
java.util.Comparator v7;
boolean v4;
v0 := @this: io.vertx.codegen.ClassModel;
v1 := @parameter0: java.util.Map;
v2 = interfaceinvoke v1.<java.util.Map: java.util.Collection values()>();
v3 = interfaceinvoke v2.<java.util.Collection: java.util.Iterator iterator()>();
label1:
v4 = interfaceinvoke v3.<java.util.Iterator: boolean hasNext()>();
if v4 == 0 goto label2;
v5 = interfaceinvoke v3.<java.util.Iterator: java.lang.Object next()>();
v6 = staticinvoke <io.vertx.codegen.ClassModel$lambda_sortMethodMap_1__2470: java.util.function.ToIntFunction bootstrap$()>();
v7 = staticinvoke <java.util.Comparator: java.util.Comparator comparingInt(java.util.function.ToIntFunction)>(v6);
interfaceinvoke v5.<java.util.List: void sort(java.util.Comparator)>(v7);
goto label1;
label2:
return;
}
private void determineApiTypes()
{
java.util.stream.Collector v19, v27, v37, v9;
java.util.function.Predicate v17, v25, v35, v7;
java.util.Set v1, v11, v21, v29;
io.vertx.codegen.ClassModel v0;
java.util.stream.Stream v12, v14, v16, v18, v2, v22, v24, v26, v30, v32, v34, v36, v4, v6, v8;
java.util.function.Function v13, v15, v23, v3, v31, v33, v5;
java.lang.Object v10, v20, v28, v38;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: java.util.Set collectedTypes>;
v2 = interfaceinvoke v1.<java.util.Set: java.util.stream.Stream stream()>();
v3 = staticinvoke <io.vertx.codegen.ClassModel$getRaw__2471: java.util.function.Function bootstrap$()>();
v4 = interfaceinvoke v2.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v3);
v5 = staticinvoke <io.vertx.codegen.Helper: java.util.function.Function instanceOf(java.lang.Class)>(class "Lio/vertx/codegen/type/ClassTypeInfo;");
v6 = interfaceinvoke v4.<java.util.stream.Stream: java.util.stream.Stream flatMap(java.util.function.Function)>(v5);
v7 = staticinvoke <io.vertx.codegen.ClassModel$lambda_determineApiTypes_2__2472: java.util.function.Predicate bootstrap$(io.vertx.codegen.ClassModel)>(v0);
v8 = interfaceinvoke v6.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v7);
v9 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector toSet()>();
v10 = interfaceinvoke v8.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v9);
v0.<io.vertx.codegen.ClassModel: java.util.Set importedTypes> = v10;
v11 = v0.<io.vertx.codegen.ClassModel: java.util.Set collectedTypes>;
v12 = interfaceinvoke v11.<java.util.Set: java.util.stream.Stream stream()>();
v13 = staticinvoke <io.vertx.codegen.ClassModel$getRaw__2473: java.util.function.Function bootstrap$()>();
v14 = interfaceinvoke v12.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v13);
v15 = staticinvoke <io.vertx.codegen.Helper: java.util.function.Function instanceOf(java.lang.Class)>(class "Lio/vertx/codegen/type/ApiTypeInfo;");
v16 = interfaceinvoke v14.<java.util.stream.Stream: java.util.stream.Stream flatMap(java.util.function.Function)>(v15);
v17 = staticinvoke <io.vertx.codegen.ClassModel$lambda_determineApiTypes_3__2474: java.util.function.Predicate bootstrap$(io.vertx.codegen.ClassModel)>(v0);
v18 = interfaceinvoke v16.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v17);
v19 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector toSet()>();
v20 = interfaceinvoke v18.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v19);
v0.<io.vertx.codegen.ClassModel: java.util.Set referencedTypes> = v20;
v21 = v0.<io.vertx.codegen.ClassModel: java.util.Set collectedTypes>;
v22 = interfaceinvoke v21.<java.util.Set: java.util.stream.Stream stream()>();
v23 = staticinvoke <io.vertx.codegen.ClassModel$getRaw__2475: java.util.function.Function bootstrap$()>();
v24 = interfaceinvoke v22.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v23);
v25 = staticinvoke <io.vertx.codegen.ClassModel$isDataObjectHolder__2476: java.util.function.Predicate bootstrap$()>();
v26 = interfaceinvoke v24.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v25);
v27 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector toSet()>();
v28 = interfaceinvoke v26.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v27);
v0.<io.vertx.codegen.ClassModel: java.util.Set referencedDataObjectTypes> = v28;
v29 = v0.<io.vertx.codegen.ClassModel: java.util.Set collectedTypes>;
v30 = interfaceinvoke v29.<java.util.Set: java.util.stream.Stream stream()>();
v31 = staticinvoke <io.vertx.codegen.ClassModel$getRaw__2477: java.util.function.Function bootstrap$()>();
v32 = interfaceinvoke v30.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v31);
v33 = staticinvoke <io.vertx.codegen.Helper: java.util.function.Function instanceOf(java.lang.Class)>(class "Lio/vertx/codegen/type/EnumTypeInfo;");
v34 = interfaceinvoke v32.<java.util.stream.Stream: java.util.stream.Stream flatMap(java.util.function.Function)>(v33);
v35 = staticinvoke <io.vertx.codegen.ClassModel$lambda_determineApiTypes_4__2478: java.util.function.Predicate bootstrap$()>();
v36 = interfaceinvoke v34.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v35);
v37 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector toSet()>();
v38 = interfaceinvoke v36.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v37);
v0.<io.vertx.codegen.ClassModel: java.util.Set referencedEnumTypes> = v38;
return;
}
public boolean process()
{
javax.lang.model.element.TypeElement v2;
io.vertx.codegen.ClassModel v0;
boolean v1;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: boolean processed>;
if v1 != 0 goto label1;
v2 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.element.TypeElement modelElt>;
specialinvoke v0.<io.vertx.codegen.ClassModel: void traverseType(javax.lang.model.element.Element)>(v2);
specialinvoke v0.<io.vertx.codegen.ClassModel: void determineApiTypes()>();
specialinvoke v0.<io.vertx.codegen.ClassModel: void processTypeAnnotations()>();
specialinvoke v0.<io.vertx.codegen.ClassModel: void logNonFutures()>();
v0.<io.vertx.codegen.ClassModel: boolean processed> = 1;
return 1;
label1:
return 0;
}
private void logNonFutures()
{
java.util.function.Predicate v4, v6;
java.util.Collection v2;
io.vertx.codegen.ClassModel v0;
java.util.LinkedHashMap v1;
java.util.function.Consumer v8;
java.util.stream.Stream v3, v5, v7;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: java.util.LinkedHashMap methods>;
v2 = virtualinvoke v1.<java.util.LinkedHashMap: java.util.Collection values()>();
v3 = interfaceinvoke v2.<java.util.Collection: java.util.stream.Stream stream()>();
v4 = staticinvoke <io.vertx.codegen.ClassModel$lambda_logNonFutures_5__2479: java.util.function.Predicate bootstrap$()>();
v5 = interfaceinvoke v3.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v4);
v6 = staticinvoke <io.vertx.codegen.ClassModel$lambda_logNonFutures_6__2480: java.util.function.Predicate bootstrap$(io.vertx.codegen.ClassModel)>(v0);
v7 = interfaceinvoke v5.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v6);
v8 = staticinvoke <io.vertx.codegen.ClassModel$lambda_logNonFutures_7__2481: java.util.function.Consumer bootstrap$(io.vertx.codegen.ClassModel)>(v0);
interfaceinvoke v7.<java.util.stream.Stream: void forEach(java.util.function.Consumer)>(v8);
return;
}
private void processTypeAnnotations()
{
javax.lang.model.element.TypeElement v2;
java.util.function.Function v6;
javax.lang.model.util.Elements v1;
io.vertx.codegen.ClassModel v0;
java.util.List v3;
java.util.stream.Stream v4, v7;
io.vertx.codegen.type.AnnotationValueInfoFactory v5;
java.lang.Object v9;
java.util.stream.Collector v8;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Elements elementUtils>;
v2 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.element.TypeElement modelElt>;
v3 = interfaceinvoke v1.<javax.lang.model.util.Elements: java.util.List getAllAnnotationMirrors(javax.lang.model.element.Element)>(v2);
v4 = interfaceinvoke v3.<java.util.List: java.util.stream.Stream stream()>();
v5 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.AnnotationValueInfoFactory annotationValueInfoFactory>;
virtualinvoke v5.<java.lang.Object: java.lang.Class getClass()>();
v6 = staticinvoke <io.vertx.codegen.ClassModel$processAnnotation__2482: java.util.function.Function bootstrap$(io.vertx.codegen.type.AnnotationValueInfoFactory)>(v5);
v7 = interfaceinvoke v4.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v6);
v8 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector toList()>();
v9 = interfaceinvoke v7.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v8);
v0.<io.vertx.codegen.ClassModel: java.util.List annotations> = v9;
return;
}
private void traverseType(javax.lang.model.element.Element)
{
javax.lang.model.util.Elements v128, v131, v139, v18, v22;
java.util.Map v217, v218;
java.util.stream.Collector v215;
javax.lang.model.element.Element v1, v93;
java.util.stream.Stream v133, v135, v137, v141, v143, v145, v194, v196, v198, v205, v208, v209, v213, v29, v31;
io.vertx.codegen.Signature v191;
javax.lang.model.element.PackageElement v19;
java.util.LinkedHashMap v148, v149, v203, v206, v211;
io.vertx.codegen.type.ParameterizedTypeInfo v185, v187;
io.vertx.codegen.type.ClassTypeInfo v14, v166, v178, v186, v188, v69, v97;
io.vertx.codegen.ParamInfo v183;
int[] v119, v3, v63;
io.vertx.codegen.type.ClassKind v163, v164, v64;
java.util.LinkedHashMap[] v147;
io.vertx.codegen.type.TypeInfo v107, v108, v109, v110, v111, v112, v13, v162, v170, v176, v181, v59, v68, v72, v81, v82, v96;
java.util.Collection v193, v212, v219;
io.vertx.codegen.ClassModel v0;
javax.lang.model.type.TypeKind v91, v92;
java.lang.'annotation'.Annotation v37, v38;
java.util.function.Function v136, v144, v214;
int v102, v103, v121, v122, v160, v169, v184, v5, v6, v65, v66;
java.util.function.Consumer v138, v146, v210, v223, v33;
javax.lang.model.type.TypeMirror v130, v2, v233, v234, v44, v47, v85;
java.lang.Class v55;
java.lang.Object v105, v117, v153, v157, v158, v172, v202, v216, v222, v224, v227, v53, v90;
javax.lang.model.element.TypeElement v129, v84;
io.vertx.codegen.type.TypeMirrorFactory v106, v12, v58, v67;
java.util.Set v154, v165, v168, v201, v204, v207, v80;
java.lang.Exception v77;
io.vertx.codegen.doc.Doc v25, v26, v27;
java.util.ArrayList v100, v182;
io.vertx.codegen.GenException v11, v123, v171, v230, v46, v61, v7, v73, v74, v78;
io.vertx.codegen.type.TypeInfo[] v113;
java.lang.String v10, v124, v125, v15, v17, v173, v174, v175, v179, v192, v21, v23, v231, v232, v48, v54, v56, v62, v79, v8, v9, v95, v98;
io.vertx.codegen.doc.Doc$Factory v24;
io.vertx.codegen.doc.Text v35;
boolean v116, v118, v152, v156, v161, v167, v177, v180, v200, v221, v226, v228, v229, v34, v36, v39, v40, v43, v45, v52, v57, v70, v71, v83, v89, v99;
java.util.function.Predicate v134, v142, v195, v197, v30;
javax.lang.model.util.Types v49, v86;
java.util.List v101, v104, v114, v132, v140, v150, v159, v189, v190, v28, v41, v50, v75, v76, v87;
java.util.Optional v199, v32;
javax.lang.model.element.Name v16, v20, v94;
java.util.Iterator v115, v151, v155, v220, v225, v42, v51, v88;
javax.lang.model.element.ElementKind v120, v126, v127, v4;
java.lang.IllegalArgumentException v60;
v0 := @this: io.vertx.codegen.ClassModel;
v1 := @parameter0: javax.lang.model.element.Element;
v2 = interfaceinvoke v1.<javax.lang.model.element.Element: javax.lang.model.type.TypeMirror asType()>();
v3 = <io.vertx.codegen.ClassModel$1: int[] $SwitchMap$javax$lang$model$element$ElementKind>;
v4 = interfaceinvoke v1.<javax.lang.model.element.Element: javax.lang.model.element.ElementKind getKind()>();
v5 = virtualinvoke v4.<javax.lang.model.element.ElementKind: int ordinal()>();
v6 = v3[v5];
tableswitch(v6)
{
case 1: goto label01;
case 2: goto label01;
case 3: goto label02;
default: goto label30;
};
label01:
v7 = new io.vertx.codegen.GenException;
v8 = virtualinvoke v2.<java.lang.Object: java.lang.String toString()>();
v9 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v8) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("@VertxGen can only be used with interfaces or enums in \u0001");
specialinvoke v7.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v1, v9);
throw v7;
label02:
v10 = v0.<io.vertx.codegen.ClassModel: java.lang.String ifaceFQCN>;
if v10 == null goto label03;
v11 = new io.vertx.codegen.GenException;
specialinvoke v11.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v1, "Can only have one interface per file");
throw v11;
label03:
v12 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeMirrorFactory typeFactory>;
v13 = virtualinvoke v12.<io.vertx.codegen.type.TypeMirrorFactory: io.vertx.codegen.type.TypeInfo create(javax.lang.model.type.DeclaredType)>(v2);
v14 = virtualinvoke v13.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.ClassTypeInfo type> = v14;
staticinvoke <io.vertx.codegen.Helper: void checkUnderModule(io.vertx.codegen.Model,java.lang.String)>(v0, "@VertxGen");
v15 = virtualinvoke v2.<java.lang.Object: java.lang.String toString()>();
v0.<io.vertx.codegen.ClassModel: java.lang.String ifaceFQCN> = v15;
v16 = interfaceinvoke v1.<javax.lang.model.element.Element: javax.lang.model.element.Name getSimpleName()>();
v17 = virtualinvoke v16.<java.lang.Object: java.lang.String toString()>();
v0.<io.vertx.codegen.ClassModel: java.lang.String ifaceSimpleName> = v17;
v18 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Elements elementUtils>;
v19 = interfaceinvoke v18.<javax.lang.model.util.Elements: javax.lang.model.element.PackageElement getPackageOf(javax.lang.model.element.Element)>(v1);
v20 = interfaceinvoke v19.<javax.lang.model.element.PackageElement: javax.lang.model.element.Name getQualifiedName()>();
v21 = virtualinvoke v20.<java.lang.Object: java.lang.String toString()>();
v0.<io.vertx.codegen.ClassModel: java.lang.String ifacePackageName> = v21;
v22 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Elements elementUtils>;
v23 = interfaceinvoke v22.<javax.lang.model.util.Elements: java.lang.String getDocComment(javax.lang.model.element.Element)>(v1);
v0.<io.vertx.codegen.ClassModel: java.lang.String ifaceComment> = v23;
v24 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.doc.Doc$Factory docFactory>;
v25 = virtualinvoke v24.<io.vertx.codegen.doc.Doc$Factory: io.vertx.codegen.doc.Doc createDoc(javax.lang.model.element.Element)>(v1);
v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.doc.Doc doc> = v25;
v26 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.doc.Doc doc>;
if v26 == null goto label04;
v27 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.doc.Doc doc>;
v28 = virtualinvoke v27.<io.vertx.codegen.doc.Doc: java.util.List getBlockTags()>();
v29 = interfaceinvoke v28.<java.util.List: java.util.stream.Stream stream()>();
v30 = staticinvoke <io.vertx.codegen.ClassModel$lambda_traverseType_8__2492: java.util.function.Predicate bootstrap$()>();
v31 = interfaceinvoke v29.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v30);
v32 = interfaceinvoke v31.<java.util.stream.Stream: java.util.Optional findFirst()>();
v33 = staticinvoke <io.vertx.codegen.ClassModel$lambda_traverseType_9__2493: java.util.function.Consumer bootstrap$(io.vertx.codegen.ClassModel)>(v0);
virtualinvoke v32.<java.util.Optional: void ifPresent(java.util.function.Consumer)>(v33);
label04:
v34 = v0.<io.vertx.codegen.ClassModel: boolean deprecated>;
if v34 != 0 goto label05;
v35 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.doc.Text deprecatedDesc>;
if v35 == null goto label06;
label05:
v36 = 1;
goto label07;
label06:
v36 = 0;
label07:
v0.<io.vertx.codegen.ClassModel: boolean deprecated> = v36;
v37 = interfaceinvoke v1.<javax.lang.model.element.Element: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Lio/vertx/codegen/annotations/VertxGen;");
if v37 == null goto label08;
v38 = interfaceinvoke v1.<javax.lang.model.element.Element: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Lio/vertx/codegen/annotations/VertxGen;");
v39 = interfaceinvoke v38.<io.vertx.codegen.annotations.VertxGen: boolean concrete()>();
if v39 == 0 goto label09;
label08:
v40 = 1;
goto label10;
label09:
v40 = 0;
label10:
v0.<io.vertx.codegen.ClassModel: boolean concrete> = v40;
v41 = interfaceinvoke v2.<javax.lang.model.type.DeclaredType: java.util.List getTypeArguments()>();
v42 = interfaceinvoke v41.<java.util.List: java.util.Iterator iterator()>();
label11:
v43 = interfaceinvoke v42.<java.util.Iterator: boolean hasNext()>();
if v43 == 0 goto label12;
interfaceinvoke v42.<java.util.Iterator: java.lang.Object next()>();
v44 = interfaceinvoke v233.<javax.lang.model.type.TypeVariable: javax.lang.model.type.TypeMirror getUpperBound()>();
v45 = specialinvoke v0.<io.vertx.codegen.ClassModel: boolean isObjectBound(javax.lang.model.type.TypeMirror)>(v44);
if v45 != 0 goto label11;
v46 = new io.vertx.codegen.GenException;
v47 = interfaceinvoke v233.<javax.lang.model.type.TypeVariable: javax.lang.model.type.TypeMirror getUpperBound()>();
v48 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (javax.lang.model.type.TypeMirror)>(v47) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Type variable bounds not supported \u0001");
specialinvoke v46.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v1, v48);
throw v46;
label12:
v49 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Types typeUtils>;
v50 = interfaceinvoke v49.<javax.lang.model.util.Types: java.util.List directSupertypes(javax.lang.model.type.TypeMirror)>(v2);
v51 = interfaceinvoke v50.<java.util.List: java.util.Iterator iterator()>();
label13:
v52 = interfaceinvoke v51.<java.util.Iterator: boolean hasNext()>();
if v52 == 0 goto label26;
v53 = interfaceinvoke v51.<java.util.Iterator: java.lang.Object next()>();
v54 = interfaceinvoke v53.<javax.lang.model.type.TypeMirror: java.lang.String toString()>();
v55 = class "Ljava/lang/Object;";
v56 = virtualinvoke v55.<java.lang.Class: java.lang.String getName()>();
v57 = virtualinvoke v54.<java.lang.String: boolean equals(java.lang.Object)>(v56);
if v57 != 0 goto label13;
label14:
v58 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeMirrorFactory typeFactory>;
v59 = virtualinvoke v58.<io.vertx.codegen.type.TypeMirrorFactory: io.vertx.codegen.type.TypeInfo create(javax.lang.model.type.TypeMirror)>(v53);
label15:
goto label17;
label16:
v60 := @caughtexception;
v61 = new io.vertx.codegen.GenException;
v62 = virtualinvoke v60.<java.lang.IllegalArgumentException: java.lang.String getMessage()>();
specialinvoke v61.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v1, v62);
throw v61;
label17:
v63 = <io.vertx.codegen.ClassModel$1: int[] $SwitchMap$io$vertx$codegen$type$ClassKind>;
v64 = virtualinvoke v59.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v65 = virtualinvoke v64.<io.vertx.codegen.type.ClassKind: int ordinal()>();
v66 = v63[v65];
lookupswitch(v66)
{
case 1: goto label18;
default: goto label25;
};
label18:
v67 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeMirrorFactory typeFactory>;
v68 = virtualinvoke v67.<io.vertx.codegen.type.TypeMirrorFactory: io.vertx.codegen.type.TypeInfo create(javax.lang.model.type.TypeMirror)>(v53);
v69 = virtualinvoke v68.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v70 = virtualinvoke v69.<io.vertx.codegen.type.ApiTypeInfo: boolean isConcrete()>();
if v70 == 0 goto label21;
v71 = v0.<io.vertx.codegen.ClassModel: boolean concrete>;
if v71 == 0 goto label19;
v72 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo concreteSuperType>;
if v72 == null goto label20;
v73 = new io.vertx.codegen.GenException;
specialinvoke v73.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v1, "A concrete interface cannot extend more than one concrete interfaces");
throw v73;
label19:
v74 = new io.vertx.codegen.GenException;
specialinvoke v74.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v1, "A abstract interface cannot extend a concrete interface");
throw v74;
label20:
v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo concreteSuperType> = v59;
goto label22;
label21:
v75 = v0.<io.vertx.codegen.ClassModel: java.util.List abstractSuperTypes>;
interfaceinvoke v75.<java.util.List: boolean add(java.lang.Object)>(v59);
label22:
v76 = v0.<io.vertx.codegen.ClassModel: java.util.List superTypes>;
interfaceinvoke v76.<java.util.List: boolean add(java.lang.Object)>(v59);
label23:
goto label25;
label24:
v77 := @caughtexception;
v78 = new io.vertx.codegen.GenException;
v79 = virtualinvoke v77.<java.lang.Exception: java.lang.String getMessage()>();
specialinvoke v78.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v1, v79);
throw v78;
label25:
v80 = v0.<io.vertx.codegen.ClassModel: java.util.Set collectedTypes>;
virtualinvoke v59.<io.vertx.codegen.type.TypeInfo: void collectImports(java.util.Collection)>(v80);
goto label13;
label26:
v81 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo concreteSuperType>;
if v81 == null goto label30;
v82 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo concreteSuperType>;
v83 = virtualinvoke v82.<io.vertx.codegen.type.TypeInfo: boolean isParameterized()>();
if v83 == 0 goto label30;
v84 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.element.TypeElement modelElt>;
v85 = interfaceinvoke v84.<javax.lang.model.element.TypeElement: javax.lang.model.type.TypeMirror asType()>();
v86 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Types typeUtils>;
v87 = interfaceinvoke v86.<javax.lang.model.util.Types: java.util.List directSupertypes(javax.lang.model.type.TypeMirror)>(v85);
v88 = interfaceinvoke v87.<java.util.List: java.util.Iterator iterator()>();
label27:
v89 = interfaceinvoke v88.<java.util.Iterator: boolean hasNext()>();
if v89 == 0 goto label30;
v90 = interfaceinvoke v88.<java.util.Iterator: java.lang.Object next()>();
v91 = interfaceinvoke v90.<javax.lang.model.type.TypeMirror: javax.lang.model.type.TypeKind getKind()>();
v92 = <javax.lang.model.type.TypeKind: javax.lang.model.type.TypeKind DECLARED>;
if v91 != v92 goto label27;
v93 = interfaceinvoke v234.<javax.lang.model.type.DeclaredType: javax.lang.model.element.Element asElement()>();
v94 = interfaceinvoke v93.<javax.lang.model.element.TypeElement: javax.lang.model.element.Name getQualifiedName()>();
v95 = virtualinvoke v94.<java.lang.Object: java.lang.String toString()>();
v96 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo concreteSuperType>;
v97 = virtualinvoke v96.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v98 = virtualinvoke v97.<io.vertx.codegen.type.ClassTypeInfo: java.lang.String getName()>();
v99 = virtualinvoke v95.<java.lang.String: boolean equals(java.lang.Object)>(v98);
if v99 == 0 goto label27;
v100 = new java.util.ArrayList;
specialinvoke v100.<java.util.ArrayList: void <init>()>();
v101 = interfaceinvoke v93.<javax.lang.model.element.TypeElement: java.util.List getTypeParameters()>();
v102 = interfaceinvoke v101.<java.util.List: int size()>();
v103 = 0;
label28:
if v103 >= v102 goto label29;
v104 = interfaceinvoke v234.<javax.lang.model.type.DeclaredType: java.util.List getTypeArguments()>();
v105 = interfaceinvoke v104.<java.util.List: java.lang.Object get(int)>(v103);
v106 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeMirrorFactory typeFactory>;
v107 = virtualinvoke v106.<io.vertx.codegen.type.TypeMirrorFactory: io.vertx.codegen.type.TypeInfo create(javax.lang.model.type.TypeMirror)>(v105);
interfaceinvoke v100.<java.util.List: boolean add(java.lang.Object)>(v107);
v103 = v103 + 1;
goto label28;
label29:
v0.<io.vertx.codegen.ClassModel: java.util.List superTypeArguments> = v100;
goto label27;
label30:
v108 = specialinvoke v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo extractArg(java.lang.String,javax.lang.model.type.DeclaredType)>("io.vertx.core.Handler", v2);
v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo handlerArg> = v108;
v109 = specialinvoke v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo extractArg(java.lang.String,javax.lang.model.type.DeclaredType)>("io.vertx.core.streams.ReadStream", v2);
v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo readStreamArg> = v109;
v110 = specialinvoke v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo extractArg(java.lang.String,javax.lang.model.type.DeclaredType)>("io.vertx.core.streams.WriteStream", v2);
v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo writeStreamArg> = v110;
v111 = specialinvoke v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo extractArg(java.lang.String,javax.lang.model.type.DeclaredType)>("java.lang.Iterable", v2);
v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo iterableArg> = v111;
v112 = specialinvoke v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo extractArg(java.lang.String,javax.lang.model.type.DeclaredType)>("java.util.Iterator", v2);
v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo iteratorArg> = v112;
v113 = specialinvoke v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo[] extractArgs(java.lang.String,javax.lang.model.type.DeclaredType)>("java.util.function.Function", v2);
v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo[] functionArgs> = v113;
v114 = interfaceinvoke v1.<javax.lang.model.element.Element: java.util.List getEnclosedElements()>();
v115 = interfaceinvoke v114.<java.util.List: java.util.Iterator iterator()>();
label31:
v116 = interfaceinvoke v115.<java.util.Iterator: boolean hasNext()>();
if v116 == 0 goto label33;
v117 = interfaceinvoke v115.<java.util.Iterator: java.lang.Object next()>();
v118 = staticinvoke <io.vertx.codegen.Helper: boolean isGenIgnore(javax.lang.model.element.Element)>(v117);
if v118 != 0 goto label31;
v119 = <io.vertx.codegen.ClassModel$1: int[] $SwitchMap$javax$lang$model$element$ElementKind>;
v120 = interfaceinvoke v117.<javax.lang.model.element.Element: javax.lang.model.element.ElementKind getKind()>();
v121 = virtualinvoke v120.<javax.lang.model.element.ElementKind: int ordinal()>();
v122 = v119[v121];
lookupswitch(v122)
{
case 4: goto label31;
case 5: goto label31;
default: goto label32;
};
label32:
v123 = new io.vertx.codegen.GenException;
v124 = virtualinvoke v2.<java.lang.Object: java.lang.String toString()>();
v125 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v124) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("@VertxGen can only declare methods and not \u0001");
specialinvoke v123.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v1, v125);
throw v123;
label33:
v126 = interfaceinvoke v1.<javax.lang.model.element.Element: javax.lang.model.element.ElementKind getKind()>();
v127 = <javax.lang.model.element.ElementKind: javax.lang.model.element.ElementKind INTERFACE>;
if v126 != v127 goto label40;
v128 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Elements elementUtils>;
v129 = interfaceinvoke v128.<javax.lang.model.util.Elements: javax.lang.model.element.TypeElement getTypeElement(java.lang.CharSequence)>("java.lang.Object");
v130 = interfaceinvoke v129.<javax.lang.model.element.TypeElement: javax.lang.model.type.TypeMirror asType()>();
v131 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Elements elementUtils>;
v132 = interfaceinvoke v131.<javax.lang.model.util.Elements: java.util.List getAllMembers(javax.lang.model.element.TypeElement)>(v1);
v133 = interfaceinvoke v132.<java.util.List: java.util.stream.Stream stream()>();
v134 = staticinvoke <io.vertx.codegen.ClassModel$lambda_traverseType_10__2483: java.util.function.Predicate bootstrap$(io.vertx.codegen.ClassModel,javax.lang.model.type.TypeMirror)>(v0, v130);
v135 = interfaceinvoke v133.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v134);
v136 = <io.vertx.codegen.Helper: java.util.function.Function FILTER_FIELD>;
v137 = interfaceinvoke v135.<java.util.stream.Stream: java.util.stream.Stream flatMap(java.util.function.Function)>(v136);
v138 = staticinvoke <io.vertx.codegen.ClassModel$lambda_traverseType_11__2484: java.util.function.Consumer bootstrap$(io.vertx.codegen.ClassModel)>(v0);
interfaceinvoke v137.<java.util.stream.Stream: void forEach(java.util.function.Consumer)>(v138);
v139 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Elements elementUtils>;
v140 = interfaceinvoke v139.<javax.lang.model.util.Elements: java.util.List getAllMembers(javax.lang.model.element.TypeElement)>(v1);
v141 = interfaceinvoke v140.<java.util.List: java.util.stream.Stream stream()>();
v142 = staticinvoke <io.vertx.codegen.ClassModel$lambda_traverseType_12__2485: java.util.function.Predicate bootstrap$(io.vertx.codegen.ClassModel,javax.lang.model.type.TypeMirror)>(v0, v130);
v143 = interfaceinvoke v141.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v142);
v144 = <io.vertx.codegen.Helper: java.util.function.Function FILTER_METHOD>;
v145 = interfaceinvoke v143.<java.util.stream.Stream: java.util.stream.Stream flatMap(java.util.function.Function)>(v144);
v146 = staticinvoke <io.vertx.codegen.ClassModel$lambda_traverseType_13__2486: java.util.function.Consumer bootstrap$(io.vertx.codegen.ClassModel)>(v0);
interfaceinvoke v145.<java.util.stream.Stream: void forEach(java.util.function.Consumer)>(v146);
v147 = newarray (java.util.LinkedHashMap)[2];
v148 = v0.<io.vertx.codegen.ClassModel: java.util.LinkedHashMap methods>;
v147[0] = v148;
v149 = v0.<io.vertx.codegen.ClassModel: java.util.LinkedHashMap anyJavaTypeMethods>;
v147[1] = v149;
v150 = staticinvoke <java.util.Arrays: java.util.List asList(java.lang.Object[])>(v147);
v151 = interfaceinvoke v150.<java.util.List: java.util.Iterator iterator()>();
label34:
v152 = interfaceinvoke v151.<java.util.Iterator: boolean hasNext()>();
if v152 == 0 goto label37;
v153 = interfaceinvoke v151.<java.util.Iterator: java.lang.Object next()>();
v154 = interfaceinvoke v153.<java.util.Map: java.util.Set entrySet()>();
v155 = interfaceinvoke v154.<java.util.Set: java.util.Iterator iterator()>();
label35:
v156 = interfaceinvoke v155.<java.util.Iterator: boolean hasNext()>();
if v156 == 0 goto label34;
v157 = interfaceinvoke v155.<java.util.Iterator: java.lang.Object next()>();
v158 = interfaceinvoke v157.<java.util.Map$Entry: java.lang.Object getValue()>();
v159 = virtualinvoke v158.<io.vertx.codegen.MethodInfo: java.util.List getParams()>();
v160 = interfaceinvoke v159.<java.util.List: int size()>();
v161 = virtualinvoke v158.<io.vertx.codegen.MethodInfo: boolean isUseFutures()>();
if v161 == 0 goto label36;
if v160 <= 0 goto label36;
v162 = virtualinvoke v158.<io.vertx.codegen.MethodInfo: io.vertx.codegen.type.TypeInfo getCallbackType()>();
if v162 == null goto label35;
v163 = virtualinvoke v162.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v164 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind ASYNC_RESULT>;
if v163 != v164 goto label35;
v165 = virtualinvoke v158.<io.vertx.codegen.MethodInfo: java.util.Set getOwnerTypes()>();
v166 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.ClassTypeInfo type>;
v167 = interfaceinvoke v165.<java.util.Set: boolean contains(java.lang.Object)>(v166);
if v167 == 0 goto label35;
v168 = virtualinvoke v158.<io.vertx.codegen.MethodInfo: java.util.Set getOwnerTypes()>();
v169 = interfaceinvoke v168.<java.util.Set: int size()>();
if v169 != 1 goto label35;
v170 = virtualinvoke v162.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(0);
v171 = new io.vertx.codegen.GenException;
v172 = interfaceinvoke v157.<java.util.Map$Entry: java.lang.Object getKey()>();
v173 = virtualinvoke v170.<io.vertx.codegen.type.TypeInfo: java.lang.String getSimpleName()>();
v174 = virtualinvoke v170.<io.vertx.codegen.type.TypeInfo: java.lang.String getSimpleName()>();
v175 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v173, v174) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Cannot use Handler<AsyncResult<\u0001>>, instead use a Future<\u0001> return");
specialinvoke v171.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v172, v175);
throw v171;
label36:
v176 = virtualinvoke v158.<io.vertx.codegen.MethodInfo: io.vertx.codegen.type.TypeInfo getReturnType()>();
v177 = virtualinvoke v176.<io.vertx.codegen.type.TypeInfo: boolean isParameterized()>();
if v177 == 0 goto label35;
v178 = virtualinvoke v176.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v179 = virtualinvoke v178.<io.vertx.codegen.type.ClassTypeInfo: java.lang.String getName()>();
v180 = virtualinvoke v179.<java.lang.String: boolean equals(java.lang.Object)>("io.vertx.core.Future");
if v180 == 0 goto label35;
v181 = virtualinvoke v176.<io.vertx.codegen.type.ParameterizedTypeInfo: io.vertx.codegen.type.TypeInfo getArg(int)>(0);
v182 = new java.util.ArrayList;
specialinvoke v182.<java.util.ArrayList: void <init>(java.util.Collection)>(v159);
v183 = new io.vertx.codegen.ParamInfo;
v184 = interfaceinvoke v182.<java.util.List: int size()>();
v185 = new io.vertx.codegen.type.ParameterizedTypeInfo;
v186 = <io.vertx.codegen.ClassModel: io.vertx.codegen.type.ClassTypeInfo HANDLER_TYPE>;
v187 = new io.vertx.codegen.type.ParameterizedTypeInfo;
v188 = <io.vertx.codegen.ClassModel: io.vertx.codegen.type.ClassTypeInfo ASYNC_RESULT_TYPE>;
v189 = staticinvoke <java.util.Collections: java.util.List singletonList(java.lang.Object)>(v181);
specialinvoke v187.<io.vertx.codegen.type.ParameterizedTypeInfo: void <init>(io.vertx.codegen.type.ClassTypeInfo,boolean,java.util.List)>(v188, 0, v189);
v190 = staticinvoke <java.util.Collections: java.util.List singletonList(java.lang.Object)>(v187);
specialinvoke v185.<io.vertx.codegen.type.ParameterizedTypeInfo: void <init>(io.vertx.codegen.type.ClassTypeInfo,boolean,java.util.List)>(v186, 0, v190);
specialinvoke v183.<io.vertx.codegen.ParamInfo: void <init>(int,java.lang.String,io.vertx.codegen.doc.Text,io.vertx.codegen.type.TypeInfo)>(v184, "handler", null, v185);
interfaceinvoke v182.<java.util.List: boolean add(java.lang.Object)>(v183);
v191 = new io.vertx.codegen.Signature;
v192 = virtualinvoke v158.<io.vertx.codegen.MethodInfo: java.lang.String getName()>();
specialinvoke v191.<io.vertx.codegen.Signature: void <init>(java.lang.String,java.util.List)>(v192, v182);
v193 = interfaceinvoke v153.<java.util.Map: java.util.Collection values()>();
v194 = interfaceinvoke v193.<java.util.Collection: java.util.stream.Stream stream()>();
v195 = staticinvoke <io.vertx.codegen.ClassModel$lambda_traverseType_14__2490: java.util.function.Predicate bootstrap$(io.vertx.codegen.MethodInfo)>(v158);
v196 = interfaceinvoke v194.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v195);
v197 = staticinvoke <io.vertx.codegen.ClassModel$lambda_traverseType_15__2491: java.util.function.Predicate bootstrap$(io.vertx.codegen.Signature)>(v191);
v198 = interfaceinvoke v196.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v197);
v199 = interfaceinvoke v198.<java.util.stream.Stream: java.util.Optional findFirst()>();
v200 = virtualinvoke v199.<java.util.Optional: boolean isPresent()>();
if v200 == 0 goto label35;
v201 = v0.<io.vertx.codegen.ClassModel: java.util.Set futureMethods>;
v202 = virtualinvoke v199.<java.util.Optional: java.lang.Object get()>();
interfaceinvoke v201.<java.util.Set: boolean add(java.lang.Object)>(v202);
interfaceinvoke v155.<java.util.Iterator: void remove()>();
goto label35;
label37:
v203 = v0.<io.vertx.codegen.ClassModel: java.util.LinkedHashMap methods>;
v204 = virtualinvoke v203.<java.util.LinkedHashMap: java.util.Set entrySet()>();
v205 = interfaceinvoke v204.<java.util.Set: java.util.stream.Stream stream()>();
v206 = v0.<io.vertx.codegen.ClassModel: java.util.LinkedHashMap anyJavaTypeMethods>;
v207 = virtualinvoke v206.<java.util.LinkedHashMap: java.util.Set entrySet()>();
v208 = interfaceinvoke v207.<java.util.Set: java.util.stream.Stream stream()>();
v209 = staticinvoke <java.util.stream.Stream: java.util.stream.Stream concat(java.util.stream.Stream,java.util.stream.Stream)>(v205, v208);
v210 = staticinvoke <io.vertx.codegen.ClassModel$lambda_traverseType_16__2487: java.util.function.Consumer bootstrap$(io.vertx.codegen.ClassModel)>(v0);
interfaceinvoke v209.<java.util.stream.Stream: void forEach(java.util.function.Consumer)>(v210);
v211 = v0.<io.vertx.codegen.ClassModel: java.util.LinkedHashMap methods>;
v212 = virtualinvoke v211.<java.util.LinkedHashMap: java.util.Collection values()>();
v213 = interfaceinvoke v212.<java.util.Collection: java.util.stream.Stream stream()>();
v214 = staticinvoke <io.vertx.codegen.ClassModel$getName__2488: java.util.function.Function bootstrap$()>();
v215 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector groupingBy(java.util.function.Function)>(v214);
v216 = interfaceinvoke v213.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v215);
v0.<io.vertx.codegen.ClassModel: java.util.Map methodMap> = v216;
v217 = v0.<io.vertx.codegen.ClassModel: java.util.Map methodMap>;
specialinvoke v0.<io.vertx.codegen.ClassModel: void sortMethodMap(java.util.Map)>(v217);
v218 = v0.<io.vertx.codegen.ClassModel: java.util.Map methodMap>;
v219 = interfaceinvoke v218.<java.util.Map: java.util.Collection values()>();
v220 = interfaceinvoke v219.<java.util.Collection: java.util.Iterator iterator()>();
label38:
v221 = interfaceinvoke v220.<java.util.Iterator: boolean hasNext()>();
if v221 == 0 goto label40;
v222 = interfaceinvoke v220.<java.util.Iterator: java.lang.Object next()>();
v223 = staticinvoke <io.vertx.codegen.ClassModel$checkMethod__2489: java.util.function.Consumer bootstrap$(io.vertx.codegen.ClassModel)>(v0);
interfaceinvoke v222.<java.util.List: void forEach(java.util.function.Consumer)>(v223);
v224 = interfaceinvoke v222.<java.util.List: java.lang.Object get(int)>(0);
v225 = interfaceinvoke v222.<java.util.List: java.util.Iterator iterator()>();
label39:
v226 = interfaceinvoke v225.<java.util.Iterator: boolean hasNext()>();
if v226 == 0 goto label38;
v227 = interfaceinvoke v225.<java.util.Iterator: java.lang.Object next()>();
v228 = virtualinvoke v227.<io.vertx.codegen.MethodInfo: boolean isStaticMethod()>();
v229 = virtualinvoke v224.<io.vertx.codegen.MethodInfo: boolean isStaticMethod()>();
if v228 == v229 goto label39;
v230 = new io.vertx.codegen.GenException;
v231 = virtualinvoke v227.<io.vertx.codegen.MethodInfo: java.lang.String getName()>();
v232 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v231) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Overloaded method \u0001 cannot be both static and instance");
specialinvoke v230.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v1, v232);
throw v230;
label40:
return;
catch java.lang.IllegalArgumentException from label14 to label15 with label16;
catch java.lang.Exception from label18 to label23 with label24;
}
protected void checkParamType(javax.lang.model.element.ExecutableElement, io.vertx.codegen.type.TypeInfo, int, int, boolean)
{
io.vertx.codegen.type.TypeInfo v2;
javax.lang.model.element.ExecutableElement v1;
int v3, v4;
io.vertx.codegen.ClassModel v0;
boolean v5;
v0 := @this: io.vertx.codegen.ClassModel;
v1 := @parameter0: javax.lang.model.element.ExecutableElement;
v2 := @parameter1: io.vertx.codegen.type.TypeInfo;
v3 := @parameter2: int;
v4 := @parameter3: int;
v5 := @parameter4: boolean;
staticinvoke <io.vertx.codegen.TypeValidator: void validateParamType(javax.lang.model.element.ExecutableElement,io.vertx.codegen.type.TypeInfo,boolean)>(v1, v2, v5);
return;
}
protected void checkReturnType(javax.lang.model.element.ExecutableElement, io.vertx.codegen.type.TypeInfo, boolean)
{
io.vertx.codegen.type.TypeInfo v2;
javax.lang.model.element.ExecutableElement v1;
io.vertx.codegen.ClassModel v0;
boolean v3;
v0 := @this: io.vertx.codegen.ClassModel;
v1 := @parameter0: javax.lang.model.element.ExecutableElement;
v2 := @parameter1: io.vertx.codegen.type.TypeInfo;
v3 := @parameter2: boolean;
staticinvoke <io.vertx.codegen.TypeValidator: void validateReturnType(javax.lang.model.element.ExecutableElement,io.vertx.codegen.type.TypeInfo,boolean)>(v1, v2, v3);
return;
}
private io.vertx.codegen.type.TypeInfo extractArg(java.lang.String, javax.lang.model.type.DeclaredType)
{
io.vertx.codegen.type.TypeInfo[] v3;
io.vertx.codegen.type.TypeInfo v5;
javax.lang.model.type.DeclaredType v2;
int v4;
java.lang.String v1;
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
v1 := @parameter0: java.lang.String;
v2 := @parameter1: javax.lang.model.type.DeclaredType;
v3 = specialinvoke v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo[] extractArgs(java.lang.String,javax.lang.model.type.DeclaredType)>(v1, v2);
if v3 == null goto label1;
v4 = lengthof v3;
if v4 <= 0 goto label1;
v5 = v3[0];
goto label2;
label1:
v5 = null;
label2:
return v5;
}
private io.vertx.codegen.type.TypeInfo[] extractArgs(java.lang.String, javax.lang.model.type.DeclaredType)
{
javax.lang.model.element.TypeElement v4;
javax.lang.model.util.Elements v3;
io.vertx.codegen.type.TypeInfo[] v12;
javax.lang.model.type.DeclaredType v2;
int v11, v13, v14;
java.lang.String v1, v22;
boolean v23, v9;
javax.lang.model.element.Name v21;
io.vertx.codegen.type.TypeMirrorFactory v24;
io.vertx.codegen.type.TypeInfo v25;
javax.lang.model.element.Element v20;
javax.lang.model.util.Types v15, v6, v8;
io.vertx.codegen.ClassModel v0;
javax.lang.model.type.TypeKind v18, v19;
java.util.List v10;
javax.lang.model.type.TypeMirror v17, v5, v7;
java.lang.Object v16;
v0 := @this: io.vertx.codegen.ClassModel;
v1 := @parameter0: java.lang.String;
v2 := @parameter1: javax.lang.model.type.DeclaredType;
v3 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Elements elementUtils>;
v4 = interfaceinvoke v3.<javax.lang.model.util.Elements: javax.lang.model.element.TypeElement getTypeElement(java.lang.CharSequence)>(v1);
v5 = interfaceinvoke v4.<javax.lang.model.element.TypeElement: javax.lang.model.type.TypeMirror asType()>();
v6 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Types typeUtils>;
v7 = interfaceinvoke v6.<javax.lang.model.util.Types: javax.lang.model.type.TypeMirror erasure(javax.lang.model.type.TypeMirror)>(v5);
v8 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Types typeUtils>;
v9 = interfaceinvoke v8.<javax.lang.model.util.Types: boolean isSubtype(javax.lang.model.type.TypeMirror,javax.lang.model.type.TypeMirror)>(v2, v7);
if v9 == 0 goto label4;
v10 = interfaceinvoke v4.<javax.lang.model.element.TypeElement: java.util.List getTypeParameters()>();
v11 = interfaceinvoke v10.<java.util.List: int size()>();
v12 = newarray (io.vertx.codegen.type.TypeInfo)[v11];
v13 = 0;
label1:
v14 = interfaceinvoke v10.<java.util.List: int size()>();
if v13 >= v14 goto label3;
v15 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Types typeUtils>;
v16 = interfaceinvoke v10.<java.util.List: java.lang.Object get(int)>(v13);
v17 = staticinvoke <io.vertx.codegen.Helper: javax.lang.model.type.TypeMirror resolveTypeParameter(javax.lang.model.util.Types,javax.lang.model.type.DeclaredType,javax.lang.model.element.TypeParameterElement)>(v15, v2, v16);
if v17 == null goto label2;
v18 = interfaceinvoke v17.<javax.lang.model.type.TypeMirror: javax.lang.model.type.TypeKind getKind()>();
v19 = <javax.lang.model.type.TypeKind: javax.lang.model.type.TypeKind DECLARED>;
if v18 != v19 goto label2;
v20 = interfaceinvoke v17.<javax.lang.model.type.DeclaredType: javax.lang.model.element.Element asElement()>();
v21 = interfaceinvoke v20.<javax.lang.model.element.TypeElement: javax.lang.model.element.Name getQualifiedName()>();
v22 = virtualinvoke v21.<java.lang.Object: java.lang.String toString()>();
v23 = virtualinvoke v22.<java.lang.String: boolean equals(java.lang.Object)>("io.vertx.core.AsyncResult");
if v23 == 0 goto label2;
return null;
label2:
v24 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeMirrorFactory typeFactory>;
v25 = virtualinvoke v24.<io.vertx.codegen.type.TypeMirrorFactory: io.vertx.codegen.type.TypeInfo create(javax.lang.model.type.TypeMirror)>(v17);
v12[v13] = v25;
v13 = v13 + 1;
goto label1;
label3:
return v12;
label4:
return null;
}
private io.vertx.codegen.ConstantInfo fieldMethod(javax.lang.model.util.Types, javax.lang.model.element.VariableElement, boolean)
{
io.vertx.codegen.ConstantInfo v13;
javax.lang.model.element.Modifier v5;
javax.lang.model.element.VariableElement v2;
java.lang.String v15;
io.vertx.codegen.doc.Doc$Factory v11;
boolean v3, v6;
javax.lang.model.element.Name v14;
io.vertx.codegen.type.TypeMirrorFactory v7;
io.vertx.codegen.type.TypeInfo v9;
java.util.Set v4;
javax.lang.model.util.Types v1;
io.vertx.codegen.ClassModel v0;
javax.lang.model.type.TypeMirror v10, v8;
io.vertx.codegen.doc.Doc v12;
v0 := @this: io.vertx.codegen.ClassModel;
v1 := @parameter0: javax.lang.model.util.Types;
v2 := @parameter1: javax.lang.model.element.VariableElement;
v3 := @parameter2: boolean;
v4 = interfaceinvoke v2.<javax.lang.model.element.VariableElement: java.util.Set getModifiers()>();
v5 = <javax.lang.model.element.Modifier: javax.lang.model.element.Modifier PUBLIC>;
v6 = interfaceinvoke v4.<java.util.Set: boolean contains(java.lang.Object)>(v5);
if v6 != 0 goto label1;
return null;
label1:
v7 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeMirrorFactory typeFactory>;
v8 = interfaceinvoke v2.<javax.lang.model.element.VariableElement: javax.lang.model.type.TypeMirror asType()>();
v9 = virtualinvoke v7.<io.vertx.codegen.type.TypeMirrorFactory: io.vertx.codegen.type.TypeInfo create(javax.lang.model.type.TypeMirror)>(v8);
v10 = interfaceinvoke v2.<javax.lang.model.element.VariableElement: javax.lang.model.type.TypeMirror asType()>();
staticinvoke <io.vertx.codegen.TypeValidator: void validateConstantType(javax.lang.model.util.Types,javax.lang.model.element.VariableElement,io.vertx.codegen.type.TypeInfo,javax.lang.model.type.TypeMirror,boolean)>(v1, v2, v9, v10, v3);
v11 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.doc.Doc$Factory docFactory>;
v12 = virtualinvoke v11.<io.vertx.codegen.doc.Doc$Factory: io.vertx.codegen.doc.Doc createDoc(javax.lang.model.element.Element)>(v2);
v13 = new io.vertx.codegen.ConstantInfo;
v14 = interfaceinvoke v2.<javax.lang.model.element.VariableElement: javax.lang.model.element.Name getSimpleName()>();
v15 = virtualinvoke v14.<java.lang.Object: java.lang.String toString()>();
specialinvoke v13.<io.vertx.codegen.ConstantInfo: void <init>(io.vertx.codegen.doc.Doc,java.lang.String,io.vertx.codegen.type.TypeInfo)>(v12, v15, v9);
return v13;
}
private io.vertx.codegen.MethodInfo createMethod(javax.lang.model.element.ExecutableElement, boolean)
{
javax.lang.model.util.Elements v115, v129, v155, v168, v66, v92;
javax.lang.model.element.Element v6, v64, v75;
javax.tools.Diagnostic$Kind v181;
java.util.stream.Stream v101, v103, v106, v108, v120, v122, v68, v70, v72, v99;
java.lang.Object[] v143, v193;
java.util.LinkedHashMap v213;
io.vertx.codegen.type.ClassTypeInfo v24, v32, v86;
javax.lang.model.element.AnnotationMirror v170;
io.vertx.codegen.type.TypeUse v144, v194;
javax.lang.model.element.ExecutableElement[] v142, v192;
io.vertx.codegen.ParamInfo v167;
io.vertx.codegen.type.ClassKind v16, v17, v18, v19, v22, v23;
javax.'annotation'.processing.Messager v180;
io.vertx.codegen.type.TypeInfo v146, v163, v197, v238, v31, v85, v9;
io.vertx.codegen.ClassModel v0;
java.lang.'annotation'.Annotation v204, v208, v39, v65;
java.util.function.Function v102, v118, v132, v158, v69;
java.util.HashSet v56;
int v136, v137, v191, v233, v235, v236, v239;
javax.lang.model.element.ExecutableElement v1;
java.util.function.Consumer v104, v73;
javax.lang.model.type.TypeMirror v12, v13, v134, v174, v176, v184, v187, v196, v224, v225, v27, v30, v78, v79, v8, v84;
java.lang.Object v112, v126, v138, v140, v153, v162, v217, v218, v223, v230, v237, v46, v50, v63, v89;
io.vertx.codegen.MethodInfo v212;
java.util.Comparator v60;
javax.lang.model.element.Modifier v33, v35, v4;
javax.lang.model.element.TypeElement v11, v117, v131, v14, v157, v175, v178, v182, v186, v20, v58, v77;
io.vertx.codegen.type.TypeMirrorFactory v145, v160, v195, v29, v7, v83;
java.util.Set v201, v214, v231, v232, v3, v59;
java.lang.Exception v147, v164, v198;
io.vertx.codegen.doc.Doc v95;
io.vertx.codegen.ModuleInfo v81, v87, v90;
java.util.ArrayList v133, v42, v55, v57;
io.vertx.codegen.GenException v148, v165, v189, v199, v203, v38, v52;
java.lang.String v113, v114, v127, v128, v149, v152, v166, v179, v200, v211, v219, v221, v53, v93;
io.vertx.codegen.doc.Doc$Factory v94;
io.vertx.codegen.doc.Text v111, v125, v154, v159, v205, v96, v97;
boolean v110, v124, v15, v171, v172, v177, v188, v2, v202, v206, v207, v209, v21, v216, v222, v227, v229, v25, v28, v34, v36, v37, v40, v41, v45, v49, v5, v51, v62, v74, v80, v82;
java.util.function.Predicate v100, v107, v121, v71;
java.util.logging.Logger v183;
javax.lang.model.util.Types v10, v116, v130, v156, v169, v173, v185, v226, v228, v26, v76;
java.util.List v105, v119, v135, v139, v161, v234, v43, v47, v67, v98;
java.lang.StackTraceElement[] v150;
java.util.Optional v109, v123;
java.util.HashMap v91;
io.vertx.codegen.TypeParamInfo v54;
javax.lang.model.element.Name v151, v210, v220;
java.util.Iterator v215, v44, v48, v61, v88;
javax.'annotation'.processing.ProcessingEnvironment v141, v190;
v0 := @this: io.vertx.codegen.ClassModel;
v1 := @parameter0: javax.lang.model.element.ExecutableElement;
v2 := @parameter1: boolean;
v3 = interfaceinvoke v1.<javax.lang.model.element.ExecutableElement: java.util.Set getModifiers()>();
v4 = <javax.lang.model.element.Modifier: javax.lang.model.element.Modifier PUBLIC>;
v5 = interfaceinvoke v3.<java.util.Set: boolean contains(java.lang.Object)>(v4);
if v5 != 0 goto label01;
return null;
label01:
v6 = interfaceinvoke v1.<javax.lang.model.element.ExecutableElement: javax.lang.model.element.Element getEnclosingElement()>();
v7 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeMirrorFactory typeFactory>;
v8 = interfaceinvoke v6.<javax.lang.model.element.TypeElement: javax.lang.model.type.TypeMirror asType()>();
v9 = virtualinvoke v7.<io.vertx.codegen.type.TypeMirrorFactory: io.vertx.codegen.type.TypeInfo create(javax.lang.model.type.TypeMirror)>(v8);
v10 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Types typeUtils>;
v11 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.element.TypeElement modelElt>;
v12 = interfaceinvoke v11.<javax.lang.model.element.TypeElement: javax.lang.model.type.TypeMirror asType()>();
v13 = interfaceinvoke v10.<javax.lang.model.util.Types: javax.lang.model.type.TypeMirror asMemberOf(javax.lang.model.type.DeclaredType,javax.lang.model.element.Element)>(v12, v1);
v14 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.element.TypeElement modelElt>;
v15 = virtualinvoke v6.<java.lang.Object: boolean equals(java.lang.Object)>(v14);
if v15 != 0 goto label02;
v16 = virtualinvoke v9.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v17 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind API>;
if v16 == v17 goto label02;
v18 = virtualinvoke v9.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v19 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind HANDLER>;
if v18 == v19 goto label02;
return null;
label02:
v20 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.element.TypeElement modelElt>;
v21 = virtualinvoke v6.<java.lang.Object: boolean equals(java.lang.Object)>(v20);
if v21 != 0 goto label03;
v22 = virtualinvoke v9.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v23 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind API>;
if v22 != v23 goto label03;
v24 = virtualinvoke v9.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v25 = virtualinvoke v24.<io.vertx.codegen.type.ApiTypeInfo: boolean isConcrete()>();
if v25 == 0 goto label03;
v26 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Types typeUtils>;
v27 = interfaceinvoke v1.<javax.lang.model.element.ExecutableElement: javax.lang.model.type.TypeMirror asType()>();
v28 = interfaceinvoke v26.<javax.lang.model.util.Types: boolean isSameType(javax.lang.model.type.TypeMirror,javax.lang.model.type.TypeMirror)>(v13, v27);
if v28 == 0 goto label03;
return null;
label03:
v29 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeMirrorFactory typeFactory>;
v30 = interfaceinvoke v6.<javax.lang.model.element.TypeElement: javax.lang.model.type.TypeMirror asType()>();
v31 = virtualinvoke v29.<io.vertx.codegen.type.TypeMirrorFactory: io.vertx.codegen.type.TypeInfo create(javax.lang.model.type.TypeMirror)>(v30);
v32 = virtualinvoke v31.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v33 = <javax.lang.model.element.Modifier: javax.lang.model.element.Modifier DEFAULT>;
v34 = interfaceinvoke v3.<java.util.Set: boolean contains(java.lang.Object)>(v33);
v35 = <javax.lang.model.element.Modifier: javax.lang.model.element.Modifier STATIC>;
v36 = interfaceinvoke v3.<java.util.Set: boolean contains(java.lang.Object)>(v35);
if v36 == 0 goto label04;
v37 = v0.<io.vertx.codegen.ClassModel: boolean concrete>;
if v37 != 0 goto label04;
v38 = new io.vertx.codegen.GenException;
specialinvoke v38.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v1, "Abstract interface cannot declare static methods");
throw v38;
label04:
v39 = interfaceinvoke v1.<javax.lang.model.element.ExecutableElement: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Lio/vertx/codegen/annotations/CacheReturn;");
if v39 == null goto label05;
v40 = 1;
goto label06;
label05:
v40 = 0;
label06:
v41 = v40;
v42 = new java.util.ArrayList;
specialinvoke v42.<java.util.ArrayList: void <init>()>();
v43 = interfaceinvoke v1.<javax.lang.model.element.ExecutableElement: java.util.List getTypeParameters()>();
v44 = interfaceinvoke v43.<java.util.List: java.util.Iterator iterator()>();
label07:
v45 = interfaceinvoke v44.<java.util.Iterator: boolean hasNext()>();
if v45 == 0 goto label10;
v46 = interfaceinvoke v44.<java.util.Iterator: java.lang.Object next()>();
v47 = interfaceinvoke v46.<javax.lang.model.element.TypeParameterElement: java.util.List getBounds()>();
v48 = interfaceinvoke v47.<java.util.List: java.util.Iterator iterator()>();
label08:
v49 = interfaceinvoke v48.<java.util.Iterator: boolean hasNext()>();
if v49 == 0 goto label09;
v50 = interfaceinvoke v48.<java.util.Iterator: java.lang.Object next()>();
v51 = specialinvoke v0.<io.vertx.codegen.ClassModel: boolean isObjectBound(javax.lang.model.type.TypeMirror)>(v50);
if v51 != 0 goto label08;
v52 = new io.vertx.codegen.GenException;
v53 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (javax.lang.model.type.TypeMirror)>(v50) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Type parameter bound not supported \u0001");
specialinvoke v52.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v1, v53);
throw v52;
label09:
v54 = staticinvoke <io.vertx.codegen.TypeParamInfo: io.vertx.codegen.TypeParamInfo create(javax.lang.model.element.TypeParameterElement)>(v46);
virtualinvoke v42.<java.util.ArrayList: boolean add(java.lang.Object)>(v54);
goto label07;
label10:
v55 = new java.util.ArrayList;
specialinvoke v55.<java.util.ArrayList: void <init>()>();
interfaceinvoke v55.<java.util.List: boolean add(java.lang.Object)>(v1);
v56 = new java.util.HashSet;
specialinvoke v56.<java.util.HashSet: void <init>()>();
v57 = new java.util.ArrayList;
v58 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.element.TypeElement modelElt>;
v59 = staticinvoke <io.vertx.codegen.Helper: java.util.Set resolveAncestorTypes(javax.lang.model.element.TypeElement,boolean,boolean)>(v58, 1, 1);
specialinvoke v57.<java.util.ArrayList: void <init>(java.util.Collection)>(v59);
v60 = staticinvoke <io.vertx.codegen.ClassModel$lambda_createMethod_17__2494: java.util.Comparator bootstrap$(io.vertx.codegen.ClassModel)>(v0);
staticinvoke <java.util.Collections: void sort(java.util.List,java.util.Comparator)>(v57, v60);
v61 = virtualinvoke v57.<java.util.ArrayList: java.util.Iterator iterator()>();
label11:
v62 = interfaceinvoke v61.<java.util.Iterator: boolean hasNext()>();
if v62 == 0 goto label12;
v63 = interfaceinvoke v61.<java.util.Iterator: java.lang.Object next()>();
v64 = interfaceinvoke v63.<javax.lang.model.type.DeclaredType: javax.lang.model.element.Element asElement()>();
v65 = interfaceinvoke v64.<javax.lang.model.element.TypeElement: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Lio/vertx/codegen/annotations/VertxGen;");
if v65 == null goto label11;
v66 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Elements elementUtils>;
v67 = interfaceinvoke v66.<javax.lang.model.util.Elements: java.util.List getAllMembers(javax.lang.model.element.TypeElement)>(v64);
v68 = interfaceinvoke v67.<java.util.List: java.util.stream.Stream stream()>();
v69 = <io.vertx.codegen.Helper: java.util.function.Function FILTER_METHOD>;
v70 = interfaceinvoke v68.<java.util.stream.Stream: java.util.stream.Stream flatMap(java.util.function.Function)>(v69);
v71 = staticinvoke <io.vertx.codegen.ClassModel$lambda_createMethod_18__2500: java.util.function.Predicate bootstrap$(io.vertx.codegen.ClassModel,javax.lang.model.element.ExecutableElement)>(v0, v1);
v72 = interfaceinvoke v70.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v71);
v73 = staticinvoke <io.vertx.codegen.ClassModel$lambda_createMethod_19__2501: java.util.function.Consumer bootstrap$(io.vertx.codegen.ClassModel,java.util.List,java.util.Set,javax.lang.model.element.TypeElement)>(v0, v55, v56, v64);
interfaceinvoke v72.<java.util.stream.Stream: void forEach(java.util.function.Consumer)>(v73);
goto label11;
label12:
v74 = interfaceinvoke v56.<java.util.Set: boolean isEmpty()>();
if v74 == 0 goto label14;
v75 = interfaceinvoke v1.<javax.lang.model.element.ExecutableElement: javax.lang.model.element.Element getEnclosingElement()>();
v76 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Types typeUtils>;
v77 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.element.TypeElement modelElt>;
v78 = interfaceinvoke v77.<javax.lang.model.element.TypeElement: javax.lang.model.type.TypeMirror asType()>();
v79 = interfaceinvoke v75.<javax.lang.model.element.Element: javax.lang.model.type.TypeMirror asType()>();
v80 = interfaceinvoke v76.<javax.lang.model.util.Types: boolean isSameType(javax.lang.model.type.TypeMirror,javax.lang.model.type.TypeMirror)>(v78, v79);
if v80 == 0 goto label13;
v81 = virtualinvoke v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.ModuleInfo getModule()>();
v82 = v81.<io.vertx.codegen.ModuleInfo: boolean useFutures>;
goto label15;
label13:
v83 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeMirrorFactory typeFactory>;
v84 = interfaceinvoke v75.<javax.lang.model.element.Element: javax.lang.model.type.TypeMirror asType()>();
v85 = virtualinvoke v83.<io.vertx.codegen.type.TypeMirrorFactory: io.vertx.codegen.type.TypeInfo create(javax.lang.model.type.DeclaredType)>(v84);
v86 = virtualinvoke v85.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v87 = virtualinvoke v86.<io.vertx.codegen.type.ClassTypeInfo: io.vertx.codegen.ModuleInfo getModule()>();
v82 = v87.<io.vertx.codegen.ModuleInfo: boolean useFutures>;
goto label15;
label14:
v88 = interfaceinvoke v56.<java.util.Set: java.util.Iterator iterator()>();
v89 = interfaceinvoke v88.<java.util.Iterator: java.lang.Object next()>();
v90 = virtualinvoke v89.<io.vertx.codegen.type.ClassTypeInfo: io.vertx.codegen.ModuleInfo getModule()>();
v82 = v90.<io.vertx.codegen.ModuleInfo: boolean useFutures>;
label15:
interfaceinvoke v56.<java.util.Set: boolean add(java.lang.Object)>(v32);
v91 = new java.util.HashMap;
specialinvoke v91.<java.util.HashMap: void <init>()>();
v92 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Elements elementUtils>;
v93 = interfaceinvoke v92.<javax.lang.model.util.Elements: java.lang.String getDocComment(javax.lang.model.element.Element)>(v1);
v94 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.doc.Doc$Factory docFactory>;
v95 = virtualinvoke v94.<io.vertx.codegen.doc.Doc$Factory: io.vertx.codegen.doc.Doc createDoc(javax.lang.model.element.Element)>(v1);
v96 = null;
v97 = null;
if v95 == null goto label17;
v98 = virtualinvoke v95.<io.vertx.codegen.doc.Doc: java.util.List getBlockTags()>();
v99 = interfaceinvoke v98.<java.util.List: java.util.stream.Stream stream()>();
v100 = staticinvoke <io.vertx.codegen.ClassModel$lambda_createMethod_20__2495: java.util.function.Predicate bootstrap$()>();
v101 = interfaceinvoke v99.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v100);
v102 = staticinvoke <io.vertx.codegen.ClassModel$init__2496: java.util.function.Function bootstrap$()>();
v103 = interfaceinvoke v101.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v102);
v104 = staticinvoke <io.vertx.codegen.ClassModel$lambda_createMethod_21__2497: java.util.function.Consumer bootstrap$(java.util.Map)>(v91);
interfaceinvoke v103.<java.util.stream.Stream: void forEach(java.util.function.Consumer)>(v104);
v105 = virtualinvoke v95.<io.vertx.codegen.doc.Doc: java.util.List getBlockTags()>();
v106 = interfaceinvoke v105.<java.util.List: java.util.stream.Stream stream()>();
v107 = staticinvoke <io.vertx.codegen.ClassModel$lambda_createMethod_22__2498: java.util.function.Predicate bootstrap$()>();
v108 = interfaceinvoke v106.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v107);
v109 = interfaceinvoke v108.<java.util.stream.Stream: java.util.Optional findFirst()>();
v110 = virtualinvoke v109.<java.util.Optional: boolean isPresent()>();
if v110 == 0 goto label16;
v111 = new io.vertx.codegen.doc.Text;
v112 = virtualinvoke v109.<java.util.Optional: java.lang.Object get()>();
v113 = virtualinvoke v112.<io.vertx.codegen.doc.Tag: java.lang.String getValue()>();
v114 = staticinvoke <io.vertx.codegen.Helper: java.lang.String normalizeWhitespaces(java.lang.String)>(v113);
specialinvoke v111.<io.vertx.codegen.doc.Text: void <init>(java.lang.String)>(v114);
v115 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Elements elementUtils>;
v116 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Types typeUtils>;
v117 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.element.TypeElement modelElt>;
v118 = staticinvoke <io.vertx.codegen.doc.Token: java.util.function.Function tagMapper(javax.lang.model.util.Elements,javax.lang.model.util.Types,javax.lang.model.element.TypeElement)>(v115, v116, v117);
v96 = virtualinvoke v111.<io.vertx.codegen.doc.Text: io.vertx.codegen.doc.Text map(java.util.function.Function)>(v118);
label16:
v119 = virtualinvoke v95.<io.vertx.codegen.doc.Doc: java.util.List getBlockTags()>();
v120 = interfaceinvoke v119.<java.util.List: java.util.stream.Stream stream()>();
v121 = staticinvoke <io.vertx.codegen.ClassModel$lambda_createMethod_23__2499: java.util.function.Predicate bootstrap$()>();
v122 = interfaceinvoke v120.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v121);
v123 = interfaceinvoke v122.<java.util.stream.Stream: java.util.Optional findFirst()>();
v124 = virtualinvoke v123.<java.util.Optional: boolean isPresent()>();
if v124 == 0 goto label17;
v125 = new io.vertx.codegen.doc.Text;
v126 = virtualinvoke v123.<java.util.Optional: java.lang.Object get()>();
v127 = virtualinvoke v126.<io.vertx.codegen.doc.Tag: java.lang.String getValue()>();
v128 = staticinvoke <io.vertx.codegen.Helper: java.lang.String normalizeWhitespaces(java.lang.String)>(v127);
specialinvoke v125.<io.vertx.codegen.doc.Text: void <init>(java.lang.String)>(v128);
v129 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Elements elementUtils>;
v130 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Types typeUtils>;
v131 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.element.TypeElement modelElt>;
v132 = staticinvoke <io.vertx.codegen.doc.Token: java.util.function.Function tagMapper(javax.lang.model.util.Elements,javax.lang.model.util.Types,javax.lang.model.element.TypeElement)>(v129, v130, v131);
v97 = virtualinvoke v125.<io.vertx.codegen.doc.Text: io.vertx.codegen.doc.Text map(java.util.function.Function)>(v132);
label17:
v133 = new java.util.ArrayList;
specialinvoke v133.<java.util.ArrayList: void <init>()>();
v134 = interfaceinvoke v1.<javax.lang.model.element.ExecutableElement: javax.lang.model.type.TypeMirror asType()>();
v135 = interfaceinvoke v1.<javax.lang.model.element.ExecutableElement: java.util.List getParameters()>();
v136 = 0;
label18:
v137 = interfaceinvoke v135.<java.util.List: int size()>();
if v136 >= v137 goto label28;
v138 = interfaceinvoke v135.<java.util.List: java.lang.Object get(int)>(v136);
v139 = interfaceinvoke v13.<javax.lang.model.type.ExecutableType: java.util.List getParameterTypes()>();
v140 = interfaceinvoke v139.<java.util.List: java.lang.Object get(int)>(v136);
v141 = v0.<io.vertx.codegen.ClassModel: javax.'annotation'.processing.ProcessingEnvironment env>;
v142 = newarray (javax.lang.model.element.ExecutableElement)[0];
v143 = interfaceinvoke v55.<java.util.List: java.lang.Object[] toArray(java.lang.Object[])>(v142);
v144 = staticinvoke <io.vertx.codegen.type.TypeUse: io.vertx.codegen.type.TypeUse createParamTypeUse(javax.'annotation'.processing.ProcessingEnvironment,javax.lang.model.element.ExecutableElement[],int)>(v141, v143, v136);
label19:
v145 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeMirrorFactory typeFactory>;
v146 = virtualinvoke v145.<io.vertx.codegen.type.TypeMirrorFactory: io.vertx.codegen.type.TypeInfo create(io.vertx.codegen.type.TypeUse,javax.lang.model.type.TypeMirror)>(v144, v140);
label20:
goto label22;
label21:
v147 := @caughtexception;
v148 = new io.vertx.codegen.GenException;
v149 = virtualinvoke v147.<java.lang.Exception: java.lang.String getMessage()>();
specialinvoke v148.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v138, v149);
v150 = virtualinvoke v147.<java.lang.Exception: java.lang.StackTraceElement[] getStackTrace()>();
virtualinvoke v148.<io.vertx.codegen.GenException: void setStackTrace(java.lang.StackTraceElement[])>(v150);
throw v148;
label22:
v151 = interfaceinvoke v138.<javax.lang.model.element.VariableElement: javax.lang.model.element.Name getSimpleName()>();
v152 = virtualinvoke v151.<java.lang.Object: java.lang.String toString()>();
v153 = interfaceinvoke v91.<java.util.Map: java.lang.Object get(java.lang.Object)>(v152);
if v153 == null goto label23;
v154 = new io.vertx.codegen.doc.Text;
specialinvoke v154.<io.vertx.codegen.doc.Text: void <init>(java.lang.String)>(v153);
v155 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Elements elementUtils>;
v156 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Types typeUtils>;
v157 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.element.TypeElement modelElt>;
v158 = staticinvoke <io.vertx.codegen.doc.Token: java.util.function.Function tagMapper(javax.lang.model.util.Elements,javax.lang.model.util.Types,javax.lang.model.element.TypeElement)>(v155, v156, v157);
v159 = virtualinvoke v154.<io.vertx.codegen.doc.Text: io.vertx.codegen.doc.Text map(java.util.function.Function)>(v158);
goto label24;
label23:
v159 = null;
label24:
v160 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeMirrorFactory typeFactory>;
v161 = interfaceinvoke v134.<javax.lang.model.type.ExecutableType: java.util.List getParameterTypes()>();
v162 = interfaceinvoke v161.<java.util.List: java.lang.Object get(int)>(v136);
v163 = virtualinvoke v160.<io.vertx.codegen.type.TypeMirrorFactory: io.vertx.codegen.type.TypeInfo create(io.vertx.codegen.type.TypeUse,javax.lang.model.type.TypeMirror)>(v144, v162);
label25:
goto label27;
label26:
v164 := @caughtexception;
v165 = new io.vertx.codegen.GenException;
v166 = virtualinvoke v164.<java.lang.Exception: java.lang.String getMessage()>();
specialinvoke v165.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v138, v166);
throw v165;
label27:
v167 = new io.vertx.codegen.ParamInfo;
specialinvoke v167.<io.vertx.codegen.ParamInfo: void <init>(int,java.lang.String,io.vertx.codegen.doc.Text,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.type.TypeInfo)>(v136, v152, v159, v146, v163);
interfaceinvoke v133.<java.util.List: boolean add(java.lang.Object)>(v167);
v136 = v136 + 1;
goto label18;
label28:
v168 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Elements elementUtils>;
v169 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Types typeUtils>;
v170 = staticinvoke <io.vertx.codegen.Helper: javax.lang.model.element.AnnotationMirror resolveMethodAnnotation(java.lang.Class,javax.lang.model.util.Elements,javax.lang.model.util.Types,javax.lang.model.element.TypeElement,javax.lang.model.element.ExecutableElement)>(class "Lio/vertx/codegen/annotations/Fluent;", v168, v169, v6, v1);
if v170 == null goto label29;
v171 = 1;
goto label30;
label29:
v171 = 0;
label30:
v172 = v171;
if v171 == 0 goto label32;
v172 = 1;
v173 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Types typeUtils>;
v174 = interfaceinvoke v6.<javax.lang.model.element.TypeElement: javax.lang.model.type.TypeMirror asType()>();
v175 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.element.TypeElement modelElt>;
v176 = interfaceinvoke v175.<javax.lang.model.element.TypeElement: javax.lang.model.type.TypeMirror asType()>();
v177 = interfaceinvoke v173.<javax.lang.model.util.Types: boolean isSameType(javax.lang.model.type.TypeMirror,javax.lang.model.type.TypeMirror)>(v174, v176);
if v177 != 0 goto label31;
v178 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.element.TypeElement modelElt>;
v179 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (javax.lang.model.element.TypeElement,javax.lang.model.element.ExecutableElement,javax.lang.model.element.TypeElement)>(v178, v1, v6) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Interface \u0001 does not redeclare the @Fluent return type  of method \u0001 declared by \u0001");
v180 = v0.<io.vertx.codegen.ClassModel: javax.'annotation'.processing.Messager messager>;
v181 = <javax.tools.Diagnostic$Kind: javax.tools.Diagnostic$Kind WARNING>;
v182 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.element.TypeElement modelElt>;
interfaceinvoke v180.<javax.'annotation'.processing.Messager: void printMessage(javax.tools.Diagnostic$Kind,java.lang.CharSequence,javax.lang.model.element.Element,javax.lang.model.element.AnnotationMirror)>(v181, v179, v182, v170);
v183 = <io.vertx.codegen.ClassModel: java.util.logging.Logger logger>;
virtualinvoke v183.<java.util.logging.Logger: void warning(java.lang.String)>(v179);
goto label32;
label31:
v184 = interfaceinvoke v1.<javax.lang.model.element.ExecutableElement: javax.lang.model.type.TypeMirror getReturnType()>();
v185 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Types typeUtils>;
v186 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.element.TypeElement modelElt>;
v187 = interfaceinvoke v186.<javax.lang.model.element.TypeElement: javax.lang.model.type.TypeMirror asType()>();
v188 = interfaceinvoke v185.<javax.lang.model.util.Types: boolean isAssignable(javax.lang.model.type.TypeMirror,javax.lang.model.type.TypeMirror)>(v184, v187);
if v188 != 0 goto label32;
v189 = new io.vertx.codegen.GenException;
specialinvoke v189.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v1, "Methods marked with @Fluent must have a return type that extends the type");
throw v189;
label32:
v190 = v0.<io.vertx.codegen.ClassModel: javax.'annotation'.processing.ProcessingEnvironment env>;
v191 = interfaceinvoke v55.<java.util.List: int size()>();
v192 = newarray (javax.lang.model.element.ExecutableElement)[v191];
v193 = interfaceinvoke v55.<java.util.List: java.lang.Object[] toArray(java.lang.Object[])>(v192);
v194 = staticinvoke <io.vertx.codegen.type.TypeUse: io.vertx.codegen.type.TypeUse createReturnTypeUse(javax.'annotation'.processing.ProcessingEnvironment,javax.lang.model.element.ExecutableElement[])>(v190, v193);
label33:
v195 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeMirrorFactory typeFactory>;
v196 = interfaceinvoke v13.<javax.lang.model.type.ExecutableType: javax.lang.model.type.TypeMirror getReturnType()>();
v197 = virtualinvoke v195.<io.vertx.codegen.type.TypeMirrorFactory: io.vertx.codegen.type.TypeInfo create(io.vertx.codegen.type.TypeUse,javax.lang.model.type.TypeMirror)>(v194, v196);
label34:
goto label36;
label35:
v198 := @caughtexception;
v199 = new io.vertx.codegen.GenException;
v200 = virtualinvoke v198.<java.lang.Exception: java.lang.String getMessage()>();
specialinvoke v199.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v1, v200);
virtualinvoke v199.<io.vertx.codegen.GenException: java.lang.Throwable initCause(java.lang.Throwable)>(v198);
throw v199;
label36:
v201 = v0.<io.vertx.codegen.ClassModel: java.util.Set collectedTypes>;
virtualinvoke v197.<io.vertx.codegen.type.TypeInfo: void collectImports(java.util.Collection)>(v201);
if v41 == 0 goto label37;
v202 = virtualinvoke v197.<io.vertx.codegen.type.TypeInfo: boolean isVoid()>();
if v202 == 0 goto label37;
v203 = new io.vertx.codegen.GenException;
specialinvoke v203.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v1, "void method can\'t be marked with @CacheReturn");
throw v203;
label37:
v204 = interfaceinvoke v1.<javax.lang.model.element.ExecutableElement: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Ljava/lang/Deprecated;");
if v204 != null goto label38;
v205 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.doc.Text deprecatedDesc>;
if v205 == null goto label39;
label38:
v206 = 1;
goto label40;
label39:
v206 = 0;
label40:
v207 = v206;
v208 = interfaceinvoke v1.<javax.lang.model.element.ExecutableElement: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Ljava/lang/Override;");
if v208 == null goto label41;
v209 = 1;
goto label42;
label41:
v209 = 0;
label42:
v210 = interfaceinvoke v1.<javax.lang.model.element.ExecutableElement: javax.lang.model.element.Name getSimpleName()>();
v211 = virtualinvoke v210.<java.lang.Object: java.lang.String toString()>();
v212 = virtualinvoke v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.MethodInfo createMethodInfo(java.util.Set,java.lang.String,java.lang.String,io.vertx.codegen.doc.Doc,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.doc.Text,boolean,boolean,java.util.List,javax.lang.model.element.ExecutableElement,boolean,boolean,java.util.ArrayList,javax.lang.model.element.TypeElement,boolean,io.vertx.codegen.doc.Text,boolean,boolean)>(v56, v211, v93, v95, v197, v96, v172, v41, v133, v1, v36, v34, v42, v6, v207, v97, v82, v209);
v213 = v0.<io.vertx.codegen.ClassModel: java.util.LinkedHashMap methods>;
v214 = virtualinvoke v213.<java.util.LinkedHashMap: java.util.Set entrySet()>();
v215 = interfaceinvoke v214.<java.util.Set: java.util.Iterator iterator()>();
label43:
v216 = interfaceinvoke v215.<java.util.Iterator: boolean hasNext()>();
if v216 == 0 goto label44;
v217 = interfaceinvoke v215.<java.util.Iterator: java.lang.Object next()>();
v218 = interfaceinvoke v217.<java.util.Map$Entry: java.lang.Object getValue()>();
v219 = virtualinvoke v218.<io.vertx.codegen.MethodInfo: java.lang.String getName()>();
v220 = interfaceinvoke v1.<javax.lang.model.element.ExecutableElement: javax.lang.model.element.Name getSimpleName()>();
v221 = virtualinvoke v220.<java.lang.Object: java.lang.String toString()>();
v222 = virtualinvoke v219.<java.lang.String: boolean equals(java.lang.Object)>(v221);
if v222 == 0 goto label43;
v223 = interfaceinvoke v217.<java.util.Map$Entry: java.lang.Object getKey()>();
v224 = interfaceinvoke v223.<javax.lang.model.element.ExecutableElement: javax.lang.model.type.TypeMirror asType()>();
v225 = interfaceinvoke v1.<javax.lang.model.element.ExecutableElement: javax.lang.model.type.TypeMirror asType()>();
v226 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Types typeUtils>;
v227 = interfaceinvoke v226.<javax.lang.model.util.Types: boolean isSubsignature(javax.lang.model.type.ExecutableType,javax.lang.model.type.ExecutableType)>(v224, v225);
if v227 == 0 goto label43;
v228 = v0.<io.vertx.codegen.ClassModel: javax.lang.model.util.Types typeUtils>;
v229 = interfaceinvoke v228.<javax.lang.model.util.Types: boolean isSubsignature(javax.lang.model.type.ExecutableType,javax.lang.model.type.ExecutableType)>(v225, v224);
if v229 == 0 goto label43;
v230 = interfaceinvoke v217.<java.util.Map$Entry: java.lang.Object getValue()>();
v231 = virtualinvoke v230.<io.vertx.codegen.MethodInfo: java.util.Set getOwnerTypes()>();
v232 = virtualinvoke v212.<io.vertx.codegen.MethodInfo: java.util.Set getOwnerTypes()>();
interfaceinvoke v231.<java.util.Set: boolean addAll(java.util.Collection)>(v232);
return null;
label44:
v233 = interfaceinvoke v56.<java.util.Set: int size()>();
if v233 != 1 goto label46;
v234 = virtualinvoke v212.<io.vertx.codegen.MethodInfo: java.util.List getParams()>();
v235 = 0;
label45:
v236 = interfaceinvoke v234.<java.util.List: int size()>();
if v235 >= v236 goto label46;
v237 = interfaceinvoke v234.<java.util.List: java.lang.Object get(int)>(v235);
v238 = virtualinvoke v237.<io.vertx.codegen.ParamInfo: io.vertx.codegen.type.TypeInfo getType()>();
v239 = interfaceinvoke v234.<java.util.List: int size()>();
virtualinvoke v0.<io.vertx.codegen.ClassModel: void checkParamType(javax.lang.model.element.ExecutableElement,io.vertx.codegen.type.TypeInfo,int,int,boolean)>(v1, v238, v235, v239, v2);
v235 = v235 + 1;
goto label45;
label46:
return v212;
catch java.lang.Exception from label19 to label20 with label21;
catch java.lang.Exception from label24 to label25 with label26;
catch java.lang.Exception from label33 to label34 with label35;
}
protected io.vertx.codegen.MethodInfo createMethodInfo(java.util.Set, java.lang.String, java.lang.String, io.vertx.codegen.doc.Doc, io.vertx.codegen.type.TypeInfo, io.vertx.codegen.doc.Text, boolean, boolean, java.util.List, javax.lang.model.element.ExecutableElement, boolean, boolean, java.util.ArrayList, javax.lang.model.element.TypeElement, boolean, io.vertx.codegen.doc.Text, boolean, boolean)
{
javax.lang.model.element.TypeElement v14;
java.util.ArrayList v13;
io.vertx.codegen.doc.Text v16, v6;
java.lang.String v2, v3;
boolean v11, v12, v15, v17, v18, v7, v8;
io.vertx.codegen.type.TypeInfo v5;
javax.lang.model.element.ExecutableElement v10;
java.util.Set v1;
io.vertx.codegen.ClassModel v0;
java.util.List v9;
io.vertx.codegen.doc.Doc v4;
io.vertx.codegen.MethodInfo v19;
v0 := @this: io.vertx.codegen.ClassModel;
v1 := @parameter0: java.util.Set;
v2 := @parameter1: java.lang.String;
v3 := @parameter2: java.lang.String;
v4 := @parameter3: io.vertx.codegen.doc.Doc;
v5 := @parameter4: io.vertx.codegen.type.TypeInfo;
v6 := @parameter5: io.vertx.codegen.doc.Text;
v7 := @parameter6: boolean;
v8 := @parameter7: boolean;
v9 := @parameter8: java.util.List;
v10 := @parameter9: javax.lang.model.element.ExecutableElement;
v11 := @parameter10: boolean;
v12 := @parameter11: boolean;
v13 := @parameter12: java.util.ArrayList;
v14 := @parameter13: javax.lang.model.element.TypeElement;
v15 := @parameter14: boolean;
v16 := @parameter15: io.vertx.codegen.doc.Text;
v17 := @parameter16: boolean;
v18 := @parameter17: boolean;
v19 = new io.vertx.codegen.MethodInfo;
specialinvoke v19.<io.vertx.codegen.MethodInfo: void <init>(java.util.Set,java.lang.String,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.doc.Text,boolean,boolean,java.util.List,java.lang.String,io.vertx.codegen.doc.Doc,boolean,boolean,java.util.List,boolean,io.vertx.codegen.doc.Text,boolean,boolean)>(v1, v2, v5, v6, v7, v8, v9, v3, v4, v11, v12, v13, v15, v16, v17, v18);
return v19;
}
protected void checkMethod(io.vertx.codegen.MethodInfo)
{
io.vertx.codegen.MethodInfo v1;
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
v1 := @parameter0: io.vertx.codegen.MethodInfo;
return;
}
private boolean isObjectBound(javax.lang.model.type.TypeMirror)
{
io.vertx.codegen.ClassModel v0;
javax.lang.model.type.TypeKind v2, v3;
javax.lang.model.type.TypeMirror v1;
java.lang.Class v5;
java.lang.String v4, v6;
boolean v7, v8;
v0 := @this: io.vertx.codegen.ClassModel;
v1 := @parameter0: javax.lang.model.type.TypeMirror;
v2 = interfaceinvoke v1.<javax.lang.model.type.TypeMirror: javax.lang.model.type.TypeKind getKind()>();
v3 = <javax.lang.model.type.TypeKind: javax.lang.model.type.TypeKind DECLARED>;
if v2 != v3 goto label1;
v4 = interfaceinvoke v1.<javax.lang.model.type.TypeMirror: java.lang.String toString()>();
v5 = class "Ljava/lang/Object;";
v6 = virtualinvoke v5.<java.lang.Class: java.lang.String getName()>();
v7 = virtualinvoke v4.<java.lang.String: boolean equals(java.lang.Object)>(v6);
if v7 == 0 goto label1;
v8 = 1;
goto label2;
label1:
v8 = 0;
label2:
return v8;
}
public boolean isDeprecated()
{
io.vertx.codegen.ClassModel v0;
boolean v1;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: boolean deprecated>;
return v1;
}
public io.vertx.codegen.doc.Text getDeprecatedDesc()
{
io.vertx.codegen.doc.Text v1;
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.doc.Text deprecatedDesc>;
return v1;
}
public java.util.Map getVars()
{
io.vertx.codegen.doc.Text v28;
java.util.Map v1, v18, v20;
java.lang.Boolean v27, v4;
java.lang.String v6, v7, v8, v9;
boolean v26, v3;
io.vertx.codegen.type.ClassTypeInfo v5;
io.vertx.codegen.type.TypeInfo v15, v17;
java.util.Set v13, v2, v21, v22;
io.vertx.codegen.ClassModel v0;
java.util.List v11, v12, v14, v16, v19, v23, v24, v25;
io.vertx.codegen.doc.Doc v10;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = specialinvoke v0.<io.vertx.codegen.Model: java.util.Map getVars()>();
v2 = virtualinvoke v0.<io.vertx.codegen.ClassModel: java.util.Set getImportedTypes()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("importedTypes", v2);
v3 = virtualinvoke v0.<io.vertx.codegen.ClassModel: boolean isConcrete()>();
v4 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>(v3);
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("concrete", v4);
v5 = virtualinvoke v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.ClassTypeInfo getType()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("type", v5);
v6 = virtualinvoke v0.<io.vertx.codegen.ClassModel: java.lang.String getIfacePackageName()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("ifacePackageName", v6);
v7 = virtualinvoke v0.<io.vertx.codegen.ClassModel: java.lang.String getIfaceSimpleName()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("ifaceSimpleName", v7);
v8 = virtualinvoke v0.<io.vertx.codegen.ClassModel: java.lang.String getIfaceFQCN()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("ifaceFQCN", v8);
v9 = virtualinvoke v0.<io.vertx.codegen.ClassModel: java.lang.String getIfaceComment()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("ifaceComment", v9);
v10 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.doc.Doc doc>;
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("doc", v10);
v11 = virtualinvoke v0.<io.vertx.codegen.ClassModel: java.util.List getMethods()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("methods", v11);
v12 = virtualinvoke v0.<io.vertx.codegen.ClassModel: java.util.List getConstants()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("constants", v12);
v13 = virtualinvoke v0.<io.vertx.codegen.ClassModel: java.util.Set getReferencedTypes()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("referencedTypes", v13);
v14 = virtualinvoke v0.<io.vertx.codegen.ClassModel: java.util.List getSuperTypes()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("superTypes", v14);
v15 = virtualinvoke v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo getConcreteSuperType()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("concreteSuperType", v15);
v16 = virtualinvoke v0.<io.vertx.codegen.ClassModel: java.util.List getAbstractSuperTypes()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("abstractSuperTypes", v16);
v17 = virtualinvoke v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo getHandlerArg()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("handlerType", v17);
v18 = virtualinvoke v0.<io.vertx.codegen.ClassModel: java.util.Map getMethodMap()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("methodsByName", v18);
v19 = virtualinvoke v0.<io.vertx.codegen.ClassModel: java.util.List getAnnotations()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("classAnnotations", v19);
v20 = virtualinvoke v0.<io.vertx.codegen.ClassModel: java.util.Map getMethodAnnotations()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("annotationsByMethodName", v20);
v21 = virtualinvoke v0.<io.vertx.codegen.ClassModel: java.util.Set getReferencedDataObjectTypes()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("referencedDataObjectTypes", v21);
v22 = virtualinvoke v0.<io.vertx.codegen.ClassModel: java.util.Set getReferencedEnumTypes()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("referencedEnumTypes", v22);
v23 = virtualinvoke v0.<io.vertx.codegen.ClassModel: java.util.List getTypeParams()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("typeParams", v23);
v24 = virtualinvoke v0.<io.vertx.codegen.ClassModel: java.util.List getInstanceMethods()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("instanceMethods", v24);
v25 = virtualinvoke v0.<io.vertx.codegen.ClassModel: java.util.List getStaticMethods()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("staticMethods", v25);
v26 = virtualinvoke v0.<io.vertx.codegen.ClassModel: boolean isDeprecated()>();
v27 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>(v26);
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("deprecated", v27);
v28 = virtualinvoke v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.doc.Text getDeprecatedDesc()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("deprecatedDesc", v28);
return v1;
}
public boolean isHandler()
{
io.vertx.codegen.ClassModel v0;
boolean v2;
io.vertx.codegen.type.TypeInfo v1;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo handlerArg>;
if v1 == null goto label1;
v2 = 1;
goto label2;
label1:
v2 = 0;
label2:
return v2;
}
public io.vertx.codegen.type.TypeInfo getHandlerArg()
{
io.vertx.codegen.ClassModel v0;
io.vertx.codegen.type.TypeInfo v1;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo handlerArg>;
return v1;
}
public boolean isReadStream()
{
io.vertx.codegen.ClassModel v0;
boolean v2;
io.vertx.codegen.type.TypeInfo v1;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo readStreamArg>;
if v1 == null goto label1;
v2 = 1;
goto label2;
label1:
v2 = 0;
label2:
return v2;
}
public io.vertx.codegen.type.TypeInfo getReadStreamArg()
{
io.vertx.codegen.ClassModel v0;
io.vertx.codegen.type.TypeInfo v1;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo readStreamArg>;
return v1;
}
public boolean isWriteStream()
{
io.vertx.codegen.ClassModel v0;
boolean v2;
io.vertx.codegen.type.TypeInfo v1;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo writeStreamArg>;
if v1 == null goto label1;
v2 = 1;
goto label2;
label1:
v2 = 0;
label2:
return v2;
}
public io.vertx.codegen.type.TypeInfo getWriteStreamArg()
{
io.vertx.codegen.ClassModel v0;
io.vertx.codegen.type.TypeInfo v1;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo writeStreamArg>;
return v1;
}
public boolean isIterable()
{
io.vertx.codegen.ClassModel v0;
boolean v2;
io.vertx.codegen.type.TypeInfo v1;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo iterableArg>;
if v1 == null goto label1;
v2 = 1;
goto label2;
label1:
v2 = 0;
label2:
return v2;
}
public io.vertx.codegen.type.TypeInfo getIterableArg()
{
io.vertx.codegen.ClassModel v0;
io.vertx.codegen.type.TypeInfo v1;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo iterableArg>;
return v1;
}
public boolean isIterator()
{
io.vertx.codegen.ClassModel v0;
boolean v2;
io.vertx.codegen.type.TypeInfo v1;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo iteratorArg>;
if v1 == null goto label1;
v2 = 1;
goto label2;
label1:
v2 = 0;
label2:
return v2;
}
public io.vertx.codegen.type.TypeInfo getIteratorArg()
{
io.vertx.codegen.ClassModel v0;
io.vertx.codegen.type.TypeInfo v1;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo iteratorArg>;
return v1;
}
public boolean isFunction()
{
io.vertx.codegen.type.TypeInfo[] v1;
io.vertx.codegen.ClassModel v0;
boolean v2;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo[] functionArgs>;
if v1 == null goto label1;
v2 = 1;
goto label2;
label1:
v2 = 0;
label2:
return v2;
}
public io.vertx.codegen.type.TypeInfo[] getFunctionArgs()
{
io.vertx.codegen.type.TypeInfo[] v1;
io.vertx.codegen.ClassModel v0;
v0 := @this: io.vertx.codegen.ClassModel;
v1 = v0.<io.vertx.codegen.ClassModel: io.vertx.codegen.type.TypeInfo[] functionArgs>;
return v1;
}
static void <clinit>()
{
io.vertx.codegen.type.ClassTypeInfo v3, v8;
io.vertx.codegen.TypeParamInfo$Class[] v10, v5;
java.util.logging.Logger v2;
io.vertx.codegen.TypeParamInfo$Class v11, v6;
java.util.List v12, v7;
java.lang.Class v0;
java.lang.String v1;
io.vertx.codegen.type.ClassKind v4, v9;
v0 = class "Lio/vertx/codegen/ClassModel;";
v1 = virtualinvoke v0.<java.lang.Class: java.lang.String getName()>();
v2 = staticinvoke <java.util.logging.Logger: java.util.logging.Logger getLogger(java.lang.String)>(v1);
<io.vertx.codegen.ClassModel: java.util.logging.Logger logger> = v2;
v3 = new io.vertx.codegen.type.ClassTypeInfo;
v4 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind ASYNC_RESULT>;
v5 = newarray (io.vertx.codegen.TypeParamInfo$Class)[1];
v6 = new io.vertx.codegen.TypeParamInfo$Class;
specialinvoke v6.<io.vertx.codegen.TypeParamInfo$Class: void <init>(java.lang.String,int,java.lang.String)>("io.vertx.core.AsyncResult", 0, "T");
v5[0] = v6;
v7 = staticinvoke <java.util.Arrays: java.util.List asList(java.lang.Object[])>(v5);
specialinvoke v3.<io.vertx.codegen.type.ClassTypeInfo: void <init>(io.vertx.codegen.type.ClassKind,java.lang.String,io.vertx.codegen.ModuleInfo,boolean,java.util.List,io.vertx.codegen.type.DataObjectInfo)>(v4, "io.vertx.core.AsyncResult", null, 0, v7, null);
<io.vertx.codegen.ClassModel: io.vertx.codegen.type.ClassTypeInfo ASYNC_RESULT_TYPE> = v3;
v8 = new io.vertx.codegen.type.ClassTypeInfo;
v9 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind HANDLER>;
v10 = newarray (io.vertx.codegen.TypeParamInfo$Class)[1];
v11 = new io.vertx.codegen.TypeParamInfo$Class;
specialinvoke v11.<io.vertx.codegen.TypeParamInfo$Class: void <init>(java.lang.String,int,java.lang.String)>("io.vertx.core.Handler", 0, "T");
v10[0] = v11;
v12 = staticinvoke <java.util.Arrays: java.util.List asList(java.lang.Object[])>(v10);
specialinvoke v8.<io.vertx.codegen.type.ClassTypeInfo: void <init>(io.vertx.codegen.type.ClassKind,java.lang.String,io.vertx.codegen.ModuleInfo,boolean,java.util.List,io.vertx.codegen.type.DataObjectInfo)>(v9, "io.vertx.core.Handler", null, 0, v12, null);
<io.vertx.codegen.ClassModel: io.vertx.codegen.type.ClassTypeInfo HANDLER_TYPE> = v8;
return;
}
}