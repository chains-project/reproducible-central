public class io.vertx.codegen.CodeGenProcessor extends javax.'annotation'.processing.AbstractProcessor
{
private static final int JAVA;
private static final int RESOURCE;
private static final int OTHER;
private static final java.lang.String JSON_MAPPERS_PROPERTIES_PATH;
public static final java.util.logging.Logger log;
private java.io.File outputDirectory;
private java.util.List codeGenerators;
private java.util.Map generatedFiles;
private java.util.Map generatedResources;
private java.util.Map relocations;
private java.util.Set supportedAnnotation;
private java.util.List mappers;
public void <init>()
{
java.util.HashSet v4;
java.util.HashMap v1, v2, v3;
io.vertx.codegen.CodeGenProcessor v0;
v0 := @this: io.vertx.codegen.CodeGenProcessor;
specialinvoke v0.<javax.'annotation'.processing.AbstractProcessor: void <init>()>();
v1 = new java.util.HashMap;
specialinvoke v1.<java.util.HashMap: void <init>()>();
v0.<io.vertx.codegen.CodeGenProcessor: java.util.Map generatedFiles> = v1;
v2 = new java.util.HashMap;
specialinvoke v2.<java.util.HashMap: void <init>()>();
v0.<io.vertx.codegen.CodeGenProcessor: java.util.Map generatedResources> = v2;
v3 = new java.util.HashMap;
specialinvoke v3.<java.util.HashMap: void <init>()>();
v0.<io.vertx.codegen.CodeGenProcessor: java.util.Map relocations> = v3;
v4 = new java.util.HashSet;
specialinvoke v4.<java.util.HashSet: void <init>()>();
v0.<io.vertx.codegen.CodeGenProcessor: java.util.Set supportedAnnotation> = v4;
return;
}
public java.util.Set getSupportedAnnotationTypes()
{
java.util.stream.Stream v2, v4;
java.util.Set v1;
java.lang.Object v6;
java.util.stream.Collector v5;
io.vertx.codegen.CodeGenProcessor v0;
java.util.function.Function v3;
v0 := @this: io.vertx.codegen.CodeGenProcessor;
v1 = v0.<io.vertx.codegen.CodeGenProcessor: java.util.Set supportedAnnotation>;
v2 = interfaceinvoke v1.<java.util.Set: java.util.stream.Stream stream()>();
v3 = staticinvoke <io.vertx.codegen.CodeGenProcessor$getName__2380: java.util.function.Function bootstrap$()>();
v4 = interfaceinvoke v2.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v3);
v5 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector toSet()>();
v6 = interfaceinvoke v4.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v5);
return v6;
}
public synchronized void init(javax.'annotation'.processing.ProcessingEnvironment)
{
java.util.Collection v7;
java.lang.Class[] v5;
java.util.Set v11;
java.util.function.Function v9;
java.util.HashSet v4;
java.util.function.Consumer v12;
java.util.List v13, v14, v6;
java.util.stream.Stream v10, v8;
java.util.Map v2, v3;
javax.'annotation'.processing.ProcessingEnvironment v1;
io.vertx.codegen.CodeGenProcessor v0;
v0 := @this: io.vertx.codegen.CodeGenProcessor;
v1 := @parameter0: javax.'annotation'.processing.ProcessingEnvironment;
specialinvoke v0.<javax.'annotation'.processing.AbstractProcessor: void init(javax.'annotation'.processing.ProcessingEnvironment)>(v1);
v2 = v0.<io.vertx.codegen.CodeGenProcessor: java.util.Map generatedFiles>;
interfaceinvoke v2.<java.util.Map: void clear()>();
v3 = v0.<io.vertx.codegen.CodeGenProcessor: java.util.Map generatedResources>;
interfaceinvoke v3.<java.util.Map: void clear()>();
v4 = new java.util.HashSet;
v5 = newarray (java.lang.Class)[2];
v5[0] = class "Lio/vertx/codegen/annotations/DataObject;";
v5[1] = class "Lio/vertx/codegen/annotations/VertxGen;";
v6 = staticinvoke <java.util.Arrays: java.util.List asList(java.lang.Object[])>(v5);
specialinvoke v4.<java.util.HashSet: void <init>(java.util.Collection)>(v6);
v0.<io.vertx.codegen.CodeGenProcessor: java.util.Set supportedAnnotation> = v4;
v7 = specialinvoke v0.<io.vertx.codegen.CodeGenProcessor: java.util.Collection getCodeGenerators()>();
v8 = interfaceinvoke v7.<java.util.Collection: java.util.stream.Stream stream()>();
v9 = staticinvoke <io.vertx.codegen.CodeGenProcessor$lambda_init_0__2381: java.util.function.Function bootstrap$()>();
v10 = interfaceinvoke v8.<java.util.stream.Stream: java.util.stream.Stream flatMap(java.util.function.Function)>(v9);
v11 = v0.<io.vertx.codegen.CodeGenProcessor: java.util.Set supportedAnnotation>;
virtualinvoke v11.<java.lang.Object: java.lang.Class getClass()>();
v12 = staticinvoke <io.vertx.codegen.CodeGenProcessor$add__2382: java.util.function.Consumer bootstrap$(java.util.Set)>(v11);
interfaceinvoke v10.<java.util.stream.Stream: void forEach(java.util.function.Consumer)>(v12);
v13 = v0.<io.vertx.codegen.CodeGenProcessor: java.util.List mappers>;
if v13 != null goto label1;
v14 = specialinvoke v0.<io.vertx.codegen.CodeGenProcessor: java.util.List loadJsonMappers()>();
v0.<io.vertx.codegen.CodeGenProcessor: java.util.List mappers> = v14;
label1:
return;
}
private java.util.function.Predicate filterGenerators()
{
java.util.function.Predicate v12;
java.lang.String[] v4;
java.util.function.Function v6, v8;
java.util.stream.Stream v5, v7, v9;
java.util.Map v2;
javax.'annotation'.processing.ProcessingEnvironment v1;
java.lang.Object v11, v3;
java.util.stream.Collector v10;
io.vertx.codegen.CodeGenProcessor v0;
v0 := @this: io.vertx.codegen.CodeGenProcessor;
v1 = v0.<io.vertx.codegen.CodeGenProcessor: javax.'annotation'.processing.ProcessingEnvironment processingEnv>;
v2 = interfaceinvoke v1.<javax.'annotation'.processing.ProcessingEnvironment: java.util.Map getOptions()>();
v3 = interfaceinvoke v2.<java.util.Map: java.lang.Object get(java.lang.Object)>("codegen.generators");
if v3 == null goto label1;
v4 = virtualinvoke v3.<java.lang.String: java.lang.String[] split(java.lang.String)>(",");
v5 = staticinvoke <java.util.stream.Stream: java.util.stream.Stream of(java.lang.Object[])>(v4);
v6 = staticinvoke <io.vertx.codegen.CodeGenProcessor$trim__2383: java.util.function.Function bootstrap$()>();
v7 = interfaceinvoke v5.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v6);
v8 = staticinvoke <io.vertx.codegen.CodeGenProcessor$compile__2384: java.util.function.Function bootstrap$()>();
v9 = interfaceinvoke v7.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v8);
v10 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector toList()>();
v11 = interfaceinvoke v9.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v10);
v12 = staticinvoke <io.vertx.codegen.CodeGenProcessor$lambda_filterGenerators_2__2385: java.util.function.Predicate bootstrap$(java.util.List)>(v11);
return v12;
label1:
return null;
}
private java.util.Collection getCodeGenerators()
{
java.util.Map v3, v34;
java.util.stream.Collector v41, v43;
javax.'annotation'.processing.Messager v11, v17;
boolean v15, v7, v9;
java.util.function.Predicate v30, v37;
java.util.Set v35;
java.util.ServiceLoader v22;
javax.tools.Diagnostic$Kind v12, v18;
java.util.List v1, v45;
java.util.stream.Stream v24, v26, v27, v29, v32, v36, v38;
java.lang.ClassLoader v21;
java.util.Spliterator v23;
java.util.function.Function v28, v39, v40;
java.lang.String v13, v19;
io.vertx.codegen.CodeGenProcessor v0;
io.vertx.codegen.generators.dataobjecthelper.DataObjectHelperGenLoader v25;
java.io.File v14, v5, v6, v8;
java.util.function.Consumer v31;
javax.'annotation'.processing.ProcessingEnvironment v10, v16, v2, v33;
java.lang.Class v20;
java.lang.Object v4, v42, v44;
v0 := @this: io.vertx.codegen.CodeGenProcessor;
v1 = v0.<io.vertx.codegen.CodeGenProcessor: java.util.List codeGenerators>;
if v1 != null goto label4;
v2 = v0.<io.vertx.codegen.CodeGenProcessor: javax.'annotation'.processing.ProcessingEnvironment processingEnv>;
v3 = interfaceinvoke v2.<javax.'annotation'.processing.ProcessingEnvironment: java.util.Map getOptions()>();
v4 = interfaceinvoke v3.<java.util.Map: java.lang.Object get(java.lang.Object)>("codegen.output");
if v4 == null goto label2;
v5 = new java.io.File;
specialinvoke v5.<java.io.File: void <init>(java.lang.String)>(v4);
v0.<io.vertx.codegen.CodeGenProcessor: java.io.File outputDirectory> = v5;
v6 = v0.<io.vertx.codegen.CodeGenProcessor: java.io.File outputDirectory>;
v7 = virtualinvoke v6.<java.io.File: boolean exists()>();
if v7 != 0 goto label1;
v8 = v0.<io.vertx.codegen.CodeGenProcessor: java.io.File outputDirectory>;
v9 = virtualinvoke v8.<java.io.File: boolean mkdirs()>();
if v9 != 0 goto label1;
v10 = v0.<io.vertx.codegen.CodeGenProcessor: javax.'annotation'.processing.ProcessingEnvironment processingEnv>;
v11 = interfaceinvoke v10.<javax.'annotation'.processing.ProcessingEnvironment: javax.'annotation'.processing.Messager getMessager()>();
v12 = <javax.tools.Diagnostic$Kind: javax.tools.Diagnostic$Kind ERROR>;
v13 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v4) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Output directory \u0001 does not exist");
interfaceinvoke v11.<javax.'annotation'.processing.Messager: void printMessage(javax.tools.Diagnostic$Kind,java.lang.CharSequence)>(v12, v13);
label1:
v14 = v0.<io.vertx.codegen.CodeGenProcessor: java.io.File outputDirectory>;
v15 = virtualinvoke v14.<java.io.File: boolean isDirectory()>();
if v15 != 0 goto label2;
v16 = v0.<io.vertx.codegen.CodeGenProcessor: javax.'annotation'.processing.ProcessingEnvironment processingEnv>;
v17 = interfaceinvoke v16.<javax.'annotation'.processing.ProcessingEnvironment: javax.'annotation'.processing.Messager getMessager()>();
v18 = <javax.tools.Diagnostic$Kind: javax.tools.Diagnostic$Kind ERROR>;
v19 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v4) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Output directory \u0001 is not a directory");
interfaceinvoke v17.<javax.'annotation'.processing.Messager: void printMessage(javax.tools.Diagnostic$Kind,java.lang.CharSequence)>(v18, v19);
label2:
v20 = class "Lio/vertx/codegen/CodeGenProcessor;";
v21 = virtualinvoke v20.<java.lang.Class: java.lang.ClassLoader getClassLoader()>();
v22 = staticinvoke <java.util.ServiceLoader: java.util.ServiceLoader load(java.lang.Class,java.lang.ClassLoader)>(class "Lio/vertx/codegen/GeneratorLoader;", v21);
v23 = virtualinvoke v22.<java.util.ServiceLoader: java.util.Spliterator spliterator()>();
v24 = staticinvoke <java.util.stream.StreamSupport: java.util.stream.Stream stream(java.util.Spliterator,boolean)>(v23, 0);
v25 = new io.vertx.codegen.generators.dataobjecthelper.DataObjectHelperGenLoader;
specialinvoke v25.<io.vertx.codegen.generators.dataobjecthelper.DataObjectHelperGenLoader: void <init>()>();
v26 = staticinvoke <java.util.stream.Stream: java.util.stream.Stream of(java.lang.Object)>(v25);
v27 = staticinvoke <java.util.stream.Stream: java.util.stream.Stream concat(java.util.stream.Stream,java.util.stream.Stream)>(v24, v26);
v28 = staticinvoke <io.vertx.codegen.CodeGenProcessor$lambda_getCodeGenerators_3__2386: java.util.function.Function bootstrap$(io.vertx.codegen.CodeGenProcessor)>(v0);
v29 = interfaceinvoke v27.<java.util.stream.Stream: java.util.stream.Stream flatMap(java.util.function.Function)>(v28);
v30 = specialinvoke v0.<io.vertx.codegen.CodeGenProcessor: java.util.function.Predicate filterGenerators()>();
if v30 == null goto label3;
v29 = interfaceinvoke v29.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v30);
label3:
v31 = staticinvoke <io.vertx.codegen.CodeGenProcessor$lambda_getCodeGenerators_4__2387: java.util.function.Consumer bootstrap$(io.vertx.codegen.CodeGenProcessor)>(v0);
v32 = interfaceinvoke v29.<java.util.stream.Stream: java.util.stream.Stream peek(java.util.function.Consumer)>(v31);
v33 = v0.<io.vertx.codegen.CodeGenProcessor: javax.'annotation'.processing.ProcessingEnvironment processingEnv>;
v34 = interfaceinvoke v33.<javax.'annotation'.processing.ProcessingEnvironment: java.util.Map getOptions()>();
v35 = interfaceinvoke v34.<java.util.Map: java.util.Set entrySet()>();
v36 = interfaceinvoke v35.<java.util.Set: java.util.stream.Stream stream()>();
v37 = staticinvoke <io.vertx.codegen.CodeGenProcessor$lambda_getCodeGenerators_5__2388: java.util.function.Predicate bootstrap$()>();
v38 = interfaceinvoke v36.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v37);
v39 = staticinvoke <io.vertx.codegen.CodeGenProcessor$lambda_getCodeGenerators_6__2389: java.util.function.Function bootstrap$()>();
v40 = staticinvoke <io.vertx.codegen.CodeGenProcessor$getValue__2390: java.util.function.Function bootstrap$()>();
v41 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector toMap(java.util.function.Function,java.util.function.Function)>(v39, v40);
v42 = interfaceinvoke v38.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v41);
v0.<io.vertx.codegen.CodeGenProcessor: java.util.Map relocations> = v42;
v43 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector toList()>();
v44 = interfaceinvoke v32.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v43);
v0.<io.vertx.codegen.CodeGenProcessor: java.util.List codeGenerators> = v44;
label4:
v45 = v0.<io.vertx.codegen.CodeGenProcessor: java.util.List codeGenerators>;
return v45;
}
private static void loadJsonMappers(java.util.List, java.io.InputStream) throws java.io.IOException
{
java.util.function.Consumer v4;
java.util.List v0;
java.util.Properties v2;
java.util.Set v3;
java.io.InputStream v1;
v0 := @parameter0: java.util.List;
v1 := @parameter1: java.io.InputStream;
v2 = new java.util.Properties;
specialinvoke v2.<java.util.Properties: void <init>()>();
virtualinvoke v2.<java.util.Properties: void load(java.io.InputStream)>(v1);
v3 = virtualinvoke v2.<java.util.Properties: java.util.Set stringPropertyNames()>();
v4 = staticinvoke <io.vertx.codegen.CodeGenProcessor$lambda_loadJsonMappers_7__2391: java.util.function.Consumer bootstrap$(java.util.Properties,java.util.List)>(v2, v0);
interfaceinvoke v3.<java.util.Set: void forEach(java.util.function.Consumer)>(v4);
return;
}
private java.nio.file.Path determineSourcePathInEclipse()
{
java.lang.String v4, v7, v8;
java.net.URI v12;
io.vertx.codegen.CodeGenProcessor v0;
java.nio.file.Path v13, v14;
javax.'annotation'.processing.Messager v17;
boolean v5;
java.io.IOException v15;
java.io.File v11;
javax.tools.Diagnostic$Kind v18;
javax.tools.JavaFileObject v10;
javax.'annotation'.processing.Filer v2;
javax.'annotation'.processing.ProcessingEnvironment v1, v16;
java.lang.Class v3, v6;
javax.lang.model.element.Element[] v9;
v0 := @this: io.vertx.codegen.CodeGenProcessor;
label1:
v1 = v0.<io.vertx.codegen.CodeGenProcessor: javax.'annotation'.processing.ProcessingEnvironment processingEnv>;
v2 = interfaceinvoke v1.<javax.'annotation'.processing.ProcessingEnvironment: javax.'annotation'.processing.Filer getFiler()>();
v3 = virtualinvoke v2.<java.lang.Object: java.lang.Class getClass()>();
v4 = virtualinvoke v3.<java.lang.Class: java.lang.String getName()>();
v5 = virtualinvoke v4.<java.lang.String: boolean startsWith(java.lang.String)>("com.sun.tools.javac");
if v5 != 0 goto label4;
v6 = virtualinvoke v0.<java.lang.Object: java.lang.Class getClass()>();
v7 = virtualinvoke v6.<java.lang.Class: java.lang.String getSimpleName()>();
v8 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v7) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("PathFor\u0001");
v9 = newarray (javax.lang.model.element.Element)[0];
v10 = interfaceinvoke v2.<javax.'annotation'.processing.Filer: javax.tools.JavaFileObject createClassFile(java.lang.CharSequence,javax.lang.model.element.Element[])>(v8, v9);
v11 = new java.io.File;
v12 = interfaceinvoke v10.<javax.tools.JavaFileObject: java.net.URI toUri()>();
specialinvoke v11.<java.io.File: void <init>(java.net.URI)>(v12);
v13 = virtualinvoke v11.<java.io.File: java.nio.file.Path toPath()>();
v14 = interfaceinvoke v13.<java.nio.file.Path: java.nio.file.Path getParent()>();
label2:
return v14;
label3:
v15 := @caughtexception;
v16 = v0.<io.vertx.codegen.CodeGenProcessor: javax.'annotation'.processing.ProcessingEnvironment processingEnv>;
v17 = interfaceinvoke v16.<javax.'annotation'.processing.ProcessingEnvironment: javax.'annotation'.processing.Messager getMessager()>();
v18 = <javax.tools.Diagnostic$Kind: javax.tools.Diagnostic$Kind WARNING>;
interfaceinvoke v17.<javax.'annotation'.processing.Messager: void printMessage(javax.tools.Diagnostic$Kind,java.lang.CharSequence)>(v18, "Unable to determine source file path!");
label4:
return null;
catch java.io.IOException from label1 to label2 with label3;
}
private java.util.List loadJsonMappers()
{
java.util.Enumeration v16;
javax.tools.FileObject v9;
java.util.Map v49;
java.nio.file.Path v26, v27, v28, v29, v30, v63, v64, v65;
java.lang.Exception v1, v13;
javax.tools.Diagnostic$Kind v22, v38, v46, v73, v81;
java.lang.ClassLoader v15;
java.lang.Throwable v12, v24, v40, v75;
java.util.ArrayList v2;
java.lang.String v23, v39, v47, v51, v52, v54, v62, v74, v82;
io.vertx.codegen.CodeGenProcessor v0;
java.io.IOException v11, v25, v41, v76;
java.io.File v31, v58, v66;
java.net.URL v34, v69;
java.util.Locale v53;
java.net.URI v33, v68;
javax.'annotation'.processing.Messager v21, v37, v45, v72, v80;
boolean v17, v32, v55, v57, v67;
javax.tools.StandardLocation v6;
java.util.logging.Logger v42, v77;
javax.tools.StandardLocation[] v3;
javax.'annotation'.processing.Filer v8;
java.util.logging.Level v43, v78;
int v4, v5, v59, v60, v61;
char v56;
javax.'annotation'.processing.ProcessingEnvironment v20, v36, v44, v48, v7, v71, v79;
java.lang.Class v14;
java.lang.Object v18, v50;
java.io.InputStream v10, v19, v35, v70;
v0 := @this: io.vertx.codegen.CodeGenProcessor;
v1 = null;
v2 = new java.util.ArrayList;
specialinvoke v2.<java.util.ArrayList: void <init>()>();
v3 = staticinvoke <javax.tools.StandardLocation: javax.tools.StandardLocation[] values()>();
v4 = lengthof v3;
v5 = 0;
label01:
if v5 >= v4 goto label10;
v6 = v3[v5];
label02:
v7 = v0.<io.vertx.codegen.CodeGenProcessor: javax.'annotation'.processing.ProcessingEnvironment processingEnv>;
v8 = interfaceinvoke v7.<javax.'annotation'.processing.ProcessingEnvironment: javax.'annotation'.processing.Filer getFiler()>();
v9 = interfaceinvoke v8.<javax.'annotation'.processing.Filer: javax.tools.FileObject getResource(javax.tools.JavaFileManager$Location,java.lang.CharSequence,java.lang.CharSequence)>(v6, "", "META-INF/vertx/json-mappers.properties");
v10 = interfaceinvoke v9.<javax.tools.FileObject: java.io.InputStream openInputStream()>();
label03:
staticinvoke <io.vertx.codegen.CodeGenProcessor: void loadJsonMappers(java.util.List,java.io.InputStream)>(v2, v10);
v1 = null;
label04:
goto label06;
label05:
v11 := @caughtexception;
v1 = v11;
label06:
if v10 == null goto label09;
virtualinvoke v10.<java.io.InputStream: void close()>();
goto label09;
label07:
v12 := @caughtexception;
throw v12;
label08:
v13 := @caughtexception;
v1 = v13;
label09:
v5 = v5 + 1;
goto label01;
label10:
if v1 == null goto label30;
label11:
v14 = virtualinvoke v0.<java.lang.Object: java.lang.Class getClass()>();
v15 = virtualinvoke v14.<java.lang.Class: java.lang.ClassLoader getClassLoader()>();
v16 = virtualinvoke v15.<java.lang.ClassLoader: java.util.Enumeration getResources(java.lang.String)>("META-INF/vertx/json-mappers.properties");
label12:
v17 = interfaceinvoke v16.<java.util.Enumeration: boolean hasMoreElements()>();
if v17 == 0 goto label17;
v18 = interfaceinvoke v16.<java.util.Enumeration: java.lang.Object nextElement()>();
v19 = virtualinvoke v18.<java.net.URL: java.io.InputStream openStream()>();
label13:
staticinvoke <io.vertx.codegen.CodeGenProcessor: void loadJsonMappers(java.util.List,java.io.InputStream)>(v2, v19);
v1 = null;
v20 = v0.<io.vertx.codegen.CodeGenProcessor: javax.'annotation'.processing.ProcessingEnvironment processingEnv>;
v21 = interfaceinvoke v20.<javax.'annotation'.processing.ProcessingEnvironment: javax.'annotation'.processing.Messager getMessager()>();
v22 = <javax.tools.Diagnostic$Kind: javax.tools.Diagnostic$Kind NOTE>;
v23 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.net.URL)>(v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Loaded json-mappers.properties \u0001");
interfaceinvoke v21.<javax.'annotation'.processing.Messager: void printMessage(javax.tools.Diagnostic$Kind,java.lang.CharSequence)>(v22, v23);
label14:
if v19 == null goto label12;
virtualinvoke v19.<java.io.InputStream: void close()>();
goto label12;
label15:
v24 := @caughtexception;
throw v24;
label16:
v25 := @caughtexception;
v1 = v25;
label17:
if v1 == null goto label30;
v26 = specialinvoke v0.<io.vertx.codegen.CodeGenProcessor: java.nio.file.Path determineSourcePathInEclipse()>();
if v26 == null goto label23;
v27 = interfaceinvoke v26.<java.nio.file.Path: java.nio.file.Path getParent()>();
v28 = interfaceinvoke v27.<java.nio.file.Path: java.nio.file.Path getParent()>();
v29 = interfaceinvoke v28.<java.nio.file.Path: java.nio.file.Path resolve(java.lang.String)>("src/main/resources");
v30 = interfaceinvoke v29.<java.nio.file.Path: java.nio.file.Path resolve(java.lang.String)>("META-INF/vertx/json-mappers.properties");
v31 = interfaceinvoke v30.<java.nio.file.Path: java.io.File toFile()>();
v32 = virtualinvoke v31.<java.io.File: boolean exists()>();
if v32 == 0 goto label23;
label18:
v33 = interfaceinvoke v30.<java.nio.file.Path: java.net.URI toUri()>();
v34 = virtualinvoke v33.<java.net.URI: java.net.URL toURL()>();
v35 = virtualinvoke v34.<java.net.URL: java.io.InputStream openStream()>();
label19:
staticinvoke <io.vertx.codegen.CodeGenProcessor: void loadJsonMappers(java.util.List,java.io.InputStream)>(v2, v35);
v36 = v0.<io.vertx.codegen.CodeGenProcessor: javax.'annotation'.processing.ProcessingEnvironment processingEnv>;
v37 = interfaceinvoke v36.<javax.'annotation'.processing.ProcessingEnvironment: javax.'annotation'.processing.Messager getMessager()>();
v38 = <javax.tools.Diagnostic$Kind: javax.tools.Diagnostic$Kind NOTE>;
v39 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.file.Path)>(v30) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Loaded json-mappers.properties from \'\u0001\'");
interfaceinvoke v37.<javax.'annotation'.processing.Messager: void printMessage(javax.tools.Diagnostic$Kind,java.lang.CharSequence)>(v38, v39);
label20:
if v35 == null goto label23;
virtualinvoke v35.<java.io.InputStream: void close()>();
goto label23;
label21:
v40 := @caughtexception;
throw v40;
label22:
v41 := @caughtexception;
v42 = <io.vertx.codegen.CodeGenProcessor: java.util.logging.Logger log>;
v43 = <java.util.logging.Level: java.util.logging.Level SEVERE>;
virtualinvoke v42.<java.util.logging.Logger: void log(java.util.logging.Level,java.lang.String,java.lang.Throwable)>(v43, "Could not load json-mappers.properties", v41);
v44 = v0.<io.vertx.codegen.CodeGenProcessor: javax.'annotation'.processing.ProcessingEnvironment processingEnv>;
v45 = interfaceinvoke v44.<javax.'annotation'.processing.ProcessingEnvironment: javax.'annotation'.processing.Messager getMessager()>();
v46 = <javax.tools.Diagnostic$Kind: javax.tools.Diagnostic$Kind WARNING>;
v47 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.file.Path)>(v30) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Unable to open properties file at \u0001");
interfaceinvoke v45.<javax.'annotation'.processing.Messager: void printMessage(javax.tools.Diagnostic$Kind,java.lang.CharSequence)>(v46, v47);
label23:
if v1 == null goto label30;
v48 = v0.<io.vertx.codegen.CodeGenProcessor: javax.'annotation'.processing.ProcessingEnvironment processingEnv>;
v49 = interfaceinvoke v48.<javax.'annotation'.processing.ProcessingEnvironment: java.util.Map getOptions()>();
v50 = interfaceinvoke v49.<java.util.Map: java.lang.Object get(java.lang.Object)>("kapt.kotlin.generated");
v51 = "/build/generated/source/kaptKotlin/main";
v52 = staticinvoke <java.lang.System: java.lang.String getProperty(java.lang.String)>("os.name");
v53 = <java.util.Locale: java.util.Locale US>;
v54 = virtualinvoke v52.<java.lang.String: java.lang.String toLowerCase(java.util.Locale)>(v53);
v55 = virtualinvoke v54.<java.lang.String: boolean contains(java.lang.CharSequence)>("win");
if v55 == 0 goto label24;
v56 = <java.io.File: char separatorChar>;
v51 = virtualinvoke v51.<java.lang.String: java.lang.String replace(char,char)>(47, v56);
label24:
if v50 == null goto label30;
v57 = virtualinvoke v50.<java.lang.String: boolean endsWith(java.lang.String)>(v51);
if v57 == 0 goto label30;
v58 = new java.io.File;
v59 = virtualinvoke v50.<java.lang.String: int length()>();
v60 = virtualinvoke v51.<java.lang.String: int length()>();
v61 = v59 - v60;
v62 = virtualinvoke v50.<java.lang.String: java.lang.String substring(int,int)>(0, v61);
specialinvoke v58.<java.io.File: void <init>(java.lang.String)>(v62);
v63 = virtualinvoke v58.<java.io.File: java.nio.file.Path toPath()>();
v64 = interfaceinvoke v63.<java.nio.file.Path: java.nio.file.Path resolve(java.lang.String)>("src/main/resources");
v65 = interfaceinvoke v64.<java.nio.file.Path: java.nio.file.Path resolve(java.lang.String)>("META-INF/vertx/json-mappers.properties");
v66 = interfaceinvoke v65.<java.nio.file.Path: java.io.File toFile()>();
v67 = virtualinvoke v66.<java.io.File: boolean exists()>();
if v67 == 0 goto label30;
label25:
v68 = interfaceinvoke v65.<java.nio.file.Path: java.net.URI toUri()>();
v69 = virtualinvoke v68.<java.net.URI: java.net.URL toURL()>();
v70 = virtualinvoke v69.<java.net.URL: java.io.InputStream openStream()>();
label26:
staticinvoke <io.vertx.codegen.CodeGenProcessor: void loadJsonMappers(java.util.List,java.io.InputStream)>(v2, v70);
v71 = v0.<io.vertx.codegen.CodeGenProcessor: javax.'annotation'.processing.ProcessingEnvironment processingEnv>;
v72 = interfaceinvoke v71.<javax.'annotation'.processing.ProcessingEnvironment: javax.'annotation'.processing.Messager getMessager()>();
v73 = <javax.tools.Diagnostic$Kind: javax.tools.Diagnostic$Kind NOTE>;
v74 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.file.Path)>(v65) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Loaded json-mappers.properties from \'\u0001\'");
interfaceinvoke v72.<javax.'annotation'.processing.Messager: void printMessage(javax.tools.Diagnostic$Kind,java.lang.CharSequence)>(v73, v74);
label27:
if v70 == null goto label30;
virtualinvoke v70.<java.io.InputStream: void close()>();
goto label30;
label28:
v75 := @caughtexception;
throw v75;
label29:
v76 := @caughtexception;
v77 = <io.vertx.codegen.CodeGenProcessor: java.util.logging.Logger log>;
v78 = <java.util.logging.Level: java.util.logging.Level SEVERE>;
virtualinvoke v77.<java.util.logging.Logger: void log(java.util.logging.Level,java.lang.String,java.lang.Throwable)>(v78, "Could not load json-mappers.properties", v76);
v79 = v0.<io.vertx.codegen.CodeGenProcessor: javax.'annotation'.processing.ProcessingEnvironment processingEnv>;
v80 = interfaceinvoke v79.<javax.'annotation'.processing.ProcessingEnvironment: javax.'annotation'.processing.Messager getMessager()>();
v81 = <javax.tools.Diagnostic$Kind: javax.tools.Diagnostic$Kind WARNING>;
v82 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.nio.file.Path)>(v65) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Unable to open properties file at \u0001");
interfaceinvoke v80.<javax.'annotation'.processing.Messager: void printMessage(javax.tools.Diagnostic$Kind,java.lang.CharSequence)>(v81, v82);
label30:
return v2;
catch java.io.IOException from label03 to label04 with label05;
catch java.lang.Throwable from label03 to label06 with label07;
catch java.lang.Exception from label02 to label08 with label08;
catch java.lang.Throwable from label13 to label14 with label15;
catch java.io.IOException from label11 to label16 with label16;
catch java.lang.Throwable from label19 to label20 with label21;
catch java.io.IOException from label18 to label22 with label22;
catch java.lang.Throwable from label26 to label27 with label28;
catch java.io.IOException from label25 to label29 with label29;
}
public boolean process(java.util.Set, javax.'annotation'.processing.RoundEnvironment)
{
io.vertx.codegen.Model v50, v57;
javax.tools.FileObject v29, v43;
java.util.Map v17, v59;
javax.'annotation'.processing.Messager v47;
boolean v20, v3, v36, v5;
javax.tools.StandardLocation v26, v34, v40;
java.util.Collection v15, v18, v4, v60;
java.util.Set v1;
javax.lang.model.element.Element v58;
java.lang.Exception v55;
javax.tools.Diagnostic$Kind v48;
java.util.List v8;
java.util.stream.Stream v13;
javax.'annotation'.processing.FilerException v37;
javax.'annotation'.processing.Filer v25, v33, v39;
java.io.Writer v30, v44;
java.lang.ClassLoader v11;
javax.lang.model.element.Element[] v28, v42;
java.lang.Throwable v31, v45;
java.util.HashMap v12;
io.vertx.codegen.GenException v54;
int v23;
java.lang.String v22, v27, v35, v41, v51, v52, v53;
io.vertx.codegen.CodeGenProcessor v0;
io.vertx.codegen.CodeGen v6;
java.util.Iterator v19;
java.util.function.Consumer v14, v16, v61, v9;
javax.'annotation'.processing.RoundEnvironment v2;
javax.'annotation'.processing.ProcessingEnvironment v24, v32, v38, v46, v7;
java.lang.Class v10;
java.lang.Object v21, v49, v56;
v0 := @this: io.vertx.codegen.CodeGenProcessor;
v1 := @parameter0: java.util.Set;
v2 := @parameter1: javax.'annotation'.processing.RoundEnvironment;
v3 = interfaceinvoke v2.<javax.'annotation'.processing.RoundEnvironment: boolean processingOver()>();
if v3 != 0 goto label01;
v4 = specialinvoke v0.<io.vertx.codegen.CodeGenProcessor: java.util.Collection getCodeGenerators()>();
v5 = interfaceinvoke v2.<javax.'annotation'.processing.RoundEnvironment: boolean errorRaised()>();
if v5 != 0 goto label19;
v6 = new io.vertx.codegen.CodeGen;
v7 = v0.<io.vertx.codegen.CodeGenProcessor: javax.'annotation'.processing.ProcessingEnvironment processingEnv>;
specialinvoke v6.<io.vertx.codegen.CodeGen: void <init>(javax.'annotation'.processing.ProcessingEnvironment)>(v7);
v8 = v0.<io.vertx.codegen.CodeGenProcessor: java.util.List mappers>;
virtualinvoke v6.<java.lang.Object: java.lang.Class getClass()>();
v9 = staticinvoke <io.vertx.codegen.CodeGenProcessor$registerConverter__2393: java.util.function.Consumer bootstrap$(io.vertx.codegen.CodeGen)>(v6);
interfaceinvoke v8.<java.util.List: void forEach(java.util.function.Consumer)>(v9);
v10 = virtualinvoke v0.<java.lang.Object: java.lang.Class getClass()>();
v11 = virtualinvoke v10.<java.lang.Class: java.lang.ClassLoader getClassLoader()>();
virtualinvoke v6.<io.vertx.codegen.CodeGen: void init(javax.'annotation'.processing.RoundEnvironment,java.lang.ClassLoader)>(v2, v11);
v12 = new java.util.HashMap;
specialinvoke v12.<java.util.HashMap: void <init>()>();
v13 = virtualinvoke v6.<io.vertx.codegen.CodeGen: java.util.stream.Stream getModels()>();
v14 = staticinvoke <io.vertx.codegen.CodeGenProcessor$lambda_process_8__2394: java.util.function.Consumer bootstrap$(io.vertx.codegen.CodeGenProcessor,java.util.Collection,java.util.Map)>(v0, v4, v12);
interfaceinvoke v13.<java.util.stream.Stream: void forEach(java.util.function.Consumer)>(v14);
v15 = interfaceinvoke v12.<java.util.Map: java.util.Collection values()>();
v16 = staticinvoke <io.vertx.codegen.CodeGenProcessor$lambda_process_9__2395: java.util.function.Consumer bootstrap$(io.vertx.codegen.CodeGenProcessor)>(v0);
interfaceinvoke v15.<java.util.Collection: void forEach(java.util.function.Consumer)>(v16);
goto label19;
label01:
v17 = v0.<io.vertx.codegen.CodeGenProcessor: java.util.Map generatedResources>;
v18 = interfaceinvoke v17.<java.util.Map: java.util.Collection values()>();
v19 = interfaceinvoke v18.<java.util.Collection: java.util.Iterator iterator()>();
label02:
v20 = interfaceinvoke v19.<java.util.Iterator: boolean hasNext()>();
if v20 == 0 goto label18;
v21 = interfaceinvoke v19.<java.util.Iterator: java.lang.Object next()>();
label03:
v22 = virtualinvoke v21.<io.vertx.codegen.CodeGenProcessor$GeneratedFile: java.lang.String generate()>();
v23 = virtualinvoke v22.<java.lang.String: int length()>();
if v23 <= 0 goto label02;
v24 = v0.<io.vertx.codegen.CodeGenProcessor: javax.'annotation'.processing.ProcessingEnvironment processingEnv>;
v25 = interfaceinvoke v24.<javax.'annotation'.processing.ProcessingEnvironment: javax.'annotation'.processing.Filer getFiler()>();
v26 = <javax.tools.StandardLocation: javax.tools.StandardLocation CLASS_OUTPUT>;
v27 = v21.<io.vertx.codegen.CodeGenProcessor$GeneratedFile: java.lang.String uri>;
v28 = newarray (javax.lang.model.element.Element)[0];
v29 = interfaceinvoke v25.<javax.'annotation'.processing.Filer: javax.tools.FileObject createResource(javax.tools.JavaFileManager$Location,java.lang.CharSequence,java.lang.CharSequence,javax.lang.model.element.Element[])>(v26, "", v27, v28);
v30 = interfaceinvoke v29.<javax.tools.FileObject: java.io.Writer openWriter()>();
label04:
virtualinvoke v30.<java.io.Writer: void write(java.lang.String)>(v22);
label05:
virtualinvoke v30.<java.io.Writer: void close()>();
goto label07;
label06:
v31 := @caughtexception;
throw v31;
label07:
v32 = v0.<io.vertx.codegen.CodeGenProcessor: javax.'annotation'.processing.ProcessingEnvironment processingEnv>;
v33 = interfaceinvoke v32.<javax.'annotation'.processing.ProcessingEnvironment: javax.'annotation'.processing.Filer getFiler()>();
v34 = <javax.tools.StandardLocation: javax.tools.StandardLocation SOURCE_OUTPUT>;
v35 = v21.<io.vertx.codegen.CodeGenProcessor$GeneratedFile: java.lang.String uri>;
interfaceinvoke v33.<javax.'annotation'.processing.Filer: javax.tools.FileObject getResource(javax.tools.JavaFileManager$Location,java.lang.CharSequence,java.lang.CharSequence)>(v34, "", v35);
v36 = 1;
label08:
goto label10;
label09:
v37 := @caughtexception;
v36 = 0;
label10:
if v36 == 0 goto label14;
v38 = v0.<io.vertx.codegen.CodeGenProcessor: javax.'annotation'.processing.ProcessingEnvironment processingEnv>;
v39 = interfaceinvoke v38.<javax.'annotation'.processing.ProcessingEnvironment: javax.'annotation'.processing.Filer getFiler()>();
v40 = <javax.tools.StandardLocation: javax.tools.StandardLocation SOURCE_OUTPUT>;
v41 = v21.<io.vertx.codegen.CodeGenProcessor$GeneratedFile: java.lang.String uri>;
v42 = newarray (javax.lang.model.element.Element)[0];
v43 = interfaceinvoke v39.<javax.'annotation'.processing.Filer: javax.tools.FileObject createResource(javax.tools.JavaFileManager$Location,java.lang.CharSequence,java.lang.CharSequence,javax.lang.model.element.Element[])>(v40, "", v41, v42);
v44 = interfaceinvoke v43.<javax.tools.FileObject: java.io.Writer openWriter()>();
label11:
virtualinvoke v44.<java.io.Writer: void write(java.lang.String)>(v22);
label12:
virtualinvoke v44.<java.io.Writer: void close()>();
goto label14;
label13:
v45 := @caughtexception;
throw v45;
label14:
v46 = v0.<io.vertx.codegen.CodeGenProcessor: javax.'annotation'.processing.ProcessingEnvironment processingEnv>;
v47 = interfaceinvoke v46.<javax.'annotation'.processing.ProcessingEnvironment: javax.'annotation'.processing.Messager getMessager()>();
v48 = <javax.tools.Diagnostic$Kind: javax.tools.Diagnostic$Kind NOTE>;
v49 = virtualinvoke v21.<io.vertx.codegen.CodeGenProcessor$GeneratedFile: java.lang.Object get(int)>(0);
v50 = v49.<io.vertx.codegen.CodeGenProcessor$ModelProcessing: io.vertx.codegen.Model model>;
v51 = interfaceinvoke v50.<io.vertx.codegen.Model: java.lang.String getFqn()>();
v52 = v21.<io.vertx.codegen.CodeGenProcessor$GeneratedFile: java.lang.String uri>;
v53 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v51, v52) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Generated model \u0001: \u0001");
interfaceinvoke v47.<javax.'annotation'.processing.Messager: void printMessage(javax.tools.Diagnostic$Kind,java.lang.CharSequence)>(v48, v53);
label15:
goto label02;
label16:
v54 := @caughtexception;
specialinvoke v0.<io.vertx.codegen.CodeGenProcessor: void reportGenException(io.vertx.codegen.GenException)>(v54);
goto label02;
label17:
v55 := @caughtexception;
v56 = virtualinvoke v21.<io.vertx.codegen.CodeGenProcessor$GeneratedFile: java.lang.Object get(int)>(0);
v57 = v56.<io.vertx.codegen.CodeGenProcessor$ModelProcessing: io.vertx.codegen.Model model>;
v58 = interfaceinvoke v57.<io.vertx.codegen.Model: javax.lang.model.element.Element getElement()>();
specialinvoke v0.<io.vertx.codegen.CodeGenProcessor: void reportException(java.lang.Exception,javax.lang.model.element.Element)>(v55, v58);
goto label02;
label18:
v59 = v0.<io.vertx.codegen.CodeGenProcessor: java.util.Map generatedFiles>;
v60 = interfaceinvoke v59.<java.util.Map: java.util.Collection values()>();
v61 = staticinvoke <io.vertx.codegen.CodeGenProcessor$lambda_process_10__2392: java.util.function.Consumer bootstrap$(io.vertx.codegen.CodeGenProcessor)>(v0);
interfaceinvoke v60.<java.util.Collection: void forEach(java.util.function.Consumer)>(v61);
label19:
return 1;
catch java.lang.Throwable from label04 to label05 with label06;
catch javax.'annotation'.processing.FilerException from label07 to label08 with label09;
catch java.lang.Throwable from label11 to label12 with label13;
catch io.vertx.codegen.GenException from label03 to label15 with label16;
catch java.lang.Exception from label03 to label15 with label17;
}
private void reportGenException(io.vertx.codegen.GenException)
{
java.util.logging.Level v12;
io.vertx.codegen.GenException v1;
java.lang.String v10, v3, v9;
io.vertx.codegen.CodeGenProcessor v0;
javax.'annotation'.processing.Messager v14;
javax.lang.model.element.ElementKind v5, v6;
javax.lang.model.element.Element v16, v2, v4, v7, v8;
java.util.logging.Logger v11;
javax.tools.Diagnostic$Kind v15;
javax.'annotation'.processing.ProcessingEnvironment v13;
v0 := @this: io.vertx.codegen.CodeGenProcessor;
v1 := @parameter0: io.vertx.codegen.GenException;
v2 = v1.<io.vertx.codegen.GenException: javax.lang.model.element.Element element>;
v3 = virtualinvoke v2.<java.lang.Object: java.lang.String toString()>();
v4 = v1.<io.vertx.codegen.GenException: javax.lang.model.element.Element element>;
v5 = interfaceinvoke v4.<javax.lang.model.element.Element: javax.lang.model.element.ElementKind getKind()>();
v6 = <javax.lang.model.element.ElementKind: javax.lang.model.element.ElementKind METHOD>;
if v5 != v6 goto label1;
v7 = v1.<io.vertx.codegen.GenException: javax.lang.model.element.Element element>;
v8 = interfaceinvoke v7.<javax.lang.model.element.Element: javax.lang.model.element.Element getEnclosingElement()>();
v3 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (javax.lang.model.element.Element,java.lang.String)>(v8, v3) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001#\u0001");
label1:
v9 = v1.<io.vertx.codegen.GenException: java.lang.String msg>;
v10 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v3, v9) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Could not generate model for \u0001: \u0001");
v11 = <io.vertx.codegen.CodeGenProcessor: java.util.logging.Logger log>;
v12 = <java.util.logging.Level: java.util.logging.Level SEVERE>;
virtualinvoke v11.<java.util.logging.Logger: void log(java.util.logging.Level,java.lang.String,java.lang.Throwable)>(v12, v10, v1);
v13 = v0.<io.vertx.codegen.CodeGenProcessor: javax.'annotation'.processing.ProcessingEnvironment processingEnv>;
v14 = interfaceinvoke v13.<javax.'annotation'.processing.ProcessingEnvironment: javax.'annotation'.processing.Messager getMessager()>();
v15 = <javax.tools.Diagnostic$Kind: javax.tools.Diagnostic$Kind ERROR>;
v16 = v1.<io.vertx.codegen.GenException: javax.lang.model.element.Element element>;
interfaceinvoke v14.<javax.'annotation'.processing.Messager: void printMessage(javax.tools.Diagnostic$Kind,java.lang.CharSequence,javax.lang.model.element.Element)>(v15, v10, v16);
return;
}
private void reportException(java.lang.Exception, javax.lang.model.element.Element)
{
javax.lang.model.element.Element v2;
java.util.logging.Logger v5;
java.lang.Exception v1;
java.util.logging.Level v6;
javax.tools.Diagnostic$Kind v9;
javax.'annotation'.processing.ProcessingEnvironment v7;
java.lang.String v3, v4;
io.vertx.codegen.CodeGenProcessor v0;
javax.'annotation'.processing.Messager v8;
v0 := @this: io.vertx.codegen.CodeGenProcessor;
v1 := @parameter0: java.lang.Exception;
v2 := @parameter1: javax.lang.model.element.Element;
v3 = virtualinvoke v1.<java.lang.Exception: java.lang.String getMessage()>();
v4 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (javax.lang.model.element.Element,java.lang.String)>(v2, v3) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Could not generate element for \u0001: \u0001");
v5 = <io.vertx.codegen.CodeGenProcessor: java.util.logging.Logger log>;
v6 = <java.util.logging.Level: java.util.logging.Level SEVERE>;
virtualinvoke v5.<java.util.logging.Logger: void log(java.util.logging.Level,java.lang.String,java.lang.Throwable)>(v6, v4, v1);
v7 = v0.<io.vertx.codegen.CodeGenProcessor: javax.'annotation'.processing.ProcessingEnvironment processingEnv>;
v8 = interfaceinvoke v7.<javax.'annotation'.processing.ProcessingEnvironment: javax.'annotation'.processing.Messager getMessager()>();
v9 = <javax.tools.Diagnostic$Kind: javax.tools.Diagnostic$Kind ERROR>;
interfaceinvoke v8.<javax.'annotation'.processing.Messager: void printMessage(javax.tools.Diagnostic$Kind,java.lang.CharSequence,javax.lang.model.element.Element)>(v9, v4, v2);
return;
}
static void <clinit>()
{
java.lang.Class v0;
java.lang.String v1;
java.util.logging.Logger v2;
v0 = class "Lio/vertx/codegen/CodeGenProcessor;";
v1 = virtualinvoke v0.<java.lang.Class: java.lang.String getName()>();
v2 = staticinvoke <java.util.logging.Logger: java.util.logging.Logger getLogger(java.lang.String)>(v1);
<io.vertx.codegen.CodeGenProcessor: java.util.logging.Logger log> = v2;
return;
}
}