public class io.vertx.codegen.DataObjectModel extends java.lang.Object implements io.vertx.codegen.Model
{
private static final int CTOR_NO_ARG;
private static final int CTOR_JSON_OBJECT;
private static final int CTOR_STRING;
private final javax.lang.model.util.Elements elementUtils;
private final javax.lang.model.util.Types typeUtils;
private final io.vertx.codegen.doc.Doc$Factory docFactory;
private final io.vertx.codegen.type.TypeMirrorFactory typeFactory;
private final javax.lang.model.element.TypeElement modelElt;
private final java.util.Map propertyMap;
private final java.util.Set superTypes;
private final java.util.Set abstractSuperTypes;
private final java.util.Set importedTypes;
private final io.vertx.codegen.type.AnnotationValueInfoFactory annotationValueInfoFactory;
private boolean processed;
private boolean concrete;
private boolean isClass;
private boolean generateConverter;
private boolean inheritConverter;
private boolean publicConverter;
private java.lang.String base64Type;
private int constructors;
private boolean deprecated;
private io.vertx.codegen.doc.Text deprecatedDesc;
private io.vertx.codegen.type.ClassTypeInfo superType;
private io.vertx.codegen.type.ClassTypeInfo type;
private io.vertx.codegen.doc.Doc doc;
private boolean hasToJsonMethod;
private boolean hasDecodeStaticMethod;
private java.util.List annotations;
public void <init>(javax.'annotation'.processing.ProcessingEnvironment, io.vertx.codegen.type.TypeMirrorFactory, javax.lang.model.element.TypeElement)
{
javax.lang.model.element.TypeElement v3;
javax.lang.model.util.Elements v12, v8;
java.util.LinkedHashMap v4;
io.vertx.codegen.type.AnnotationValueInfoFactory v14;
io.vertx.codegen.doc.Doc$Factory v10;
java.util.LinkedHashSet v5, v6, v7;
javax.'annotation'.processing.Messager v11;
boolean v16;
io.vertx.codegen.type.TypeMirrorFactory v2;
io.vertx.codegen.DataObjectModel v0;
javax.lang.model.util.Types v13, v9;
java.lang.'annotation'.Annotation v15;
javax.'annotation'.processing.ProcessingEnvironment v1;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 := @parameter0: javax.'annotation'.processing.ProcessingEnvironment;
v2 := @parameter1: io.vertx.codegen.type.TypeMirrorFactory;
v3 := @parameter2: javax.lang.model.element.TypeElement;
specialinvoke v0.<java.lang.Object: void <init>()>();
v4 = new java.util.LinkedHashMap;
specialinvoke v4.<java.util.LinkedHashMap: void <init>()>();
v0.<io.vertx.codegen.DataObjectModel: java.util.Map propertyMap> = v4;
v5 = new java.util.LinkedHashSet;
specialinvoke v5.<java.util.LinkedHashSet: void <init>()>();
v0.<io.vertx.codegen.DataObjectModel: java.util.Set superTypes> = v5;
v6 = new java.util.LinkedHashSet;
specialinvoke v6.<java.util.LinkedHashSet: void <init>()>();
v0.<io.vertx.codegen.DataObjectModel: java.util.Set abstractSuperTypes> = v6;
v7 = new java.util.LinkedHashSet;
specialinvoke v7.<java.util.LinkedHashSet: void <init>()>();
v0.<io.vertx.codegen.DataObjectModel: java.util.Set importedTypes> = v7;
v8 = interfaceinvoke v1.<javax.'annotation'.processing.ProcessingEnvironment: javax.lang.model.util.Elements getElementUtils()>();
v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.util.Elements elementUtils> = v8;
v9 = interfaceinvoke v1.<javax.'annotation'.processing.ProcessingEnvironment: javax.lang.model.util.Types getTypeUtils()>();
v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.util.Types typeUtils> = v9;
v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.TypeMirrorFactory typeFactory> = v2;
v10 = new io.vertx.codegen.doc.Doc$Factory;
v11 = interfaceinvoke v1.<javax.'annotation'.processing.ProcessingEnvironment: javax.'annotation'.processing.Messager getMessager()>();
v12 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.util.Elements elementUtils>;
v13 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.util.Types typeUtils>;
specialinvoke v10.<io.vertx.codegen.doc.Doc$Factory: void <init>(javax.'annotation'.processing.Messager,javax.lang.model.util.Elements,javax.lang.model.util.Types,io.vertx.codegen.type.TypeMirrorFactory,javax.lang.model.element.TypeElement)>(v11, v12, v13, v2, v3);
v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.doc.Doc$Factory docFactory> = v10;
v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.TypeElement modelElt> = v3;
v14 = new io.vertx.codegen.type.AnnotationValueInfoFactory;
specialinvoke v14.<io.vertx.codegen.type.AnnotationValueInfoFactory: void <init>(io.vertx.codegen.type.TypeMirrorFactory)>(v2);
v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.AnnotationValueInfoFactory annotationValueInfoFactory> = v14;
v15 = interfaceinvoke v3.<javax.lang.model.element.TypeElement: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Ljava/lang/Deprecated;");
if v15 == null goto label1;
v16 = 1;
goto label2;
label1:
v16 = 0;
label2:
v0.<io.vertx.codegen.DataObjectModel: boolean deprecated> = v16;
return;
}
public java.lang.String getKind()
{
io.vertx.codegen.DataObjectModel v0;
v0 := @this: io.vertx.codegen.DataObjectModel;
return "dataObject";
}
public javax.lang.model.element.Element getElement()
{
javax.lang.model.element.TypeElement v1;
io.vertx.codegen.DataObjectModel v0;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.TypeElement modelElt>;
return v1;
}
public java.lang.String getFqn()
{
io.vertx.codegen.type.ClassTypeInfo v1;
io.vertx.codegen.DataObjectModel v0;
java.lang.String v2;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.ClassTypeInfo type>;
v2 = virtualinvoke v1.<io.vertx.codegen.type.ClassTypeInfo: java.lang.String getName()>();
return v2;
}
public io.vertx.codegen.type.ClassTypeInfo getType()
{
io.vertx.codegen.type.ClassTypeInfo v1;
io.vertx.codegen.DataObjectModel v0;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.ClassTypeInfo type>;
return v1;
}
public io.vertx.codegen.doc.Doc getDoc()
{
io.vertx.codegen.DataObjectModel v0;
io.vertx.codegen.doc.Doc v1;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.doc.Doc doc>;
return v1;
}
public boolean isAbstract()
{
io.vertx.codegen.DataObjectModel v0;
boolean v1, v2;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: boolean concrete>;
if v1 != 0 goto label1;
v2 = 1;
goto label2;
label1:
v2 = 0;
label2:
return v2;
}
public boolean isConcrete()
{
io.vertx.codegen.DataObjectModel v0;
boolean v1;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: boolean concrete>;
return v1;
}
public java.util.Set getImportedTypes()
{
java.util.Set v1;
io.vertx.codegen.DataObjectModel v0;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: java.util.Set importedTypes>;
return v1;
}
public java.util.Map getPropertyMap()
{
io.vertx.codegen.DataObjectModel v0;
java.util.Map v1;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: java.util.Map propertyMap>;
return v1;
}
public java.util.List getAnnotations()
{
java.util.List v1;
io.vertx.codegen.DataObjectModel v0;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: java.util.List annotations>;
return v1;
}
public io.vertx.codegen.type.ClassTypeInfo getSuperType()
{
io.vertx.codegen.type.ClassTypeInfo v1;
io.vertx.codegen.DataObjectModel v0;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.ClassTypeInfo superType>;
return v1;
}
public java.util.Set getAbstractSuperTypes()
{
java.util.Set v1;
io.vertx.codegen.DataObjectModel v0;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: java.util.Set abstractSuperTypes>;
return v1;
}
public java.util.Set getSuperTypes()
{
java.util.Set v1;
io.vertx.codegen.DataObjectModel v0;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: java.util.Set superTypes>;
return v1;
}
public io.vertx.codegen.ModuleInfo getModule()
{
io.vertx.codegen.type.ClassTypeInfo v1, v2;
io.vertx.codegen.DataObjectModel v0;
io.vertx.codegen.ModuleInfo v3;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.ClassTypeInfo type>;
v2 = virtualinvoke v1.<io.vertx.codegen.type.ClassTypeInfo: io.vertx.codegen.type.ClassTypeInfo getRaw()>();
v3 = virtualinvoke v2.<io.vertx.codegen.type.ClassTypeInfo: io.vertx.codegen.ModuleInfo getModule()>();
return v3;
}
public boolean isClass()
{
io.vertx.codegen.DataObjectModel v0;
boolean v1;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: boolean isClass>;
return v1;
}
public boolean getGenerateConverter()
{
io.vertx.codegen.DataObjectModel v0;
boolean v1;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: boolean generateConverter>;
return v1;
}
public boolean getInheritConverter()
{
io.vertx.codegen.DataObjectModel v0;
boolean v1;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: boolean inheritConverter>;
return v1;
}
public boolean isPublicConverter()
{
io.vertx.codegen.DataObjectModel v0;
boolean v1;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: boolean publicConverter>;
return v1;
}
public java.lang.String getBase64Type()
{
io.vertx.codegen.DataObjectModel v0;
java.lang.String v1;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: java.lang.String base64Type>;
return v1;
}
public boolean isSerializable()
{
io.vertx.codegen.type.ClassTypeInfo v1, v3;
io.vertx.codegen.type.DataObjectInfo v4;
io.vertx.codegen.DataObjectModel v0;
boolean v2, v5, v6;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.ClassTypeInfo type>;
v2 = virtualinvoke v1.<io.vertx.codegen.type.ClassTypeInfo: boolean isDataObjectHolder()>();
if v2 == 0 goto label1;
v3 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.ClassTypeInfo type>;
v4 = virtualinvoke v3.<io.vertx.codegen.type.ClassTypeInfo: io.vertx.codegen.type.DataObjectInfo getDataObject()>();
v5 = virtualinvoke v4.<io.vertx.codegen.type.DataObjectInfo: boolean isSerializable()>();
if v5 == 0 goto label1;
v6 = 1;
goto label2;
label1:
v6 = 0;
label2:
return v6;
}
public boolean isDeserializable()
{
io.vertx.codegen.type.ClassTypeInfo v1, v3;
io.vertx.codegen.type.DataObjectInfo v4;
io.vertx.codegen.DataObjectModel v0;
boolean v2, v5, v6;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.ClassTypeInfo type>;
v2 = virtualinvoke v1.<io.vertx.codegen.type.ClassTypeInfo: boolean isDataObjectHolder()>();
if v2 == 0 goto label1;
v3 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.ClassTypeInfo type>;
v4 = virtualinvoke v3.<io.vertx.codegen.type.ClassTypeInfo: io.vertx.codegen.type.DataObjectInfo getDataObject()>();
v5 = virtualinvoke v4.<io.vertx.codegen.type.DataObjectInfo: boolean isDeserializable()>();
if v5 == 0 goto label1;
v6 = 1;
goto label2;
label1:
v6 = 0;
label2:
return v6;
}
public boolean hasToJsonMethod()
{
io.vertx.codegen.DataObjectModel v0;
boolean v1;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: boolean hasToJsonMethod>;
return v1;
}
public boolean hasEmptyConstructor()
{
io.vertx.codegen.DataObjectModel v0;
int v1, v2;
boolean v3;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: int constructors>;
v2 = v1 & 1;
if v2 != 1 goto label1;
v3 = 1;
goto label2;
label1:
v3 = 0;
label2:
return v3;
}
public boolean hasJsonConstructor()
{
io.vertx.codegen.DataObjectModel v0;
int v1, v2;
boolean v3;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: int constructors>;
v2 = v1 & 2;
if v2 != 2 goto label1;
v3 = 1;
goto label2;
label1:
v3 = 0;
label2:
return v3;
}
public boolean hasStringConstructor()
{
io.vertx.codegen.DataObjectModel v0;
int v1, v2;
boolean v3;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: int constructors>;
v2 = v1 & 4;
if v2 != 4 goto label1;
v3 = 1;
goto label2;
label1:
v3 = 0;
label2:
return v3;
}
public boolean hasDecodeStaticMethod()
{
io.vertx.codegen.DataObjectModel v0;
boolean v1;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: boolean hasDecodeStaticMethod>;
return v1;
}
public boolean isDeprecated()
{
io.vertx.codegen.DataObjectModel v0;
boolean v1;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: boolean deprecated>;
return v1;
}
public io.vertx.codegen.doc.Text getDeprecatedDesc()
{
io.vertx.codegen.DataObjectModel v0;
io.vertx.codegen.doc.Text v1;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.doc.Text deprecatedDesc>;
return v1;
}
public java.util.Map getVars()
{
io.vertx.codegen.doc.Text v35;
java.util.Map v1, v15;
boolean v11, v13, v21, v23, v25, v27, v29, v31, v33, v4, v6, v8;
java.util.Collection v16;
java.util.Set v17, v18, v20;
io.vertx.codegen.doc.Doc v3;
java.lang.Boolean v12, v14, v22, v24, v26, v28, v30, v32, v34, v5, v7, v9;
java.lang.String v10;
io.vertx.codegen.type.ClassTypeInfo v19, v2;
io.vertx.codegen.DataObjectModel v0;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = specialinvoke v0.<io.vertx.codegen.Model: java.util.Map getVars()>();
v2 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.ClassTypeInfo type>;
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("type", v2);
v3 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.doc.Doc doc>;
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("doc", v3);
v4 = v0.<io.vertx.codegen.DataObjectModel: boolean generateConverter>;
v5 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>(v4);
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("generateConverter", v5);
v6 = v0.<io.vertx.codegen.DataObjectModel: boolean inheritConverter>;
v7 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>(v6);
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("inheritConverter", v7);
v8 = v0.<io.vertx.codegen.DataObjectModel: boolean publicConverter>;
v9 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>(v8);
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("publicConverter", v9);
v10 = v0.<io.vertx.codegen.DataObjectModel: java.lang.String base64Type>;
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("base64Type", v10);
v11 = v0.<io.vertx.codegen.DataObjectModel: boolean concrete>;
v12 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>(v11);
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("concrete", v12);
v13 = v0.<io.vertx.codegen.DataObjectModel: boolean isClass>;
v14 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>(v13);
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("isClass", v14);
v15 = v0.<io.vertx.codegen.DataObjectModel: java.util.Map propertyMap>;
v16 = interfaceinvoke v15.<java.util.Map: java.util.Collection values()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("properties", v16);
v17 = v0.<io.vertx.codegen.DataObjectModel: java.util.Set importedTypes>;
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("importedTypes", v17);
v18 = v0.<io.vertx.codegen.DataObjectModel: java.util.Set superTypes>;
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("superTypes", v18);
v19 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.ClassTypeInfo superType>;
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("superType", v19);
v20 = v0.<io.vertx.codegen.DataObjectModel: java.util.Set abstractSuperTypes>;
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("abstractSuperTypes", v20);
v21 = v0.<io.vertx.codegen.DataObjectModel: boolean hasToJsonMethod>;
v22 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>(v21);
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("hasToJsonMethod", v22);
v23 = virtualinvoke v0.<io.vertx.codegen.DataObjectModel: boolean hasEmptyConstructor()>();
v24 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>(v23);
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("hasEmptyConstructor", v24);
v25 = virtualinvoke v0.<io.vertx.codegen.DataObjectModel: boolean hasJsonConstructor()>();
v26 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>(v25);
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("hasJsonConstructor", v26);
v27 = virtualinvoke v0.<io.vertx.codegen.DataObjectModel: boolean hasStringConstructor()>();
v28 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>(v27);
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("hasStringConstructor", v28);
v29 = virtualinvoke v0.<io.vertx.codegen.DataObjectModel: boolean isSerializable()>();
v30 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>(v29);
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("serializable", v30);
v31 = virtualinvoke v0.<io.vertx.codegen.DataObjectModel: boolean isDeserializable()>();
v32 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>(v31);
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("deserializable", v32);
v33 = v0.<io.vertx.codegen.DataObjectModel: boolean deprecated>;
v34 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>(v33);
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("deprecated", v34);
v35 = virtualinvoke v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.doc.Text getDeprecatedDesc()>();
interfaceinvoke v1.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>("deprecatedDesc", v35);
return v1;
}
public boolean process()
{
io.vertx.codegen.DataObjectModel v0;
javax.lang.model.element.ElementKind v3, v4, v6, v7;
javax.lang.model.element.TypeElement v10, v2, v5, v9;
io.vertx.codegen.GenException v8;
java.lang.String v11;
boolean v1;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: boolean processed>;
if v1 != 0 goto label3;
v2 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.TypeElement modelElt>;
v3 = interfaceinvoke v2.<javax.lang.model.element.TypeElement: javax.lang.model.element.ElementKind getKind()>();
v4 = <javax.lang.model.element.ElementKind: javax.lang.model.element.ElementKind INTERFACE>;
if v3 == v4 goto label1;
v5 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.TypeElement modelElt>;
v6 = interfaceinvoke v5.<javax.lang.model.element.TypeElement: javax.lang.model.element.ElementKind getKind()>();
v7 = <javax.lang.model.element.ElementKind: javax.lang.model.element.ElementKind CLASS>;
if v6 != v7 goto label2;
label1:
specialinvoke v0.<io.vertx.codegen.DataObjectModel: void traverse()>();
specialinvoke v0.<io.vertx.codegen.DataObjectModel: void processTypeAnnotations()>();
specialinvoke v0.<io.vertx.codegen.DataObjectModel: void processImportedTypes()>();
v0.<io.vertx.codegen.DataObjectModel: boolean processed> = 1;
return 1;
label2:
v8 = new io.vertx.codegen.GenException;
v9 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.TypeElement modelElt>;
v10 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.TypeElement modelElt>;
v11 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (javax.lang.model.element.TypeElement)>(v10) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Data object \u0001 must be an interface or a class");
specialinvoke v8.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v9, v11);
throw v8;
label3:
return 0;
}
private void traverse()
{
javax.lang.model.element.Modifier v27, v96, v97;
javax.lang.model.element.TypeElement v1, v111, v17, v20, v25, v31, v36, v38, v50, v51, v62, v73, v9;
javax.lang.model.util.Elements v72;
byte v11;
javax.lang.model.element.Modifier[] v95;
java.util.Map v116, v119;
io.vertx.codegen.type.TypeMirrorFactory v102, v30, v67, v87;
java.util.Set v26, v58, v60, v61, v69, v94;
javax.lang.model.element.Element v121, v65;
java.util.stream.Stream v43, v45, v53, v55, v57;
io.vertx.codegen.doc.Doc v39, v40, v41;
io.vertx.codegen.ModuleInfo v48;
java.lang.ClassCastException v34;
java.util.ArrayList v115, v71;
io.vertx.codegen.GenException v16, v35, v49, v8;
java.lang.String v10, v18, v19, v6, v7, v83;
io.vertx.codegen.doc.Doc$Factory v37;
io.vertx.codegen.type.ClassTypeInfo v70;
int[] v78;
io.vertx.codegen.type.ClassKind v107, v108, v90, v91;
boolean v113, v13, v14, v15, v23, v24, v28, v29, v3, v4, v5, v64, v76, v84, v86, v93, v99;
java.util.function.Predicate v44, v54;
io.vertx.codegen.type.TypeInfo v106, v33, v68, v89;
java.util.Collection v117;
javax.lang.model.util.Types v109;
java.util.List v100, v103, v42, v52, v74, v85, v98;
java.lang.'annotation'.Annotation v114, v2, v66;
java.util.Optional v46;
java.util.function.Function v56;
int v101, v12, v80, v81;
javax.lang.model.element.Name v82, v92;
io.vertx.codegen.DataObjectModel v0;
java.util.Iterator v75;
javax.lang.model.element.ElementKind v21, v22, v79;
java.util.function.Consumer v120, v47, v59;
javax.lang.model.type.TypeMirror v105, v110, v112, v32, v63, v88;
java.lang.Object v104, v77;
java.util.Comparator v118;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.TypeElement modelElt>;
v2 = interfaceinvoke v1.<javax.lang.model.element.TypeElement: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Lio/vertx/codegen/annotations/DataObject;");
v3 = interfaceinvoke v2.<io.vertx.codegen.annotations.DataObject: boolean generateConverter()>();
v0.<io.vertx.codegen.DataObjectModel: boolean generateConverter> = v3;
v4 = interfaceinvoke v2.<io.vertx.codegen.annotations.DataObject: boolean publicConverter()>();
v0.<io.vertx.codegen.DataObjectModel: boolean publicConverter> = v4;
v5 = interfaceinvoke v2.<io.vertx.codegen.annotations.DataObject: boolean inheritConverter()>();
v0.<io.vertx.codegen.DataObjectModel: boolean inheritConverter> = v5;
v6 = interfaceinvoke v2.<io.vertx.codegen.annotations.DataObject: java.lang.String base64Type()>();
v0.<io.vertx.codegen.DataObjectModel: java.lang.String base64Type> = v6;
v7 = v0.<io.vertx.codegen.DataObjectModel: java.lang.String base64Type>;
if v7 != null goto label01;
v8 = new io.vertx.codegen.GenException;
v9 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.TypeElement modelElt>;
specialinvoke v8.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v9, "Data object base64 type cannot be null");
throw v8;
label01:
v10 = v0.<io.vertx.codegen.DataObjectModel: java.lang.String base64Type>;
v11 = -1;
v12 = virtualinvoke v10.<java.lang.String: int hashCode()>();
lookupswitch(v12)
{
case -1856179776: goto label04;
case 0: goto label02;
case 93508654: goto label03;
default: goto label05;
};
label02:
v13 = virtualinvoke v10.<java.lang.String: boolean equals(java.lang.Object)>("");
if v13 == 0 goto label05;
v11 = 0;
goto label05;
label03:
v14 = virtualinvoke v10.<java.lang.String: boolean equals(java.lang.Object)>("basic");
if v14 == 0 goto label05;
v11 = 1;
goto label05;
label04:
v15 = virtualinvoke v10.<java.lang.String: boolean equals(java.lang.Object)>("base64url");
if v15 == 0 goto label05;
v11 = 2;
label05:
tableswitch(v11)
{
case 0: goto label07;
case 1: goto label07;
case 2: goto label07;
default: goto label06;
};
label06:
v16 = new io.vertx.codegen.GenException;
v17 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.TypeElement modelElt>;
v18 = v0.<io.vertx.codegen.DataObjectModel: java.lang.String base64Type>;
v19 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v18) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Data object base64 unsupported type: \u0001");
specialinvoke v16.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v17, v19);
throw v16;
label07:
v20 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.TypeElement modelElt>;
v21 = interfaceinvoke v20.<javax.lang.model.element.TypeElement: javax.lang.model.element.ElementKind getKind()>();
v22 = <javax.lang.model.element.ElementKind: javax.lang.model.element.ElementKind CLASS>;
if v21 != v22 goto label08;
v23 = 1;
goto label09;
label08:
v23 = 0;
label09:
v0.<io.vertx.codegen.DataObjectModel: boolean isClass> = v23;
v24 = v0.<io.vertx.codegen.DataObjectModel: boolean isClass>;
if v24 == 0 goto label10;
v25 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.TypeElement modelElt>;
v26 = interfaceinvoke v25.<javax.lang.model.element.TypeElement: java.util.Set getModifiers()>();
v27 = <javax.lang.model.element.Modifier: javax.lang.model.element.Modifier ABSTRACT>;
v28 = interfaceinvoke v26.<java.util.Set: boolean contains(java.lang.Object)>(v27);
if v28 != 0 goto label10;
v29 = 1;
goto label11;
label10:
v29 = 0;
label11:
v0.<io.vertx.codegen.DataObjectModel: boolean concrete> = v29;
label12:
v30 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.TypeMirrorFactory typeFactory>;
v31 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.TypeElement modelElt>;
v32 = interfaceinvoke v31.<javax.lang.model.element.TypeElement: javax.lang.model.type.TypeMirror asType()>();
v33 = virtualinvoke v30.<io.vertx.codegen.type.TypeMirrorFactory: io.vertx.codegen.type.TypeInfo create(javax.lang.model.type.TypeMirror)>(v32);
v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.ClassTypeInfo type> = v33;
label13:
goto label15;
label14:
v34 := @caughtexception;
v35 = new io.vertx.codegen.GenException;
v36 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.TypeElement modelElt>;
specialinvoke v35.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v36, "Data object must be a plain java class with no type parameters");
throw v35;
label15:
staticinvoke <io.vertx.codegen.Helper: void checkUnderModule(io.vertx.codegen.Model,java.lang.String)>(v0, "@VertxGen");
v37 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.doc.Doc$Factory docFactory>;
v38 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.TypeElement modelElt>;
v39 = virtualinvoke v37.<io.vertx.codegen.doc.Doc$Factory: io.vertx.codegen.doc.Doc createDoc(javax.lang.model.element.Element)>(v38);
v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.doc.Doc doc> = v39;
v40 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.doc.Doc doc>;
if v40 == null goto label16;
v41 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.doc.Doc doc>;
v42 = virtualinvoke v41.<io.vertx.codegen.doc.Doc: java.util.List getBlockTags()>();
v43 = interfaceinvoke v42.<java.util.List: java.util.stream.Stream stream()>();
v44 = staticinvoke <io.vertx.codegen.DataObjectModel$lambda_traverse_0__2413: java.util.function.Predicate bootstrap$()>();
v45 = interfaceinvoke v43.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v44);
v46 = interfaceinvoke v45.<java.util.stream.Stream: java.util.Optional findFirst()>();
v47 = staticinvoke <io.vertx.codegen.DataObjectModel$lambda_traverse_1__2414: java.util.function.Consumer bootstrap$(io.vertx.codegen.DataObjectModel)>(v0);
virtualinvoke v46.<java.util.Optional: void ifPresent(java.util.function.Consumer)>(v47);
label16:
v48 = virtualinvoke v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.ModuleInfo getModule()>();
if v48 != null goto label17;
v49 = new io.vertx.codegen.GenException;
v50 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.TypeElement modelElt>;
specialinvoke v49.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v50, "Data object must have an ancestor package annotated with @ModuleGen");
throw v49;
label17:
v51 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.TypeElement modelElt>;
v52 = interfaceinvoke v51.<javax.lang.model.element.TypeElement: java.util.List getInterfaces()>();
v53 = interfaceinvoke v52.<java.util.List: java.util.stream.Stream stream()>();
v54 = staticinvoke <io.vertx.codegen.DataObjectModel$lambda_traverse_2__2408: java.util.function.Predicate bootstrap$()>();
v55 = interfaceinvoke v53.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v54);
v56 = staticinvoke <io.vertx.codegen.DataObjectModel$lambda_traverse_3__2409: java.util.function.Function bootstrap$(io.vertx.codegen.DataObjectModel)>(v0);
v57 = interfaceinvoke v55.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v56);
v58 = v0.<io.vertx.codegen.DataObjectModel: java.util.Set abstractSuperTypes>;
virtualinvoke v58.<java.lang.Object: java.lang.Class getClass()>();
v59 = staticinvoke <io.vertx.codegen.DataObjectModel$add__2410: java.util.function.Consumer bootstrap$(java.util.Set)>(v58);
interfaceinvoke v57.<java.util.stream.Stream: void forEach(java.util.function.Consumer)>(v59);
v60 = v0.<io.vertx.codegen.DataObjectModel: java.util.Set superTypes>;
v61 = v0.<io.vertx.codegen.DataObjectModel: java.util.Set abstractSuperTypes>;
interfaceinvoke v60.<java.util.Set: boolean addAll(java.util.Collection)>(v61);
v62 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.TypeElement modelElt>;
v63 = interfaceinvoke v62.<javax.lang.model.element.TypeElement: javax.lang.model.type.TypeMirror getSuperclass()>();
v64 = v63 instanceof javax.lang.model.type.DeclaredType;
if v64 == 0 goto label18;
v65 = interfaceinvoke v63.<javax.lang.model.type.DeclaredType: javax.lang.model.element.Element asElement()>();
v66 = interfaceinvoke v65.<javax.lang.model.element.Element: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Lio/vertx/codegen/annotations/DataObject;");
if v66 == null goto label18;
v67 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.TypeMirrorFactory typeFactory>;
v68 = virtualinvoke v67.<io.vertx.codegen.type.TypeMirrorFactory: io.vertx.codegen.type.TypeInfo create(javax.lang.model.type.TypeMirror)>(v63);
v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.ClassTypeInfo superType> = v68;
v69 = v0.<io.vertx.codegen.DataObjectModel: java.util.Set superTypes>;
v70 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.ClassTypeInfo superType>;
interfaceinvoke v69.<java.util.Set: boolean add(java.lang.Object)>(v70);
label18:
v71 = new java.util.ArrayList;
specialinvoke v71.<java.util.ArrayList: void <init>()>();
v72 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.util.Elements elementUtils>;
v73 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.TypeElement modelElt>;
v74 = interfaceinvoke v72.<javax.lang.model.util.Elements: java.util.List getAllMembers(javax.lang.model.element.TypeElement)>(v73);
v75 = interfaceinvoke v74.<java.util.List: java.util.Iterator iterator()>();
label19:
v76 = interfaceinvoke v75.<java.util.Iterator: boolean hasNext()>();
if v76 == 0 goto label24;
v77 = interfaceinvoke v75.<java.util.Iterator: java.lang.Object next()>();
v78 = <io.vertx.codegen.DataObjectModel$1: int[] $SwitchMap$javax$lang$model$element$ElementKind>;
v79 = interfaceinvoke v77.<javax.lang.model.element.Element: javax.lang.model.element.ElementKind getKind()>();
v80 = virtualinvoke v79.<javax.lang.model.element.ElementKind: int ordinal()>();
v81 = v78[v80];
lookupswitch(v81)
{
case 1: goto label20;
case 2: goto label21;
default: goto label19;
};
label20:
specialinvoke v0.<io.vertx.codegen.DataObjectModel: void processConstructor(javax.lang.model.element.ExecutableElement)>(v121);
goto label19;
label21:
v82 = interfaceinvoke v121.<javax.lang.model.element.ExecutableElement: javax.lang.model.element.Name getSimpleName()>();
v83 = virtualinvoke v82.<java.lang.Object: java.lang.String toString()>();
v84 = virtualinvoke v83.<java.lang.String: boolean equals(java.lang.Object)>("toJson");
if v84 == 0 goto label22;
v85 = interfaceinvoke v121.<javax.lang.model.element.ExecutableElement: java.util.List getParameters()>();
v86 = interfaceinvoke v85.<java.util.List: boolean isEmpty()>();
if v86 == 0 goto label22;
v87 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.TypeMirrorFactory typeFactory>;
v88 = interfaceinvoke v121.<javax.lang.model.element.ExecutableElement: javax.lang.model.type.TypeMirror getReturnType()>();
v89 = virtualinvoke v87.<io.vertx.codegen.type.TypeMirrorFactory: io.vertx.codegen.type.TypeInfo create(javax.lang.model.type.TypeMirror)>(v88);
v90 = virtualinvoke v89.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v91 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind JSON_OBJECT>;
if v90 != v91 goto label22;
v0.<io.vertx.codegen.DataObjectModel: boolean hasToJsonMethod> = 1;
label22:
v92 = interfaceinvoke v121.<javax.lang.model.element.ExecutableElement: javax.lang.model.element.Name getSimpleName()>();
v93 = interfaceinvoke v92.<javax.lang.model.element.Name: boolean contentEquals(java.lang.CharSequence)>("decode");
if v93 == 0 goto label23;
v94 = interfaceinvoke v121.<javax.lang.model.element.ExecutableElement: java.util.Set getModifiers()>();
v95 = newarray (javax.lang.model.element.Modifier)[2];
v96 = <javax.lang.model.element.Modifier: javax.lang.model.element.Modifier STATIC>;
v95[0] = v96;
v97 = <javax.lang.model.element.Modifier: javax.lang.model.element.Modifier PUBLIC>;
v95[1] = v97;
v98 = staticinvoke <java.util.Arrays: java.util.List asList(java.lang.Object[])>(v95);
v99 = interfaceinvoke v94.<java.util.Set: boolean containsAll(java.util.Collection)>(v98);
if v99 == 0 goto label23;
v100 = interfaceinvoke v121.<javax.lang.model.element.ExecutableElement: java.util.List getParameters()>();
v101 = interfaceinvoke v100.<java.util.List: int size()>();
if v101 != 1 goto label23;
v102 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.TypeMirrorFactory typeFactory>;
v103 = interfaceinvoke v121.<javax.lang.model.element.ExecutableElement: java.util.List getParameters()>();
v104 = interfaceinvoke v103.<java.util.List: java.lang.Object get(int)>(0);
v105 = interfaceinvoke v104.<javax.lang.model.element.VariableElement: javax.lang.model.type.TypeMirror asType()>();
v106 = virtualinvoke v102.<io.vertx.codegen.type.TypeMirrorFactory: io.vertx.codegen.type.TypeInfo create(javax.lang.model.type.TypeMirror)>(v105);
v107 = virtualinvoke v106.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v108 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind JSON_OBJECT>;
if v107 != v108 goto label23;
v109 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.util.Types typeUtils>;
v110 = interfaceinvoke v121.<javax.lang.model.element.ExecutableElement: javax.lang.model.type.TypeMirror getReturnType()>();
v111 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.TypeElement modelElt>;
v112 = interfaceinvoke v111.<javax.lang.model.element.TypeElement: javax.lang.model.type.TypeMirror asType()>();
v113 = interfaceinvoke v109.<javax.lang.model.util.Types: boolean isSameType(javax.lang.model.type.TypeMirror,javax.lang.model.type.TypeMirror)>(v110, v112);
if v113 == 0 goto label23;
v0.<io.vertx.codegen.DataObjectModel: boolean hasDecodeStaticMethod> = 1;
label23:
v114 = interfaceinvoke v121.<javax.lang.model.element.ExecutableElement: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Lio/vertx/codegen/annotations/GenIgnore;");
if v114 != null goto label19;
interfaceinvoke v71.<java.util.List: boolean add(java.lang.Object)>(v121);
goto label19;
label24:
specialinvoke v0.<io.vertx.codegen.DataObjectModel: void processMethods(java.util.List)>(v71);
v115 = new java.util.ArrayList;
v116 = v0.<io.vertx.codegen.DataObjectModel: java.util.Map propertyMap>;
v117 = interfaceinvoke v116.<java.util.Map: java.util.Collection values()>();
specialinvoke v115.<java.util.ArrayList: void <init>(java.util.Collection)>(v117);
v118 = staticinvoke <io.vertx.codegen.DataObjectModel$lambda_traverse_4__2411: java.util.Comparator bootstrap$()>();
staticinvoke <java.util.Collections: void sort(java.util.List,java.util.Comparator)>(v115, v118);
v119 = v0.<io.vertx.codegen.DataObjectModel: java.util.Map propertyMap>;
interfaceinvoke v119.<java.util.Map: void clear()>();
v120 = staticinvoke <io.vertx.codegen.DataObjectModel$lambda_traverse_5__2412: java.util.function.Consumer bootstrap$(io.vertx.codegen.DataObjectModel)>(v0);
virtualinvoke v115.<java.util.ArrayList: void forEach(java.util.function.Consumer)>(v120);
return;
catch java.lang.ClassCastException from label12 to label13 with label14;
}
private void processTypeAnnotations()
{
io.vertx.codegen.DataObjectModel v0;
javax.lang.model.element.TypeElement v2;
java.util.function.Function v6;
javax.lang.model.util.Elements v1;
java.util.List v3;
java.util.stream.Stream v4, v7;
io.vertx.codegen.type.AnnotationValueInfoFactory v5;
java.lang.Object v9;
java.util.stream.Collector v8;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.util.Elements elementUtils>;
v2 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.TypeElement modelElt>;
v3 = interfaceinvoke v1.<javax.lang.model.util.Elements: java.util.List getAllAnnotationMirrors(javax.lang.model.element.Element)>(v2);
v4 = interfaceinvoke v3.<java.util.List: java.util.stream.Stream stream()>();
v5 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.AnnotationValueInfoFactory annotationValueInfoFactory>;
virtualinvoke v5.<java.lang.Object: java.lang.Class getClass()>();
v6 = staticinvoke <io.vertx.codegen.DataObjectModel$processAnnotation__2415: java.util.function.Function bootstrap$(io.vertx.codegen.type.AnnotationValueInfoFactory)>(v5);
v7 = interfaceinvoke v4.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v6);
v8 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector toList()>();
v9 = interfaceinvoke v7.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v8);
v0.<io.vertx.codegen.DataObjectModel: java.util.List annotations> = v9;
return;
}
private void processImportedTypes()
{
java.util.Map v1;
java.lang.String v17, v19;
java.util.stream.Collector v11;
boolean v15, v20, v4;
io.vertx.codegen.type.ClassTypeInfo v18;
io.vertx.codegen.DataObjectModel v0;
java.util.Iterator v14, v3;
io.vertx.codegen.type.TypeInfo v6;
java.util.Collection v2;
java.util.Set v13, v7, v8, v9;
java.util.stream.Stream v10;
java.lang.Object v12, v16, v5;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 = v0.<io.vertx.codegen.DataObjectModel: java.util.Map propertyMap>;
v2 = interfaceinvoke v1.<java.util.Map: java.util.Collection values()>();
v3 = interfaceinvoke v2.<java.util.Collection: java.util.Iterator iterator()>();
label1:
v4 = interfaceinvoke v3.<java.util.Iterator: boolean hasNext()>();
if v4 == 0 goto label2;
v5 = interfaceinvoke v3.<java.util.Iterator: java.lang.Object next()>();
v6 = v5.<io.vertx.codegen.PropertyInfo: io.vertx.codegen.type.TypeInfo type>;
v7 = v0.<io.vertx.codegen.DataObjectModel: java.util.Set importedTypes>;
virtualinvoke v6.<io.vertx.codegen.type.TypeInfo: void collectImports(java.util.Collection)>(v7);
goto label1;
label2:
v8 = v0.<io.vertx.codegen.DataObjectModel: java.util.Set importedTypes>;
v9 = v0.<io.vertx.codegen.DataObjectModel: java.util.Set superTypes>;
v10 = interfaceinvoke v9.<java.util.Set: java.util.stream.Stream stream()>();
v11 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector toList()>();
v12 = interfaceinvoke v10.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v11);
interfaceinvoke v8.<java.util.Set: boolean addAll(java.util.Collection)>(v12);
v13 = v0.<io.vertx.codegen.DataObjectModel: java.util.Set importedTypes>;
v14 = interfaceinvoke v13.<java.util.Set: java.util.Iterator iterator()>();
label3:
v15 = interfaceinvoke v14.<java.util.Iterator: boolean hasNext()>();
if v15 == 0 goto label4;
v16 = interfaceinvoke v14.<java.util.Iterator: java.lang.Object next()>();
v17 = virtualinvoke v16.<io.vertx.codegen.type.ClassTypeInfo: java.lang.String getPackageName()>();
v18 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.ClassTypeInfo type>;
v19 = virtualinvoke v18.<io.vertx.codegen.type.ClassTypeInfo: java.lang.String getPackageName()>();
v20 = virtualinvoke v17.<java.lang.String: boolean equals(java.lang.Object)>(v19);
if v20 == 0 goto label3;
interfaceinvoke v14.<java.util.Iterator: void remove()>();
goto label3;
label4:
return;
}
private void processConstructor(javax.lang.model.element.ExecutableElement)
{
javax.lang.model.element.Modifier v3;
javax.lang.model.element.TypeElement v6;
int[] v15;
int v17, v18, v19, v20, v21, v22, v23, v24, v9;
io.vertx.codegen.type.ClassKind v16;
boolean v14, v4, v7;
io.vertx.codegen.type.TypeMirrorFactory v10;
io.vertx.codegen.DataObjectModel v0;
io.vertx.codegen.type.TypeInfo v13;
javax.lang.model.element.ExecutableElement v1;
java.util.Set v2;
javax.lang.model.element.Element v5;
java.util.List v8;
javax.lang.model.type.TypeMirror v12;
java.lang.Object v11;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 := @parameter0: javax.lang.model.element.ExecutableElement;
v2 = interfaceinvoke v1.<javax.lang.model.element.ExecutableElement: java.util.Set getModifiers()>();
v3 = <javax.lang.model.element.Modifier: javax.lang.model.element.Modifier PUBLIC>;
v4 = interfaceinvoke v2.<java.util.Set: boolean contains(java.lang.Object)>(v3);
if v4 == 0 goto label4;
v5 = interfaceinvoke v1.<javax.lang.model.element.ExecutableElement: javax.lang.model.element.Element getEnclosingElement()>();
v6 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.TypeElement modelElt>;
v7 = interfaceinvoke v5.<javax.lang.model.element.Element: boolean equals(java.lang.Object)>(v6);
if v7 == 0 goto label4;
v8 = interfaceinvoke v1.<javax.lang.model.element.ExecutableElement: java.util.List getParameters()>();
v9 = interfaceinvoke v8.<java.util.List: int size()>();
if v9 != 1 goto label3;
v10 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.TypeMirrorFactory typeFactory>;
v11 = interfaceinvoke v8.<java.util.List: java.lang.Object get(int)>(0);
v12 = interfaceinvoke v11.<javax.lang.model.element.VariableElement: javax.lang.model.type.TypeMirror asType()>();
v13 = virtualinvoke v10.<io.vertx.codegen.type.TypeMirrorFactory: io.vertx.codegen.type.TypeInfo create(javax.lang.model.type.TypeMirror)>(v12);
v14 = v13 instanceof io.vertx.codegen.type.ClassTypeInfo;
if v14 == 0 goto label4;
v15 = <io.vertx.codegen.DataObjectModel$1: int[] $SwitchMap$io$vertx$codegen$type$ClassKind>;
v16 = virtualinvoke v13.<io.vertx.codegen.type.ClassTypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v17 = virtualinvoke v16.<io.vertx.codegen.type.ClassKind: int ordinal()>();
v18 = v15[v17];
lookupswitch(v18)
{
case 1: goto label1;
case 2: goto label2;
default: goto label4;
};
label1:
v19 = v0.<io.vertx.codegen.DataObjectModel: int constructors>;
v20 = v19 | 2;
v0.<io.vertx.codegen.DataObjectModel: int constructors> = v20;
goto label4;
label2:
v21 = v0.<io.vertx.codegen.DataObjectModel: int constructors>;
v22 = v21 | 4;
v0.<io.vertx.codegen.DataObjectModel: int constructors> = v22;
goto label4;
label3:
if v9 != 0 goto label4;
v23 = v0.<io.vertx.codegen.DataObjectModel: int constructors>;
v24 = v23 | 1;
v0.<io.vertx.codegen.DataObjectModel: int constructors> = v24;
label4:
return;
}
private void processMethods(java.util.List)
{
javax.lang.model.element.Modifier v14, v17;
javax.lang.model.util.Elements v32, v45, v71, v73;
java.util.stream.Collector v89;
java.util.Set v13, v16, v76, v77, v78;
javax.lang.model.element.Element v67, v82, v9;
java.util.stream.Stream v84, v86, v88;
io.vertx.codegen.GenException v60;
java.lang.String v11, v20, v30, v31, v43, v44, v52, v53, v54, v57, v61, v69;
java.util.function.BiFunction v6;
boolean v12, v15, v18, v21, v24, v26, v34, v37, v39, v47, v48, v51, v58, v59, v70, v80, v93;
java.util.function.Predicate v85;
javax.lang.model.type.TypeKind v28, v29, v41, v42, v65, v66;
java.util.List v1, v25, v33, v38, v46, v55, v62, v72, v74, v83;
java.util.HashMap v2, v3, v4, v5;
java.util.function.Function v87;
java.util.HashSet v75;
int v22, v35, v49, v56, v7, v91;
javax.lang.model.element.Name v10, v19, v68;
io.vertx.codegen.DataObjectModel v0;
java.util.Iterator v79, v92;
char v23, v36, v50;
javax.lang.model.type.TypeMirror v27, v40, v64;
java.lang.Object v63, v8, v81, v90, v94, v95, v96, v97, v98;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 := @parameter0: java.util.List;
v2 = new java.util.HashMap;
specialinvoke v2.<java.util.HashMap: void <init>()>();
v3 = new java.util.HashMap;
specialinvoke v3.<java.util.HashMap: void <init>()>();
v4 = new java.util.HashMap;
specialinvoke v4.<java.util.HashMap: void <init>()>();
v5 = new java.util.HashMap;
specialinvoke v5.<java.util.HashMap: void <init>()>();
v6 = staticinvoke <io.vertx.codegen.DataObjectModel$lambda_processMethods_6__2416: java.util.function.BiFunction bootstrap$()>();
label01:
v7 = interfaceinvoke v1.<java.util.List: int size()>();
if v7 <= 0 goto label08;
v8 = interfaceinvoke v1.<java.util.List: java.lang.Object remove(int)>(0);
v9 = interfaceinvoke v8.<javax.lang.model.element.ExecutableElement: javax.lang.model.element.Element getEnclosingElement()>();
v10 = interfaceinvoke v9.<javax.lang.model.element.TypeElement: javax.lang.model.element.Name getQualifiedName()>();
v11 = virtualinvoke v10.<java.lang.Object: java.lang.String toString()>();
v12 = virtualinvoke v11.<java.lang.String: boolean equals(java.lang.Object)>("java.lang.Object");
if v12 != 0 goto label01;
v13 = interfaceinvoke v8.<javax.lang.model.element.ExecutableElement: java.util.Set getModifiers()>();
v14 = <javax.lang.model.element.Modifier: javax.lang.model.element.Modifier STATIC>;
v15 = interfaceinvoke v13.<java.util.Set: boolean contains(java.lang.Object)>(v14);
if v15 != 0 goto label01;
v16 = interfaceinvoke v8.<javax.lang.model.element.ExecutableElement: java.util.Set getModifiers()>();
v17 = <javax.lang.model.element.Modifier: javax.lang.model.element.Modifier PUBLIC>;
v18 = interfaceinvoke v16.<java.util.Set: boolean contains(java.lang.Object)>(v17);
if v18 == 0 goto label01;
v19 = interfaceinvoke v8.<javax.lang.model.element.ExecutableElement: javax.lang.model.element.Name getSimpleName()>();
v20 = virtualinvoke v19.<java.lang.Object: java.lang.String toString()>();
v21 = virtualinvoke v20.<java.lang.String: boolean startsWith(java.lang.String)>("get");
if v21 == 0 goto label02;
v22 = virtualinvoke v20.<java.lang.String: int length()>();
if v22 <= 3 goto label02;
v23 = virtualinvoke v20.<java.lang.String: char charAt(int)>(3);
v24 = staticinvoke <java.lang.Character: boolean isUpperCase(char)>(v23);
if v24 == 0 goto label02;
v25 = interfaceinvoke v8.<javax.lang.model.element.ExecutableElement: java.util.List getParameters()>();
v26 = interfaceinvoke v25.<java.util.List: boolean isEmpty()>();
if v26 == 0 goto label02;
v27 = interfaceinvoke v8.<javax.lang.model.element.ExecutableElement: javax.lang.model.type.TypeMirror getReturnType()>();
v28 = interfaceinvoke v27.<javax.lang.model.type.TypeMirror: javax.lang.model.type.TypeKind getKind()>();
v29 = <javax.lang.model.type.TypeKind: javax.lang.model.type.TypeKind VOID>;
if v28 == v29 goto label02;
v30 = virtualinvoke v20.<java.lang.String: java.lang.String substring(int)>(3);
v31 = staticinvoke <io.vertx.codegen.Helper: java.lang.String normalizePropertyName(java.lang.String)>(v30);
interfaceinvoke v2.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>(v31, v8);
v32 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.util.Elements elementUtils>;
v33 = interfaceinvoke v32.<javax.lang.model.util.Elements: java.util.List getAllAnnotationMirrors(javax.lang.model.element.Element)>(v8);
interfaceinvoke v5.<java.util.Map: java.lang.Object merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)>(v31, v33, v6);
goto label01;
label02:
v34 = virtualinvoke v20.<java.lang.String: boolean startsWith(java.lang.String)>("is");
if v34 == 0 goto label03;
v35 = virtualinvoke v20.<java.lang.String: int length()>();
if v35 <= 2 goto label03;
v36 = virtualinvoke v20.<java.lang.String: char charAt(int)>(2);
v37 = staticinvoke <java.lang.Character: boolean isUpperCase(char)>(v36);
if v37 == 0 goto label03;
v38 = interfaceinvoke v8.<javax.lang.model.element.ExecutableElement: java.util.List getParameters()>();
v39 = interfaceinvoke v38.<java.util.List: boolean isEmpty()>();
if v39 == 0 goto label03;
v40 = interfaceinvoke v8.<javax.lang.model.element.ExecutableElement: javax.lang.model.type.TypeMirror getReturnType()>();
v41 = interfaceinvoke v40.<javax.lang.model.type.TypeMirror: javax.lang.model.type.TypeKind getKind()>();
v42 = <javax.lang.model.type.TypeKind: javax.lang.model.type.TypeKind VOID>;
if v41 == v42 goto label03;
v43 = virtualinvoke v20.<java.lang.String: java.lang.String substring(int)>(2);
v44 = staticinvoke <io.vertx.codegen.Helper: java.lang.String normalizePropertyName(java.lang.String)>(v43);
interfaceinvoke v2.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>(v44, v8);
v45 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.util.Elements elementUtils>;
v46 = interfaceinvoke v45.<javax.lang.model.util.Elements: java.util.List getAllAnnotationMirrors(javax.lang.model.element.Element)>(v8);
interfaceinvoke v5.<java.util.Map: java.lang.Object merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)>(v44, v46, v6);
goto label01;
label03:
v47 = virtualinvoke v20.<java.lang.String: boolean startsWith(java.lang.String)>("set");
if v47 != 0 goto label04;
v48 = virtualinvoke v20.<java.lang.String: boolean startsWith(java.lang.String)>("add");
if v48 == 0 goto label01;
label04:
v49 = virtualinvoke v20.<java.lang.String: int length()>();
if v49 <= 3 goto label01;
v50 = virtualinvoke v20.<java.lang.String: char charAt(int)>(3);
v51 = staticinvoke <java.lang.Character: boolean isUpperCase(char)>(v50);
if v51 == 0 goto label01;
v52 = virtualinvoke v20.<java.lang.String: java.lang.String substring(int,int)>(0, 3);
v53 = virtualinvoke v20.<java.lang.String: java.lang.String substring(int)>(3);
v54 = staticinvoke <io.vertx.codegen.Helper: java.lang.String normalizePropertyName(java.lang.String)>(v53);
v55 = interfaceinvoke v8.<javax.lang.model.element.ExecutableElement: java.util.List getParameters()>();
v56 = interfaceinvoke v55.<java.util.List: int size()>();
v57 = "add";
v58 = virtualinvoke v57.<java.lang.String: boolean equals(java.lang.Object)>(v52);
if v58 == 0 goto label07;
v59 = virtualinvoke v54.<java.lang.String: boolean endsWith(java.lang.String)>("s");
if v59 == 0 goto label05;
v60 = new io.vertx.codegen.GenException;
specialinvoke v60.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v8, "Option adder name must not terminate with \'s\' char");
throw v60;
label05:
v61 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v54) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001s");
v62 = interfaceinvoke v8.<javax.lang.model.element.ExecutableElement: java.util.List getParameters()>();
v63 = interfaceinvoke v62.<java.util.List: java.lang.Object get(int)>(0);
v64 = interfaceinvoke v63.<javax.lang.model.element.VariableElement: javax.lang.model.type.TypeMirror asType()>();
if v56 == 1 goto label06;
if v56 != 2 goto label01;
v65 = interfaceinvoke v64.<javax.lang.model.type.TypeMirror: javax.lang.model.type.TypeKind getKind()>();
v66 = <javax.lang.model.type.TypeKind: javax.lang.model.type.TypeKind DECLARED>;
if v65 != v66 goto label01;
v67 = interfaceinvoke v64.<javax.lang.model.type.DeclaredType: javax.lang.model.element.Element asElement()>();
v68 = interfaceinvoke v67.<javax.lang.model.element.TypeElement: javax.lang.model.element.Name getQualifiedName()>();
v69 = virtualinvoke v68.<java.lang.Object: java.lang.String toString()>();
v70 = virtualinvoke v69.<java.lang.String: boolean equals(java.lang.Object)>("java.lang.String");
if v70 == 0 goto label01;
label06:
interfaceinvoke v4.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>(v61, v8);
v71 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.util.Elements elementUtils>;
v72 = interfaceinvoke v71.<javax.lang.model.util.Elements: java.util.List getAllAnnotationMirrors(javax.lang.model.element.Element)>(v8);
interfaceinvoke v5.<java.util.Map: java.lang.Object merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)>(v61, v72, v6);
goto label01;
label07:
if v56 != 1 goto label01;
interfaceinvoke v3.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>(v54, v8);
v73 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.util.Elements elementUtils>;
v74 = interfaceinvoke v73.<javax.lang.model.util.Elements: java.util.List getAllAnnotationMirrors(javax.lang.model.element.Element)>(v8);
interfaceinvoke v5.<java.util.Map: java.lang.Object merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)>(v54, v74, v6);
goto label01;
label08:
v75 = new java.util.HashSet;
specialinvoke v75.<java.util.HashSet: void <init>()>();
v76 = interfaceinvoke v2.<java.util.Map: java.util.Set keySet()>();
interfaceinvoke v75.<java.util.Set: boolean addAll(java.util.Collection)>(v76);
v77 = interfaceinvoke v3.<java.util.Map: java.util.Set keySet()>();
interfaceinvoke v75.<java.util.Set: boolean addAll(java.util.Collection)>(v77);
v78 = interfaceinvoke v4.<java.util.Map: java.util.Set keySet()>();
interfaceinvoke v75.<java.util.Set: boolean addAll(java.util.Collection)>(v78);
v79 = interfaceinvoke v75.<java.util.Set: java.util.Iterator iterator()>();
label09:
v80 = interfaceinvoke v79.<java.util.Iterator: boolean hasNext()>();
if v80 == 0 goto label10;
v81 = interfaceinvoke v79.<java.util.Iterator: java.lang.Object next()>();
v82 = virtualinvoke v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.Element getElement()>();
v83 = interfaceinvoke v82.<javax.lang.model.element.Element: java.util.List getEnclosedElements()>();
v84 = interfaceinvoke v83.<java.util.List: java.util.stream.Stream stream()>();
v85 = staticinvoke <io.vertx.codegen.DataObjectModel$lambda_processMethods_7__2417: java.util.function.Predicate bootstrap$(java.lang.String)>(v81);
v86 = interfaceinvoke v84.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v85);
v87 = staticinvoke <io.vertx.codegen.DataObjectModel$lambda_processMethods_8__2418: java.util.function.Function bootstrap$(io.vertx.codegen.DataObjectModel)>(v0);
v88 = interfaceinvoke v86.<java.util.stream.Stream: java.util.stream.Stream flatMap(java.util.function.Function)>(v87);
v89 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector toList()>();
v90 = interfaceinvoke v88.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v89);
v91 = interfaceinvoke v90.<java.util.List: int size()>();
if v91 <= 0 goto label09;
interfaceinvoke v5.<java.util.Map: java.lang.Object merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)>(v81, v90, v6);
goto label09;
label10:
v92 = interfaceinvoke v75.<java.util.Set: java.util.Iterator iterator()>();
label11:
v93 = interfaceinvoke v92.<java.util.Iterator: boolean hasNext()>();
if v93 == 0 goto label12;
v94 = interfaceinvoke v92.<java.util.Iterator: java.lang.Object next()>();
v95 = interfaceinvoke v2.<java.util.Map: java.lang.Object get(java.lang.Object)>(v94);
v96 = interfaceinvoke v3.<java.util.Map: java.lang.Object get(java.lang.Object)>(v94);
v97 = interfaceinvoke v4.<java.util.Map: java.lang.Object get(java.lang.Object)>(v94);
v98 = interfaceinvoke v5.<java.util.Map: java.lang.Object get(java.lang.Object)>(v94);
specialinvoke v0.<io.vertx.codegen.DataObjectModel: void processMethod(java.lang.String,javax.lang.model.element.ExecutableElement,javax.lang.model.element.ExecutableElement,javax.lang.model.element.ExecutableElement,java.util.List)>(v94, v95, v96, v97, v98);
goto label11;
label12:
return;
}
private void processMethod(java.lang.String, javax.lang.model.element.ExecutableElement, javax.lang.model.element.ExecutableElement, javax.lang.model.element.ExecutableElement, java.util.List)
{
javax.lang.model.util.Elements v139;
io.vertx.codegen.type.DataObjectInfo v88;
io.vertx.codegen.type.AnnotationValueInfoFactory v124;
java.util.Map v152;
javax.lang.model.element.Element v109;
java.util.stream.Stream v104, v106, v114, v116, v123, v126, v130, v132;
java.lang.Object[] v117;
javax.lang.model.element.ExecutableElement[] v93;
int[] v16, v33, v75;
io.vertx.codegen.type.ClassKind v13, v28, v76;
io.vertx.codegen.type.TypeInfo v12, v145, v27, v56, v68;
java.lang.'annotation'.Annotation v120, v14, v31, v48;
io.vertx.codegen.PropertyKind v29, v57, v58, v6, v69, v79;
java.util.function.Function v103, v125, v142, v98;
int v118, v17, v18, v34, v35, v51, v77, v78;
java.lang.Boolean v100, v112;
io.vertx.codegen.DataObjectModel v0;
javax.lang.model.element.ExecutableElement v2, v3, v4;
java.util.function.Consumer v127;
javax.lang.model.type.TypeMirror v10, v25, v54, v66;
java.lang.Class v82;
java.lang.Object v101, v108, v113, v136, v20, v22, v37, v39, v53, v65, v9, v97;
javax.lang.model.element.TypeElement v110, v141;
io.vertx.codegen.type.TypeMirrorFactory v11, v26, v55, v67;
io.vertx.codegen.doc.Doc v92;
java.util.ArrayList v122;
io.vertx.codegen.GenException v42, v45, v59, v62, v70, v73;
java.lang.String v1, v137, v138, v147, v149, v151, v153, v43, v46, v60, v63, v71, v74, v81, v83, v85;
io.vertx.codegen.doc.Doc$Factory v102, v99;
io.vertx.codegen.doc.Text v128, v135;
boolean v111, v119, v121, v134, v144, v15, v30, v32, v44, v47, v49, v61, v7, v72, v80, v84, v86, v87, v89, v90, v91, v96;
io.vertx.codegen.PropertyInfo v143;
java.util.function.Predicate v105, v115, v131;
javax.lang.model.util.Types v140;
java.util.List v129, v19, v21, v23, v24, v36, v38, v40, v41, v5, v50, v52, v64, v8, v94;
java.util.Optional v107, v133;
javax.lang.model.element.Name v146, v148, v150;
java.util.Iterator v95;
v0 := @this: io.vertx.codegen.DataObjectModel;
v1 := @parameter0: java.lang.String;
v2 := @parameter1: javax.lang.model.element.ExecutableElement;
v3 := @parameter2: javax.lang.model.element.ExecutableElement;
v4 := @parameter3: javax.lang.model.element.ExecutableElement;
v5 := @parameter4: java.util.List;
v6 = null;
v7 = 0;
if v3 == null goto label05;
v8 = interfaceinvoke v3.<javax.lang.model.element.ExecutableElement: java.util.List getParameters()>();
v9 = interfaceinvoke v8.<java.util.List: java.lang.Object get(int)>(0);
v10 = interfaceinvoke v9.<javax.lang.model.element.VariableElement: javax.lang.model.type.TypeMirror asType()>();
v11 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.TypeMirrorFactory typeFactory>;
v12 = virtualinvoke v11.<io.vertx.codegen.type.TypeMirrorFactory: io.vertx.codegen.type.TypeInfo create(javax.lang.model.type.TypeMirror)>(v10);
v13 = virtualinvoke v12.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v6 = staticinvoke <io.vertx.codegen.PropertyKind: io.vertx.codegen.PropertyKind forType(io.vertx.codegen.type.ClassKind)>(v13);
v14 = interfaceinvoke v3.<javax.lang.model.element.ExecutableElement: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Ljava/lang/Deprecated;");
if v14 == null goto label01;
v15 = 1;
goto label02;
label01:
v15 = 0;
label02:
v7 = 0 | v15;
v16 = <io.vertx.codegen.DataObjectModel$1: int[] $SwitchMap$io$vertx$codegen$PropertyKind>;
v17 = virtualinvoke v6.<io.vertx.codegen.PropertyKind: int ordinal()>();
v18 = v16[v17];
tableswitch(v18)
{
case 1: goto label03;
case 2: goto label03;
case 3: goto label04;
default: goto label05;
};
label03:
v19 = virtualinvoke v12.<io.vertx.codegen.type.ParameterizedTypeInfo: java.util.List getArgs()>();
v20 = interfaceinvoke v19.<java.util.List: java.lang.Object get(int)>(0);
v21 = interfaceinvoke v10.<javax.lang.model.type.DeclaredType: java.util.List getTypeArguments()>();
v22 = interfaceinvoke v21.<java.util.List: java.lang.Object get(int)>(0);
goto label05;
label04:
v23 = virtualinvoke v12.<io.vertx.codegen.type.ParameterizedTypeInfo: java.util.List getArgs()>();
interfaceinvoke v23.<java.util.List: java.lang.Object get(int)>(1);
v24 = interfaceinvoke v10.<javax.lang.model.type.DeclaredType: java.util.List getTypeArguments()>();
interfaceinvoke v24.<java.util.List: java.lang.Object get(int)>(1);
label05:
if v2 == null goto label13;
v25 = interfaceinvoke v2.<javax.lang.model.element.ExecutableElement: javax.lang.model.type.TypeMirror getReturnType()>();
v26 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.TypeMirrorFactory typeFactory>;
v27 = virtualinvoke v26.<io.vertx.codegen.type.TypeMirrorFactory: io.vertx.codegen.type.TypeInfo create(javax.lang.model.type.TypeMirror)>(v25);
v28 = virtualinvoke v27.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v29 = staticinvoke <io.vertx.codegen.PropertyKind: io.vertx.codegen.PropertyKind forType(io.vertx.codegen.type.ClassKind)>(v28);
v30 = v7;
v31 = interfaceinvoke v2.<javax.lang.model.element.ExecutableElement: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Ljava/lang/Deprecated;");
if v31 == null goto label06;
v32 = 1;
goto label07;
label06:
v32 = 0;
label07:
v7 = v30 | v32;
v33 = <io.vertx.codegen.DataObjectModel$1: int[] $SwitchMap$io$vertx$codegen$PropertyKind>;
v34 = virtualinvoke v29.<io.vertx.codegen.PropertyKind: int ordinal()>();
v35 = v33[v34];
tableswitch(v35)
{
case 1: goto label08;
case 2: goto label08;
case 3: goto label09;
default: goto label10;
};
label08:
v36 = virtualinvoke v27.<io.vertx.codegen.type.ParameterizedTypeInfo: java.util.List getArgs()>();
v37 = interfaceinvoke v36.<java.util.List: java.lang.Object get(int)>(0);
v38 = interfaceinvoke v25.<javax.lang.model.type.DeclaredType: java.util.List getTypeArguments()>();
v39 = interfaceinvoke v38.<java.util.List: java.lang.Object get(int)>(0);
goto label10;
label09:
v40 = virtualinvoke v27.<io.vertx.codegen.type.ParameterizedTypeInfo: java.util.List getArgs()>();
interfaceinvoke v40.<java.util.List: java.lang.Object get(int)>(1);
v41 = interfaceinvoke v25.<javax.lang.model.type.DeclaredType: java.util.List getTypeArguments()>();
interfaceinvoke v41.<java.util.List: java.lang.Object get(int)>(1);
label10:
if v20 == null goto label12;
if v6 == v29 goto label11;
v42 = new io.vertx.codegen.GenException;
v43 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,io.vertx.codegen.PropertyKind,io.vertx.codegen.PropertyKind)>(v1, v29, v6) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001 getter \u0001 does not match the setter \u0001");
specialinvoke v42.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v2, v43);
throw v42;
label11:
v44 = virtualinvoke v37.<io.vertx.codegen.type.TypeInfo: boolean equals(java.lang.Object)>(v20);
if v44 != 0 goto label13;
v45 = new io.vertx.codegen.GenException;
v46 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.type.TypeInfo)>(v1, v37, v20) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001 getter type \u0001 does not match the setter type \u0001");
specialinvoke v45.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v2, v46);
throw v45;
label12:
v22 = v39;
v20 = v37;
v6 = v29;
label13:
if v4 == null goto label22;
v47 = v7;
v48 = interfaceinvoke v4.<javax.lang.model.element.ExecutableElement: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Ljava/lang/Deprecated;");
if v48 == null goto label14;
v49 = 1;
goto label15;
label14:
v49 = 0;
label15:
v7 = v47 | v49;
v50 = interfaceinvoke v4.<javax.lang.model.element.ExecutableElement: java.util.List getParameters()>();
v51 = interfaceinvoke v50.<java.util.List: int size()>();
lookupswitch(v51)
{
case 1: goto label16;
case 2: goto label19;
default: goto label22;
};
label16:
v52 = interfaceinvoke v4.<javax.lang.model.element.ExecutableElement: java.util.List getParameters()>();
v53 = interfaceinvoke v52.<java.util.List: java.lang.Object get(int)>(0);
v54 = interfaceinvoke v53.<javax.lang.model.element.VariableElement: javax.lang.model.type.TypeMirror asType()>();
v55 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.TypeMirrorFactory typeFactory>;
v56 = virtualinvoke v55.<io.vertx.codegen.type.TypeMirrorFactory: io.vertx.codegen.type.TypeInfo create(javax.lang.model.type.TypeMirror)>(v54);
if v22 == null goto label18;
v57 = <io.vertx.codegen.PropertyKind: io.vertx.codegen.PropertyKind LIST>;
if v6 == v57 goto label17;
v58 = <io.vertx.codegen.PropertyKind: io.vertx.codegen.PropertyKind SET>;
if v6 == v58 goto label17;
v59 = new io.vertx.codegen.GenException;
v60 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v1) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001adder does not correspond to non list/set");
specialinvoke v59.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v4, v60);
throw v59;
label17:
v61 = virtualinvoke v56.<io.vertx.codegen.type.TypeInfo: boolean equals(java.lang.Object)>(v20);
if v61 != 0 goto label22;
v62 = new io.vertx.codegen.GenException;
v63 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.type.TypeInfo)>(v1, v56, v20) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001 adder type \u0001  does not match the property type \u0001");
specialinvoke v62.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v4, v63);
throw v62;
label18:
v20 = v56;
v6 = <io.vertx.codegen.PropertyKind: io.vertx.codegen.PropertyKind LIST>;
goto label22;
label19:
v64 = interfaceinvoke v4.<javax.lang.model.element.ExecutableElement: java.util.List getParameters()>();
v65 = interfaceinvoke v64.<java.util.List: java.lang.Object get(int)>(1);
v66 = interfaceinvoke v65.<javax.lang.model.element.VariableElement: javax.lang.model.type.TypeMirror asType()>();
v67 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.TypeMirrorFactory typeFactory>;
v68 = virtualinvoke v67.<io.vertx.codegen.type.TypeMirrorFactory: io.vertx.codegen.type.TypeInfo create(javax.lang.model.type.TypeMirror)>(v66);
if v22 == null goto label21;
v69 = <io.vertx.codegen.PropertyKind: io.vertx.codegen.PropertyKind MAP>;
if v6 == v69 goto label20;
v70 = new io.vertx.codegen.GenException;
v71 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v1) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001adder does not correspond to non map");
specialinvoke v70.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v4, v71);
throw v70;
label20:
v72 = virtualinvoke v68.<io.vertx.codegen.type.TypeInfo: boolean equals(java.lang.Object)>(v20);
if v72 != 0 goto label22;
v73 = new io.vertx.codegen.GenException;
v74 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,io.vertx.codegen.type.TypeInfo,io.vertx.codegen.type.TypeInfo)>(v1, v68, v20) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001 adder type \u0001  does not match the property type \u0001");
specialinvoke v73.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v4, v74);
throw v73;
label21:
v20 = v68;
v6 = <io.vertx.codegen.PropertyKind: io.vertx.codegen.PropertyKind MAP>;
label22:
v75 = <io.vertx.codegen.DataObjectModel$1: int[] $SwitchMap$io$vertx$codegen$type$ClassKind>;
v76 = virtualinvoke v20.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.ClassKind getKind()>();
v77 = virtualinvoke v76.<io.vertx.codegen.type.ClassKind: int ordinal()>();
v78 = v75[v77];
tableswitch(v78)
{
case 1: goto label24;
case 2: goto label24;
case 3: goto label23;
case 4: goto label24;
case 5: goto label24;
case 6: goto label24;
case 7: goto label24;
case 8: goto label25;
case 9: goto label25;
default: goto label29;
};
label23:
v79 = <io.vertx.codegen.PropertyKind: io.vertx.codegen.PropertyKind VALUE>;
if v6 != v79 goto label24;
return;
label24:
v80 = 1;
goto label30;
label25:
v81 = virtualinvoke v20.<io.vertx.codegen.type.TypeInfo: java.lang.String getName()>();
v82 = class "Ljava/time/Instant;";
v83 = virtualinvoke v82.<java.lang.Class: java.lang.String getName()>();
v84 = virtualinvoke v81.<java.lang.String: boolean equals(java.lang.Object)>(v83);
if v84 != 0 goto label26;
v85 = virtualinvoke v20.<io.vertx.codegen.type.TypeInfo: java.lang.String getName()>();
v86 = virtualinvoke v85.<java.lang.String: boolean equals(java.lang.Object)>("io.vertx.core.buffer.Buffer");
if v86 != 0 goto label26;
v87 = virtualinvoke v20.<io.vertx.codegen.type.TypeInfo: boolean isDataObjectHolder()>();
if v87 == 0 goto label27;
v88 = virtualinvoke v20.<io.vertx.codegen.type.TypeInfo: io.vertx.codegen.type.DataObjectInfo getDataObject()>();
v89 = virtualinvoke v88.<io.vertx.codegen.type.DataObjectInfo: boolean isSerializable()>();
if v89 == 0 goto label27;
label26:
v90 = 1;
goto label28;
label27:
v90 = 0;
label28:
v80 = v90;
goto label30;
label29:
return;
label30:
v91 = 0;
v92 = null;
v93 = newarray (javax.lang.model.element.ExecutableElement)[3];
v93[0] = v3;
v93[1] = v4;
v93[2] = v2;
v94 = staticinvoke <java.util.Arrays: java.util.List asList(java.lang.Object[])>(v93);
v95 = interfaceinvoke v94.<java.util.List: java.util.Iterator iterator()>();
label31:
v96 = interfaceinvoke v95.<java.util.Iterator: boolean hasNext()>();
if v96 == 0 goto label38;
v97 = interfaceinvoke v95.<java.util.Iterator: java.lang.Object next()>();
if v97 == null goto label31;
v98 = staticinvoke <io.vertx.codegen.DataObjectModel$lambda_processMethod_12__2422: java.util.function.Function bootstrap$(io.vertx.codegen.DataObjectModel,javax.lang.model.element.ExecutableElement)>(v0, v97);
if v92 != null goto label32;
v99 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.doc.Doc$Factory docFactory>;
v92 = virtualinvoke v99.<io.vertx.codegen.doc.Doc$Factory: io.vertx.codegen.doc.Doc createDoc(javax.lang.model.element.Element)>(v97);
if v92 != null goto label32;
v100 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>(0);
v101 = interfaceinvoke v98.<java.util.function.Function: java.lang.Object apply(java.lang.Object)>(v100);
v102 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.doc.Doc$Factory docFactory>;
virtualinvoke v102.<java.lang.Object: java.lang.Class getClass()>();
v103 = staticinvoke <io.vertx.codegen.DataObjectModel$createDoc__2424: java.util.function.Function bootstrap$(io.vertx.codegen.doc.Doc$Factory)>(v102);
v104 = interfaceinvoke v101.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v103);
v105 = staticinvoke <io.vertx.codegen.DataObjectModel$lambda_processMethod_13__2425: java.util.function.Predicate bootstrap$()>();
v106 = interfaceinvoke v104.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v105);
v107 = interfaceinvoke v106.<java.util.stream.Stream: java.util.Optional findFirst()>();
v108 = virtualinvoke v107.<java.util.Optional: java.lang.Object orElse(java.lang.Object)>(null);
label32:
if v91 != 0 goto label31;
v109 = interfaceinvoke v97.<javax.lang.model.element.ExecutableElement: javax.lang.model.element.Element getEnclosingElement()>();
v110 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.TypeElement modelElt>;
v111 = interfaceinvoke v109.<javax.lang.model.element.Element: boolean equals(java.lang.Object)>(v110);
if v111 == 0 goto label35;
v112 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>(1);
v113 = interfaceinvoke v98.<java.util.function.Function: java.lang.Object apply(java.lang.Object)>(v112);
v114 = interfaceinvoke v113.<java.util.stream.Stream: java.util.stream.Stream limit(long)>(1L);
v115 = staticinvoke <io.vertx.codegen.DataObjectModel$lambda_processMethod_14__2423: java.util.function.Predicate bootstrap$()>();
v116 = interfaceinvoke v114.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v115);
v117 = interfaceinvoke v116.<java.util.stream.Stream: java.lang.Object[] toArray()>();
v118 = lengthof v117;
if v118 != 0 goto label33;
v119 = 1;
goto label34;
label33:
v119 = 0;
label34:
v91 = v119;
goto label31;
label35:
v120 = interfaceinvoke v109.<javax.lang.model.element.Element: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Lio/vertx/codegen/annotations/DataObject;");
if v120 != null goto label36;
v121 = 1;
goto label37;
label36:
v121 = 0;
label37:
v91 = v121;
goto label31;
label38:
v122 = new java.util.ArrayList;
specialinvoke v122.<java.util.ArrayList: void <init>()>();
if v5 == null goto label39;
v123 = interfaceinvoke v5.<java.util.List: java.util.stream.Stream stream()>();
v124 = v0.<io.vertx.codegen.DataObjectModel: io.vertx.codegen.type.AnnotationValueInfoFactory annotationValueInfoFactory>;
virtualinvoke v124.<java.lang.Object: java.lang.Class getClass()>();
v125 = staticinvoke <io.vertx.codegen.DataObjectModel$processAnnotation__2420: java.util.function.Function bootstrap$(io.vertx.codegen.type.AnnotationValueInfoFactory)>(v124);
v126 = interfaceinvoke v123.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v125);
virtualinvoke v122.<java.lang.Object: java.lang.Class getClass()>();
v127 = staticinvoke <io.vertx.codegen.DataObjectModel$add__2421: java.util.function.Consumer bootstrap$(java.util.List)>(v122);
interfaceinvoke v126.<java.util.stream.Stream: void forEach(java.util.function.Consumer)>(v127);
label39:
v128 = null;
if v108 == null goto label40;
v129 = virtualinvoke v108.<io.vertx.codegen.doc.Doc: java.util.List getBlockTags()>();
v130 = interfaceinvoke v129.<java.util.List: java.util.stream.Stream stream()>();
v131 = staticinvoke <io.vertx.codegen.DataObjectModel$lambda_processMethod_15__2419: java.util.function.Predicate bootstrap$()>();
v132 = interfaceinvoke v130.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v131);
v133 = interfaceinvoke v132.<java.util.stream.Stream: java.util.Optional findFirst()>();
v134 = virtualinvoke v133.<java.util.Optional: boolean isPresent()>();
if v134 == 0 goto label40;
v135 = new io.vertx.codegen.doc.Text;
v136 = virtualinvoke v133.<java.util.Optional: java.lang.Object get()>();
v137 = virtualinvoke v136.<io.vertx.codegen.doc.Tag: java.lang.String getValue()>();
v138 = staticinvoke <io.vertx.codegen.Helper: java.lang.String normalizeWhitespaces(java.lang.String)>(v137);
specialinvoke v135.<io.vertx.codegen.doc.Text: void <init>(java.lang.String)>(v138);
v139 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.util.Elements elementUtils>;
v140 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.util.Types typeUtils>;
v141 = v0.<io.vertx.codegen.DataObjectModel: javax.lang.model.element.TypeElement modelElt>;
v142 = staticinvoke <io.vertx.codegen.doc.Token: java.util.function.Function tagMapper(javax.lang.model.util.Elements,javax.lang.model.util.Types,javax.lang.model.element.TypeElement)>(v139, v140, v141);
v128 = virtualinvoke v135.<io.vertx.codegen.doc.Text: io.vertx.codegen.doc.Text map(java.util.function.Function)>(v142);
label40:
v143 = new io.vertx.codegen.PropertyInfo;
v144 = v91;
v145 = v20;
if v3 == null goto label41;
v146 = interfaceinvoke v3.<javax.lang.model.element.ExecutableElement: javax.lang.model.element.Name getSimpleName()>();
v147 = virtualinvoke v146.<java.lang.Object: java.lang.String toString()>();
goto label42;
label41:
v147 = null;
label42:
if v4 == null goto label43;
v148 = interfaceinvoke v4.<javax.lang.model.element.ExecutableElement: javax.lang.model.element.Name getSimpleName()>();
v149 = virtualinvoke v148.<java.lang.Object: java.lang.String toString()>();
goto label44;
label43:
v149 = null;
label44:
if v2 == null goto label45;
v150 = interfaceinvoke v2.<javax.lang.model.element.ExecutableElement: javax.lang.model.element.Name getSimpleName()>();
v151 = virtualinvoke v150.<java.lang.Object: java.lang.String toString()>();
goto label46;
label45:
v151 = null;
label46:
specialinvoke v143.<io.vertx.codegen.PropertyInfo: void <init>(boolean,java.lang.String,io.vertx.codegen.doc.Doc,io.vertx.codegen.type.TypeInfo,java.lang.String,java.lang.String,java.lang.String,java.util.List,io.vertx.codegen.PropertyKind,boolean,boolean,io.vertx.codegen.doc.Text)>(v144, v1, v108, v145, v147, v149, v151, v122, v6, v80, v7, v128);
v152 = v0.<io.vertx.codegen.DataObjectModel: java.util.Map propertyMap>;
v153 = v143.<io.vertx.codegen.PropertyInfo: java.lang.String name>;
interfaceinvoke v152.<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>(v153, v143);
return;
}
}