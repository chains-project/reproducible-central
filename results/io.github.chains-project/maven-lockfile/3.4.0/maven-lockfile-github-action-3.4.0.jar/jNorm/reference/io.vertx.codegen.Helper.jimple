public class io.vertx.codegen.Helper extends java.lang.Object
{
public static final java.util.function.Function FILTER_METHOD;
public static final java.util.function.Function FILTER_FIELD;
static final java.util.function.Function CAST;
private static final java.util.regex.Pattern SIGNATURE_PATTERN;
public static final java.util.regex.Pattern LINK_REFERENCE_PATTERN;
private static final java.util.regex.Pattern WHITESPACE_CLUSTER_PATTERN;
private static final java.util.Set dataObjectTypes;
public void <init>()
{
io.vertx.codegen.Helper v0;
v0 := @this: io.vertx.codegen.Helper;
specialinvoke v0.<java.lang.Object: void <init>()>();
return;
}
static java.util.function.Function instanceOf(java.lang.Class)
{
java.lang.Class v0;
java.util.function.Function v1;
v0 := @parameter0: java.lang.Class;
v1 = staticinvoke <io.vertx.codegen.Helper$lambda_instanceOf_2__2444: java.util.function.Function bootstrap$(java.lang.Class)>(v0);
return v1;
}
static java.util.function.Function cast(java.lang.Class)
{
java.lang.Class v0;
java.util.function.Function v1;
v0 := @parameter0: java.lang.Class;
v1 = staticinvoke <io.vertx.codegen.Helper$lambda_cast_3__2445: java.util.function.Function bootstrap$(java.lang.Class)>(v0);
return v1;
}
public static java.lang.String normalizePropertyName(java.lang.String)
{
int v12, v13, v14, v4, v5, v6, v9;
java.lang.String v0;
boolean v11, v16, v2;
char v1, v10, v15, v7, v8;
java.lang.StringBuilder v3;
v0 := @parameter0: java.lang.String;
v1 = virtualinvoke v0.<java.lang.String: char charAt(int)>(0);
v2 = staticinvoke <java.lang.Character: boolean isUpperCase(char)>(v1);
if v2 == 0 goto label3;
v3 = new java.lang.StringBuilder;
specialinvoke v3.<java.lang.StringBuilder: void <init>(java.lang.String)>(v0);
v4 = 0;
label1:
v5 = v4;
v6 = v4;
v4 = v4 + 1;
v7 = virtualinvoke v3.<java.lang.StringBuilder: char charAt(int)>(v6);
v8 = staticinvoke <java.lang.Character: char toLowerCase(char)>(v7);
virtualinvoke v3.<java.lang.StringBuilder: void setCharAt(int,char)>(v5, v8);
v9 = virtualinvoke v3.<java.lang.StringBuilder: int length()>();
if v4 >= v9 goto label2;
v10 = virtualinvoke v3.<java.lang.StringBuilder: char charAt(int)>(v4);
v11 = staticinvoke <java.lang.Character: boolean isUpperCase(char)>(v10);
if v11 == 0 goto label2;
v12 = v4 + 1;
v13 = virtualinvoke v3.<java.lang.StringBuilder: int length()>();
if v12 >= v13 goto label1;
v14 = v4 + 1;
v15 = virtualinvoke v3.<java.lang.StringBuilder: char charAt(int)>(v14);
v16 = staticinvoke <java.lang.Character: boolean isLowerCase(char)>(v15);
if v16 == 0 goto label1;
label2:
v0 = virtualinvoke v3.<java.lang.StringBuilder: java.lang.String toString()>();
label3:
return v0;
}
public static java.lang.String decapitaliseFirstLetter(java.lang.String)
{
int v1;
java.lang.String v0, v2, v3, v4, v5;
v0 := @parameter0: java.lang.String;
v1 = virtualinvoke v0.<java.lang.String: int length()>();
if v1 != 0 goto label1;
return v0;
label1:
v2 = virtualinvoke v0.<java.lang.String: java.lang.String substring(int,int)>(0, 1);
v3 = virtualinvoke v2.<java.lang.String: java.lang.String toLowerCase()>();
v4 = virtualinvoke v0.<java.lang.String: java.lang.String substring(int)>(1);
v5 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v3, v4) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001\u0001");
return v5;
}
public static java.lang.String convertCamelCaseToUnderscores(java.lang.String)
{
java.lang.String v0, v1, v2, v3;
v0 := @parameter0: java.lang.String;
v1 = virtualinvoke v0.<java.lang.String: java.lang.String replaceAll(java.lang.String,java.lang.String)>("([A-Z]+)([A-Z][a-z])", "$1_$2");
v2 = virtualinvoke v1.<java.lang.String: java.lang.String replaceAll(java.lang.String,java.lang.String)>("([a-z\\d])([A-Z])", "$1_$2");
v3 = virtualinvoke v2.<java.lang.String: java.lang.String toLowerCase()>();
return v3;
}
public static java.lang.String getSimpleName(java.lang.String)
{
int v1, v2;
java.lang.String v0, v3;
v0 := @parameter0: java.lang.String;
v1 = virtualinvoke v0.<java.lang.String: int lastIndexOf(int)>(46);
v2 = v1 + 1;
v3 = virtualinvoke v0.<java.lang.String: java.lang.String substring(int)>(v2);
return v3;
}
public static java.lang.String getPackageName(java.lang.String)
{
int v1;
java.lang.String v0, v2;
v0 := @parameter0: java.lang.String;
v1 = virtualinvoke v0.<java.lang.String: int lastIndexOf(int)>(46);
if v1 < 0 goto label1;
v2 = virtualinvoke v0.<java.lang.String: java.lang.String substring(int,int)>(0, v1);
return v2;
label1:
return "";
}
public static java.lang.String getNonGenericType(java.lang.String)
{
int v1;
java.lang.String v0, v2;
v0 := @parameter0: java.lang.String;
v1 = virtualinvoke v0.<java.lang.String: int indexOf(java.lang.String)>("<");
if v1 < 0 goto label1;
v2 = virtualinvoke v0.<java.lang.String: java.lang.String substring(int,int)>(0, v1);
return v2;
label1:
return v0;
}
public static java.lang.String indentString(java.lang.String, java.lang.String)
{
char v5;
int v3, v4, v6, v7;
java.lang.StringBuilder v2;
java.lang.String v0, v1, v8;
v0 := @parameter0: java.lang.String;
v1 := @parameter1: java.lang.String;
v2 = new java.lang.StringBuilder;
specialinvoke v2.<java.lang.StringBuilder: void <init>(java.lang.String)>(v1);
v3 = 0;
label1:
v4 = virtualinvoke v0.<java.lang.String: int length()>();
if v3 >= v4 goto label3;
v5 = virtualinvoke v0.<java.lang.String: char charAt(int)>(v3);
virtualinvoke v2.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(v5);
if v5 != 10 goto label2;
v6 = virtualinvoke v0.<java.lang.String: int length()>();
v7 = v6 - 1;
if v3 == v7 goto label2;
virtualinvoke v2.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(v1);
label2:
v3 = v3 + 1;
goto label1;
label3:
v8 = virtualinvoke v2.<java.lang.StringBuilder: java.lang.String toString()>();
return v8;
}
public static java.lang.String getJavadocTag(java.lang.String, java.lang.String)
{
int v2, v3, v4, v5, v6;
java.lang.String v0, v1, v7;
v0 := @parameter0: java.lang.String;
v1 := @parameter1: java.lang.String;
v2 = virtualinvoke v0.<java.lang.String: int indexOf(java.lang.String)>(v1);
v3 = virtualinvoke v0.<java.lang.String: int indexOf(java.lang.String,int)>("\n", v2);
v4 = virtualinvoke v1.<java.lang.String: int length()>();
v5 = v2 + v4;
v6 = v5 + 1;
v7 = virtualinvoke v0.<java.lang.String: java.lang.String substring(int,int)>(v6, v3);
return v7;
}
public static java.lang.String removeTags(java.lang.String)
{
int v1, v2, v4, v5;
java.lang.String v0, v3, v6;
v0 := @parameter0: java.lang.String;
v1 = virtualinvoke v0.<java.lang.String: int indexOf(int)>(64);
v2 = (int) -1;
if v1 != v2 goto label1;
return v0;
label1:
if v1 <= 0 goto label3;
v3 = virtualinvoke v0.<java.lang.String: java.lang.String substring(int,int)>(0, v1);
v4 = virtualinvoke v3.<java.lang.String: int lastIndexOf(int)>(10);
v5 = (int) -1;
if v4 == v5 goto label2;
v1 = v4;
goto label3;
label2:
v1 = 0;
label3:
v6 = virtualinvoke v0.<java.lang.String: java.lang.String substring(int,int)>(0, v1);
return v6;
}
public static javax.lang.model.element.AnnotationMirror resolveMethodAnnotation(java.lang.Class, javax.lang.model.util.Elements, javax.lang.model.util.Types, javax.lang.model.element.TypeElement, javax.lang.model.element.ExecutableElement)
{
javax.lang.model.element.ExecutableElement v4;
javax.lang.model.element.TypeElement v3, v6;
javax.lang.model.util.Types v2;
javax.lang.model.element.AnnotationMirror v8;
javax.lang.model.util.Elements v1;
javax.lang.model.type.TypeMirror v7;
java.lang.Class v0;
java.lang.String v5;
v0 := @parameter0: java.lang.Class;
v1 := @parameter1: javax.lang.model.util.Elements;
v2 := @parameter2: javax.lang.model.util.Types;
v3 := @parameter3: javax.lang.model.element.TypeElement;
v4 := @parameter4: javax.lang.model.element.ExecutableElement;
v5 = virtualinvoke v0.<java.lang.Class: java.lang.String getName()>();
v6 = interfaceinvoke v1.<javax.lang.model.util.Elements: javax.lang.model.element.TypeElement getTypeElement(java.lang.CharSequence)>(v5);
v7 = interfaceinvoke v6.<javax.lang.model.element.TypeElement: javax.lang.model.type.TypeMirror asType()>();
v8 = staticinvoke <io.vertx.codegen.Helper: javax.lang.model.element.AnnotationMirror resolveMethodAnnotation(javax.lang.model.type.DeclaredType,javax.lang.model.util.Elements,javax.lang.model.util.Types,javax.lang.model.element.TypeElement,javax.lang.model.element.ExecutableElement)>(v7, v1, v2, v3, v4);
return v8;
}
public static javax.lang.model.element.AnnotationMirror resolveMethodAnnotation(javax.lang.model.type.DeclaredType, javax.lang.model.util.Elements, javax.lang.model.util.Types, javax.lang.model.element.TypeElement, javax.lang.model.element.ExecutableElement)
{
java.util.function.Predicate v7;
javax.lang.model.element.ExecutableElement v4;
javax.lang.model.element.Element v12;
javax.lang.model.element.TypeElement v3;
javax.lang.model.util.Types v2;
javax.lang.model.element.AnnotationMirror v14;
javax.lang.model.util.Elements v1;
java.util.List v5;
javax.lang.model.type.TypeMirror v13;
java.util.stream.Stream v6, v8;
javax.lang.model.type.DeclaredType v0;
java.util.Optional v9;
java.lang.Object v11;
boolean v10;
v0 := @parameter0: javax.lang.model.type.DeclaredType;
v1 := @parameter1: javax.lang.model.util.Elements;
v2 := @parameter2: javax.lang.model.util.Types;
v3 := @parameter3: javax.lang.model.element.TypeElement;
v4 := @parameter4: javax.lang.model.element.ExecutableElement;
v5 = interfaceinvoke v4.<javax.lang.model.element.ExecutableElement: java.util.List getAnnotationMirrors()>();
v6 = interfaceinvoke v5.<java.util.List: java.util.stream.Stream stream()>();
v7 = staticinvoke <io.vertx.codegen.Helper$lambda_resolveMethodAnnotation_5__2446: java.util.function.Predicate bootstrap$(javax.lang.model.util.Types,javax.lang.model.type.DeclaredType)>(v2, v0);
v8 = interfaceinvoke v6.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v7);
v9 = interfaceinvoke v8.<java.util.stream.Stream: java.util.Optional findFirst()>();
v10 = virtualinvoke v9.<java.util.Optional: boolean isPresent()>();
if v10 == 0 goto label1;
v11 = virtualinvoke v9.<java.util.Optional: java.lang.Object get()>();
return v11;
label1:
v12 = interfaceinvoke v4.<javax.lang.model.element.ExecutableElement: javax.lang.model.element.Element getEnclosingElement()>();
v13 = interfaceinvoke v12.<javax.lang.model.element.Element: javax.lang.model.type.TypeMirror asType()>();
v14 = staticinvoke <io.vertx.codegen.Helper: javax.lang.model.element.AnnotationMirror isFluent(javax.lang.model.type.DeclaredType,javax.lang.model.util.Elements,javax.lang.model.util.Types,javax.lang.model.element.TypeElement,javax.lang.model.element.ExecutableElement,javax.lang.model.type.TypeMirror)>(v0, v1, v2, v3, v4, v13);
return v14;
}
private static javax.lang.model.element.AnnotationMirror isFluent(javax.lang.model.type.DeclaredType, javax.lang.model.util.Elements, javax.lang.model.util.Types, javax.lang.model.element.TypeElement, javax.lang.model.element.ExecutableElement, javax.lang.model.type.TypeMirror)
{
javax.lang.model.element.TypeElement v3;
java.util.function.Function v16;
javax.lang.model.util.Elements v1;
javax.lang.model.type.DeclaredType v0;
java.util.stream.Collector v18;
boolean v11, v21, v23, v8;
java.util.Iterator v20, v7;
java.util.function.Predicate v14;
javax.lang.model.element.ExecutableElement v4;
javax.lang.model.element.Element v10;
javax.lang.model.util.Types v2;
javax.lang.model.element.AnnotationMirror v24, v25;
java.util.List v12, v6;
javax.lang.model.type.TypeMirror v5;
java.util.stream.Stream v13, v15, v17;
java.lang.Object v19, v22, v9;
v0 := @parameter0: javax.lang.model.type.DeclaredType;
v1 := @parameter1: javax.lang.model.util.Elements;
v2 := @parameter2: javax.lang.model.util.Types;
v3 := @parameter3: javax.lang.model.element.TypeElement;
v4 := @parameter4: javax.lang.model.element.ExecutableElement;
v5 := @parameter5: javax.lang.model.type.TypeMirror;
v6 = interfaceinvoke v2.<javax.lang.model.util.Types: java.util.List directSupertypes(javax.lang.model.type.TypeMirror)>(v5);
v7 = interfaceinvoke v6.<java.util.List: java.util.Iterator iterator()>();
label1:
v8 = interfaceinvoke v7.<java.util.Iterator: boolean hasNext()>();
if v8 == 0 goto label4;
v9 = interfaceinvoke v7.<java.util.Iterator: java.lang.Object next()>();
v10 = interfaceinvoke v2.<javax.lang.model.util.Types: javax.lang.model.element.Element asElement(javax.lang.model.type.TypeMirror)>(v9);
v11 = v10 instanceof javax.lang.model.element.TypeElement;
if v11 == 0 goto label1;
v12 = interfaceinvoke v10.<javax.lang.model.element.TypeElement: java.util.List getEnclosedElements()>();
v13 = interfaceinvoke v12.<java.util.List: java.util.stream.Stream stream()>();
v14 = staticinvoke <io.vertx.codegen.Helper$lambda_isFluent_6__2447: java.util.function.Predicate bootstrap$()>();
v15 = interfaceinvoke v13.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v14);
v16 = staticinvoke <io.vertx.codegen.Helper$lambda_isFluent_7__2448: java.util.function.Function bootstrap$()>();
v17 = interfaceinvoke v15.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v16);
v18 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector toList()>();
v19 = interfaceinvoke v17.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v18);
v20 = interfaceinvoke v19.<java.util.List: java.util.Iterator iterator()>();
label2:
v21 = interfaceinvoke v20.<java.util.Iterator: boolean hasNext()>();
if v21 == 0 goto label3;
v22 = interfaceinvoke v20.<java.util.Iterator: java.lang.Object next()>();
v23 = interfaceinvoke v1.<javax.lang.model.util.Elements: boolean overrides(javax.lang.model.element.ExecutableElement,javax.lang.model.element.ExecutableElement,javax.lang.model.element.TypeElement)>(v4, v22, v3);
if v23 == 0 goto label2;
v24 = staticinvoke <io.vertx.codegen.Helper: javax.lang.model.element.AnnotationMirror resolveMethodAnnotation(javax.lang.model.type.DeclaredType,javax.lang.model.util.Elements,javax.lang.model.util.Types,javax.lang.model.element.TypeElement,javax.lang.model.element.ExecutableElement)>(v0, v1, v2, v10, v22);
if v24 == null goto label2;
return v24;
label3:
v25 = staticinvoke <io.vertx.codegen.Helper: javax.lang.model.element.AnnotationMirror isFluent(javax.lang.model.type.DeclaredType,javax.lang.model.util.Elements,javax.lang.model.util.Types,javax.lang.model.element.TypeElement,javax.lang.model.element.ExecutableElement,javax.lang.model.type.TypeMirror)>(v0, v1, v2, v3, v4, v9);
if v25 == null goto label1;
return v25;
label4:
return null;
}
public static javax.lang.model.type.TypeMirror resolveTypeParameter(javax.lang.model.util.Types, javax.lang.model.type.DeclaredType, javax.lang.model.element.TypeParameterElement)
{
javax.lang.model.type.DeclaredType v1;
boolean v11, v14, v7;
java.util.Iterator v13;
javax.lang.model.element.Element v3, v9;
javax.lang.model.util.Types v0;
javax.lang.model.element.TypeParameterElement v2;
java.util.List v12;
javax.lang.model.type.TypeMirror v10, v15, v16, v4, v5, v6, v8;
v0 := @parameter0: javax.lang.model.util.Types;
v1 := @parameter1: javax.lang.model.type.DeclaredType;
v2 := @parameter2: javax.lang.model.element.TypeParameterElement;
v3 = interfaceinvoke v2.<javax.lang.model.element.TypeParameterElement: javax.lang.model.element.Element getGenericElement()>();
v4 = interfaceinvoke v3.<javax.lang.model.element.Element: javax.lang.model.type.TypeMirror asType()>();
v5 = interfaceinvoke v0.<javax.lang.model.util.Types: javax.lang.model.type.TypeMirror erasure(javax.lang.model.type.TypeMirror)>(v4);
v6 = interfaceinvoke v0.<javax.lang.model.util.Types: javax.lang.model.type.TypeMirror erasure(javax.lang.model.type.TypeMirror)>(v1);
v7 = interfaceinvoke v0.<javax.lang.model.util.Types: boolean isSameType(javax.lang.model.type.TypeMirror,javax.lang.model.type.TypeMirror)>(v5, v6);
if v7 == 0 goto label1;
v8 = interfaceinvoke v2.<javax.lang.model.element.TypeParameterElement: javax.lang.model.type.TypeMirror asType()>();
v9 = interfaceinvoke v8.<javax.lang.model.type.TypeVariable: javax.lang.model.element.Element asElement()>();
v10 = interfaceinvoke v0.<javax.lang.model.util.Types: javax.lang.model.type.TypeMirror asMemberOf(javax.lang.model.type.DeclaredType,javax.lang.model.element.Element)>(v1, v9);
return v10;
label1:
v11 = interfaceinvoke v0.<javax.lang.model.util.Types: boolean isSubtype(javax.lang.model.type.TypeMirror,javax.lang.model.type.TypeMirror)>(v6, v5);
if v11 == 0 goto label3;
v12 = interfaceinvoke v0.<javax.lang.model.util.Types: java.util.List directSupertypes(javax.lang.model.type.TypeMirror)>(v1);
v13 = interfaceinvoke v12.<java.util.List: java.util.Iterator iterator()>();
label2:
v14 = interfaceinvoke v13.<java.util.Iterator: boolean hasNext()>();
if v14 == 0 goto label3;
interfaceinvoke v13.<java.util.Iterator: java.lang.Object next()>();
v15 = staticinvoke <io.vertx.codegen.Helper: javax.lang.model.type.TypeMirror resolveTypeParameter(javax.lang.model.util.Types,javax.lang.model.type.DeclaredType,javax.lang.model.element.TypeParameterElement)>(v0, v16, v2);
if v15 == null goto label2;
return v15;
label3:
return null;
}
public static java.lang.reflect.Type resolveTypeParameter(java.lang.reflect.Type, java.lang.reflect.TypeVariable)
{
boolean v14, v17, v2, v20, v22, v27, v8;
java.util.function.Predicate v5;
java.util.stream.Stream v4, v6;
java.lang.reflect.Type v0, v10, v11, v16, v18, v19, v29;
java.lang.reflect.Type[] v12, v28;
java.util.Optional v7;
java.util.ArrayList v9;
int v24, v25;
java.lang.String v31, v33, v34;
java.lang.reflect.GenericDeclaration v21;
java.lang.UnsupportedOperationException v30;
java.util.Iterator v13;
java.lang.reflect.TypeVariable v1, v26;
java.lang.reflect.TypeVariable[] v23, v3;
java.lang.Class v32;
java.lang.Object v15;
v0 := @parameter0: java.lang.reflect.Type;
v1 := @parameter1: java.lang.reflect.TypeVariable;
v2 = v0 instanceof java.lang.Class;
if v2 == 0 goto label4;
v3 = virtualinvoke v0.<java.lang.Class: java.lang.reflect.TypeVariable[] getTypeParameters()>();
v4 = staticinvoke <java.util.stream.Stream: java.util.stream.Stream of(java.lang.Object[])>(v3);
v5 = staticinvoke <io.vertx.codegen.Helper$lambda_resolveTypeParameter_8__2449: java.util.function.Predicate bootstrap$(java.lang.reflect.TypeVariable)>(v1);
v6 = interfaceinvoke v4.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v5);
v7 = interfaceinvoke v6.<java.util.stream.Stream: java.util.Optional findFirst()>();
v8 = virtualinvoke v7.<java.util.Optional: boolean isPresent()>();
if v8 == 0 goto label1;
return v1;
label1:
v9 = new java.util.ArrayList;
specialinvoke v9.<java.util.ArrayList: void <init>()>();
v10 = virtualinvoke v0.<java.lang.Class: java.lang.reflect.Type getGenericSuperclass()>();
if v10 == null goto label2;
v11 = virtualinvoke v0.<java.lang.Class: java.lang.reflect.Type getGenericSuperclass()>();
interfaceinvoke v9.<java.util.List: boolean add(java.lang.Object)>(v11);
label2:
v12 = virtualinvoke v0.<java.lang.Class: java.lang.reflect.Type[] getGenericInterfaces()>();
staticinvoke <java.util.Collections: boolean addAll(java.util.Collection,java.lang.Object[])>(v9, v12);
v13 = interfaceinvoke v9.<java.util.List: java.util.Iterator iterator()>();
label3:
v14 = interfaceinvoke v13.<java.util.Iterator: boolean hasNext()>();
if v14 == 0 goto label8;
v15 = interfaceinvoke v13.<java.util.Iterator: java.lang.Object next()>();
v16 = staticinvoke <io.vertx.codegen.Helper: java.lang.reflect.Type resolveTypeParameter(java.lang.reflect.Type,java.lang.reflect.TypeVariable)>(v15, v1);
if v16 == null goto label3;
return v16;
label4:
v17 = v0 instanceof java.lang.reflect.ParameterizedType;
if v17 == 0 goto label7;
v18 = interfaceinvoke v0.<java.lang.reflect.ParameterizedType: java.lang.reflect.Type getRawType()>();
v19 = staticinvoke <io.vertx.codegen.Helper: java.lang.reflect.Type resolveTypeParameter(java.lang.reflect.Type,java.lang.reflect.TypeVariable)>(v18, v1);
v20 = v19 instanceof java.lang.reflect.TypeVariable;
if v20 == 0 goto label8;
v21 = interfaceinvoke v19.<java.lang.reflect.TypeVariable: java.lang.reflect.GenericDeclaration getGenericDeclaration()>();
v22 = virtualinvoke v21.<java.lang.Object: boolean equals(java.lang.Object)>(v18);
if v22 == 0 goto label8;
v23 = interfaceinvoke v21.<java.lang.reflect.GenericDeclaration: java.lang.reflect.TypeVariable[] getTypeParameters()>();
v24 = 0;
label5:
v25 = lengthof v23;
if v24 >= v25 goto label8;
v26 = v23[v24];
v27 = virtualinvoke v26.<java.lang.Object: boolean equals(java.lang.Object)>(v19);
if v27 == 0 goto label6;
v28 = interfaceinvoke v0.<java.lang.reflect.ParameterizedType: java.lang.reflect.Type[] getActualTypeArguments()>();
v29 = v28[v24];
return v29;
label6:
v24 = v24 + 1;
goto label5;
label7:
v30 = new java.lang.UnsupportedOperationException;
v31 = interfaceinvoke v0.<java.lang.reflect.Type: java.lang.String getTypeName()>();
v32 = virtualinvoke v0.<java.lang.Object: java.lang.Class getClass()>();
v33 = virtualinvoke v32.<java.lang.Class: java.lang.String getName()>();
v34 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v31, v33) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Todo \u0001 \u0001");
specialinvoke v30.<java.lang.UnsupportedOperationException: void <init>(java.lang.String)>(v34);
throw v30;
label8:
return null;
}
public static javax.lang.model.element.Element resolveSignature(javax.lang.model.util.Elements, javax.lang.model.util.Types, javax.lang.model.element.TypeElement, java.lang.String)
{
javax.lang.model.element.TypeElement v10, v2, v32;
javax.lang.model.util.Elements v0;
java.util.regex.Matcher v5;
boolean v24, v28, v31, v6;
java.util.function.Predicate v15, v17;
javax.lang.model.util.Types v1;
java.util.List v22, v26;
java.util.regex.Pattern v4;
java.lang.String[] v16;
int v14, v8;
java.lang.String v11, v12, v13, v3, v7, v9;
java.util.Iterator v23, v27;
javax.lang.model.element.ElementKind v19, v20, v21, v30;
javax.lang.model.element.ElementKind[] v18;
java.lang.Object v25, v29;
v0 := @parameter0: javax.lang.model.util.Elements;
v1 := @parameter1: javax.lang.model.util.Types;
v2 := @parameter2: javax.lang.model.element.TypeElement;
v3 := @parameter3: java.lang.String;
v4 = <io.vertx.codegen.Helper: java.util.regex.Pattern SIGNATURE_PATTERN>;
v5 = virtualinvoke v4.<java.util.regex.Pattern: java.util.regex.Matcher matcher(java.lang.CharSequence)>(v3);
v6 = virtualinvoke v5.<java.util.regex.Matcher: boolean find()>();
if v6 == 0 goto label8;
v7 = virtualinvoke v5.<java.util.regex.Matcher: java.lang.String group(int)>(1);
v8 = virtualinvoke v5.<java.util.regex.Matcher: int start()>();
v9 = virtualinvoke v3.<java.lang.String: java.lang.String substring(int,int)>(0, v8);
v10 = staticinvoke <io.vertx.codegen.Helper: javax.lang.model.element.TypeElement resolveTypeElement(javax.lang.model.util.Elements,javax.lang.model.element.TypeElement,java.lang.String)>(v0, v2, v9);
if v10 == null goto label7;
v11 = virtualinvoke v5.<java.util.regex.Matcher: java.lang.String group(int)>(2);
if v11 == null goto label3;
v12 = virtualinvoke v5.<java.util.regex.Matcher: java.lang.String group(int)>(2);
v13 = virtualinvoke v12.<java.lang.String: java.lang.String trim()>();
v14 = virtualinvoke v13.<java.lang.String: int length()>();
if v14 != 0 goto label1;
v15 = staticinvoke <io.vertx.codegen.Helper$lambda_resolveSignature_9__2452: java.util.function.Predicate bootstrap$()>();
goto label2;
label1:
v16 = virtualinvoke v13.<java.lang.String: java.lang.String[] split(java.lang.String)>("\\s*,\\s*");
v15 = staticinvoke <io.vertx.codegen.Helper: java.util.function.Predicate parametersMatcher(javax.lang.model.util.Types,java.lang.String[])>(v1, v16);
label2:
v17 = staticinvoke <io.vertx.codegen.Helper$lambda_resolveSignature_10__2451: java.util.function.Predicate bootstrap$(java.lang.String,java.util.function.Predicate)>(v7, v15);
goto label4;
label3:
v17 = staticinvoke <io.vertx.codegen.Helper$lambda_resolveSignature_13__2450: java.util.function.Predicate bootstrap$(java.lang.String)>(v7);
label4:
v18 = newarray (javax.lang.model.element.ElementKind)[3];
v19 = <javax.lang.model.element.ElementKind: javax.lang.model.element.ElementKind FIELD>;
v18[0] = v19;
v20 = <javax.lang.model.element.ElementKind: javax.lang.model.element.ElementKind CONSTRUCTOR>;
v18[1] = v20;
v21 = <javax.lang.model.element.ElementKind: javax.lang.model.element.ElementKind METHOD>;
v18[2] = v21;
v22 = staticinvoke <java.util.Arrays: java.util.List asList(java.lang.Object[])>(v18);
v23 = interfaceinvoke v22.<java.util.List: java.util.Iterator iterator()>();
label5:
v24 = interfaceinvoke v23.<java.util.Iterator: boolean hasNext()>();
if v24 == 0 goto label7;
v25 = interfaceinvoke v23.<java.util.Iterator: java.lang.Object next()>();
v26 = interfaceinvoke v0.<javax.lang.model.util.Elements: java.util.List getAllMembers(javax.lang.model.element.TypeElement)>(v10);
v27 = interfaceinvoke v26.<java.util.List: java.util.Iterator iterator()>();
label6:
v28 = interfaceinvoke v27.<java.util.Iterator: boolean hasNext()>();
if v28 == 0 goto label5;
v29 = interfaceinvoke v27.<java.util.Iterator: java.lang.Object next()>();
v30 = interfaceinvoke v29.<javax.lang.model.element.Element: javax.lang.model.element.ElementKind getKind()>();
if v30 != v25 goto label6;
v31 = interfaceinvoke v17.<java.util.function.Predicate: boolean test(java.lang.Object)>(v29);
if v31 == 0 goto label6;
return v29;
label7:
return null;
label8:
v32 = staticinvoke <io.vertx.codegen.Helper: javax.lang.model.element.TypeElement resolveTypeElement(javax.lang.model.util.Elements,javax.lang.model.element.TypeElement,java.lang.String)>(v0, v2, v3);
return v32;
}
private static javax.lang.model.element.TypeElement resolveTypeElement(javax.lang.model.util.Elements, javax.lang.model.element.TypeElement, java.lang.String)
{
javax.lang.model.element.PackageElement v8;
javax.lang.model.element.TypeElement v1, v4;
javax.lang.model.util.Elements v0;
int v5, v6;
java.lang.String v10, v11, v2, v7;
boolean v3;
javax.lang.model.element.Name v9;
v0 := @parameter0: javax.lang.model.util.Elements;
v1 := @parameter1: javax.lang.model.element.TypeElement;
v2 := @parameter2: java.lang.String;
v3 = virtualinvoke v2.<java.lang.String: boolean isEmpty()>();
if v3 == 0 goto label1;
v4 = v1;
goto label3;
label1:
v5 = virtualinvoke v2.<java.lang.String: int lastIndexOf(int)>(46);
v6 = (int) -1;
if v5 != v6 goto label2;
v7 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v2) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("java.lang.\u0001");
v4 = interfaceinvoke v0.<javax.lang.model.util.Elements: javax.lang.model.element.TypeElement getTypeElement(java.lang.CharSequence)>(v7);
if v4 != null goto label3;
v8 = interfaceinvoke v0.<javax.lang.model.util.Elements: javax.lang.model.element.PackageElement getPackageOf(javax.lang.model.element.Element)>(v1);
v9 = interfaceinvoke v8.<javax.lang.model.element.PackageElement: javax.lang.model.element.Name getQualifiedName()>();
v10 = virtualinvoke v9.<java.lang.Object: java.lang.String toString()>();
v11 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v10, v2) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001.\u0001");
v4 = interfaceinvoke v0.<javax.lang.model.util.Elements: javax.lang.model.element.TypeElement getTypeElement(java.lang.CharSequence)>(v11);
goto label3;
label2:
v4 = interfaceinvoke v0.<javax.lang.model.util.Elements: javax.lang.model.element.TypeElement getTypeElement(java.lang.CharSequence)>(v2);
label3:
return v4;
}
private static boolean matchesConstructor(javax.lang.model.element.Element, java.lang.String, java.util.function.Predicate)
{
javax.lang.model.element.ElementKind v3, v4;
java.util.function.Predicate v2;
javax.lang.model.element.Element v0, v5;
java.lang.String v1, v7;
boolean v10, v8, v9;
javax.lang.model.element.Name v6;
v0 := @parameter0: javax.lang.model.element.Element;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.util.function.Predicate;
v3 = interfaceinvoke v0.<javax.lang.model.element.Element: javax.lang.model.element.ElementKind getKind()>();
v4 = <javax.lang.model.element.ElementKind: javax.lang.model.element.ElementKind CONSTRUCTOR>;
if v3 != v4 goto label3;
v5 = interfaceinvoke v0.<javax.lang.model.element.ExecutableElement: javax.lang.model.element.Element getEnclosingElement()>();
v6 = interfaceinvoke v5.<javax.lang.model.element.TypeElement: javax.lang.model.element.Name getSimpleName()>();
v7 = virtualinvoke v6.<java.lang.Object: java.lang.String toString()>();
v8 = virtualinvoke v7.<java.lang.String: boolean equals(java.lang.Object)>(v1);
if v8 == 0 goto label1;
v9 = interfaceinvoke v2.<java.util.function.Predicate: boolean test(java.lang.Object)>(v0);
if v9 == 0 goto label1;
v10 = 1;
goto label2;
label1:
v10 = 0;
label2:
return v10;
label3:
return 0;
}
private static boolean matchesMethod(javax.lang.model.element.Element, java.lang.String, java.util.function.Predicate)
{
javax.lang.model.element.ElementKind v3, v4;
java.util.function.Predicate v2;
javax.lang.model.element.Element v0;
java.lang.String v1, v6;
boolean v7, v8, v9;
javax.lang.model.element.Name v5;
v0 := @parameter0: javax.lang.model.element.Element;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.util.function.Predicate;
v3 = interfaceinvoke v0.<javax.lang.model.element.Element: javax.lang.model.element.ElementKind getKind()>();
v4 = <javax.lang.model.element.ElementKind: javax.lang.model.element.ElementKind METHOD>;
if v3 != v4 goto label3;
v5 = interfaceinvoke v0.<javax.lang.model.element.ExecutableElement: javax.lang.model.element.Name getSimpleName()>();
v6 = virtualinvoke v5.<java.lang.Object: java.lang.String toString()>();
v7 = virtualinvoke v6.<java.lang.String: boolean equals(java.lang.Object)>(v1);
if v7 == 0 goto label1;
v8 = interfaceinvoke v2.<java.util.function.Predicate: boolean test(java.lang.Object)>(v0);
if v8 == 0 goto label1;
v9 = 1;
goto label2;
label1:
v9 = 0;
label2:
return v9;
label3:
return 0;
}
private static boolean matchesField(javax.lang.model.element.Element, java.lang.String)
{
javax.lang.model.element.ElementKind v2, v3;
javax.lang.model.element.Element v0;
java.lang.String v1, v5;
boolean v6, v7;
javax.lang.model.element.Name v4;
v0 := @parameter0: javax.lang.model.element.Element;
v1 := @parameter1: java.lang.String;
v2 = interfaceinvoke v0.<javax.lang.model.element.Element: javax.lang.model.element.ElementKind getKind()>();
v3 = <javax.lang.model.element.ElementKind: javax.lang.model.element.ElementKind FIELD>;
if v2 != v3 goto label1;
v4 = interfaceinvoke v0.<javax.lang.model.element.Element: javax.lang.model.element.Name getSimpleName()>();
v5 = virtualinvoke v4.<java.lang.Object: java.lang.String toString()>();
v6 = virtualinvoke v5.<java.lang.String: boolean equals(java.lang.Object)>(v1);
if v6 == 0 goto label1;
v7 = 1;
goto label2;
label1:
v7 = 0;
label2:
return v7;
}
private static java.util.function.Predicate parametersMatcher(javax.lang.model.util.Types, java.lang.String[])
{
java.lang.String[] v1;
javax.lang.model.util.Types v0;
java.util.function.Predicate v2;
v0 := @parameter0: javax.lang.model.util.Types;
v1 := @parameter1: java.lang.String[];
v2 = staticinvoke <io.vertx.codegen.Helper$lambda_parametersMatcher_14__2453: java.util.function.Predicate bootstrap$(java.lang.String[],javax.lang.model.util.Types)>(v1, v0);
return v2;
}
public static javax.lang.model.element.TypeElement getElementTypeOf(javax.lang.model.element.Element)
{
javax.lang.model.element.ElementKind v1, v2, v3, v4;
javax.lang.model.element.Element v0, v5;
javax.lang.model.element.TypeElement v6;
v0 := @parameter0: javax.lang.model.element.Element;
v1 = interfaceinvoke v0.<javax.lang.model.element.Element: javax.lang.model.element.ElementKind getKind()>();
v2 = <javax.lang.model.element.ElementKind: javax.lang.model.element.ElementKind CLASS>;
if v1 == v2 goto label1;
v3 = <javax.lang.model.element.ElementKind: javax.lang.model.element.ElementKind INTERFACE>;
if v1 == v3 goto label1;
v4 = <javax.lang.model.element.ElementKind: javax.lang.model.element.ElementKind ENUM>;
if v1 != v4 goto label2;
label1:
return v0;
label2:
v5 = interfaceinvoke v0.<javax.lang.model.element.Element: javax.lang.model.element.Element getEnclosingElement()>();
if v5 == null goto label3;
v6 = staticinvoke <io.vertx.codegen.Helper: javax.lang.model.element.TypeElement getElementTypeOf(javax.lang.model.element.Element)>(v5);
return v6;
label3:
return null;
}
public static java.lang.String normalizeWhitespaces(java.lang.String)
{
java.util.regex.Matcher v2;
java.lang.String v0, v3, v4;
java.util.regex.Pattern v1;
v0 := @parameter0: java.lang.String;
v1 = <io.vertx.codegen.Helper: java.util.regex.Pattern WHITESPACE_CLUSTER_PATTERN>;
v2 = virtualinvoke v1.<java.util.regex.Pattern: java.util.regex.Matcher matcher(java.lang.CharSequence)>(v0);
v3 = virtualinvoke v2.<java.util.regex.Matcher: java.lang.String replaceAll(java.lang.String)>(" ");
v4 = virtualinvoke v3.<java.lang.String: java.lang.String trim()>();
return v4;
}
public static java.util.Set resolveAncestorTypes(javax.lang.model.element.TypeElement, boolean, boolean)
{
javax.lang.model.element.TypeElement v0;
java.util.LinkedHashSet v3;
boolean v1, v2;
v0 := @parameter0: javax.lang.model.element.TypeElement;
v1 := @parameter1: boolean;
v2 := @parameter2: boolean;
v3 = new java.util.LinkedHashSet;
specialinvoke v3.<java.util.LinkedHashSet: void <init>()>();
staticinvoke <io.vertx.codegen.Helper: void resolveAncestorTypes(javax.lang.model.element.TypeElement,java.util.Set,boolean,boolean)>(v0, v3, v1, v2);
return v3;
}
private static void resolveAncestorTypes(javax.lang.model.element.TypeElement, java.util.Set, boolean, boolean)
{
javax.lang.model.element.TypeElement v0;
java.util.ArrayList v4;
boolean v13, v2, v3, v9;
java.util.Iterator v8;
java.util.Set v1;
javax.lang.model.element.Element v14;
javax.lang.model.type.TypeKind v11, v12;
java.util.List v7;
javax.lang.model.type.TypeMirror v15, v5, v6;
java.lang.Object v10;
v0 := @parameter0: javax.lang.model.element.TypeElement;
v1 := @parameter1: java.util.Set;
v2 := @parameter2: boolean;
v3 := @parameter3: boolean;
v4 = new java.util.ArrayList;
specialinvoke v4.<java.util.ArrayList: void <init>()>();
if v2 == 0 goto label1;
v5 = interfaceinvoke v0.<javax.lang.model.element.TypeElement: javax.lang.model.type.TypeMirror getSuperclass()>();
if v5 == null goto label1;
v6 = interfaceinvoke v0.<javax.lang.model.element.TypeElement: javax.lang.model.type.TypeMirror getSuperclass()>();
interfaceinvoke v4.<java.util.List: boolean add(java.lang.Object)>(v6);
label1:
if v3 == 0 goto label2;
v7 = interfaceinvoke v0.<javax.lang.model.element.TypeElement: java.util.List getInterfaces()>();
interfaceinvoke v4.<java.util.List: boolean addAll(java.util.Collection)>(v7);
label2:
v8 = interfaceinvoke v4.<java.util.List: java.util.Iterator iterator()>();
label3:
v9 = interfaceinvoke v8.<java.util.Iterator: boolean hasNext()>();
if v9 == 0 goto label4;
v10 = interfaceinvoke v8.<java.util.Iterator: java.lang.Object next()>();
v11 = interfaceinvoke v10.<javax.lang.model.type.TypeMirror: javax.lang.model.type.TypeKind getKind()>();
v12 = <javax.lang.model.type.TypeKind: javax.lang.model.type.TypeKind DECLARED>;
if v11 != v12 goto label3;
v13 = interfaceinvoke v1.<java.util.Set: boolean contains(java.lang.Object)>(v15);
if v13 != 0 goto label3;
interfaceinvoke v1.<java.util.Set: boolean add(java.lang.Object)>(v15);
v14 = interfaceinvoke v15.<javax.lang.model.type.DeclaredType: javax.lang.model.element.Element asElement()>();
staticinvoke <io.vertx.codegen.Helper: void resolveAncestorTypes(javax.lang.model.element.TypeElement,java.util.Set,boolean,boolean)>(v14, v1, v2, v3);
goto label3;
label4:
return;
}
static void checkUnderModule(io.vertx.codegen.Model, java.lang.String)
{
io.vertx.codegen.GenException v3;
io.vertx.codegen.Model v0;
javax.lang.model.element.Element v4;
io.vertx.codegen.ModuleInfo v2;
java.lang.String v1, v5, v6;
v0 := @parameter0: io.vertx.codegen.Model;
v1 := @parameter1: java.lang.String;
v2 = interfaceinvoke v0.<io.vertx.codegen.Model: io.vertx.codegen.ModuleInfo getModule()>();
if v2 != null goto label1;
v3 = new io.vertx.codegen.GenException;
v4 = interfaceinvoke v0.<io.vertx.codegen.Model: javax.lang.model.element.Element getElement()>();
v5 = interfaceinvoke v0.<io.vertx.codegen.Model: java.lang.String getFqn()>();
v6 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v1, v5) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("Declaration annotated with \u0001 must be under a package annotatedwith @ModuleGen. Check that the package \'\u0001\' or a parent package contains a \'package-info.java\' using the @ModuleGen annotation");
specialinvoke v3.<io.vertx.codegen.GenException: void <init>(javax.lang.model.element.Element,java.lang.String)>(v4, v6);
throw v3;
label1:
return;
}
static void ensureParentDir(java.io.File)
{
java.io.File v0, v1, v3;
boolean v2;
v0 := @parameter0: java.io.File;
v1 = virtualinvoke v0.<java.io.File: java.io.File getParentFile()>();
v2 = virtualinvoke v1.<java.io.File: boolean exists()>();
if v2 != 0 goto label1;
v3 = virtualinvoke v0.<java.io.File: java.io.File getParentFile()>();
virtualinvoke v3.<java.io.File: boolean mkdirs()>();
label1:
return;
}
static java.lang.String toString(javax.lang.model.type.TypeMirror)
{
java.lang.StringBuilder v1;
javax.lang.model.type.TypeMirror v0;
java.lang.String v2;
v0 := @parameter0: javax.lang.model.type.TypeMirror;
v1 = new java.lang.StringBuilder;
specialinvoke v1.<java.lang.StringBuilder: void <init>()>();
staticinvoke <io.vertx.codegen.Helper: void toString(javax.lang.model.type.TypeMirror,java.lang.StringBuilder)>(v0, v1);
v2 = virtualinvoke v1.<java.lang.StringBuilder: java.lang.String toString()>();
return v2;
}
static void toString(javax.lang.model.type.TypeMirror, java.lang.StringBuilder)
{
int[] v2;
boolean v24;
javax.lang.model.element.Element v18, v6;
javax.lang.model.type.TypeKind v28, v29, v3, v31, v36;
java.util.List v9;
java.lang.StringBuilder v1;
int v10, v11, v12, v4, v5;
java.lang.String v20, v23, v32, v33, v37, v8;
javax.lang.model.element.Name v19, v7;
java.lang.UnsupportedOperationException v35;
javax.lang.model.type.TypeMirror v0, v14, v15, v16, v17, v21, v22, v25, v26, v27, v30, v34;
java.lang.Object v13;
v0 := @parameter0: javax.lang.model.type.TypeMirror;
v1 := @parameter1: java.lang.StringBuilder;
v2 = <io.vertx.codegen.Helper$1: int[] $SwitchMap$javax$lang$model$type$TypeKind>;
v3 = interfaceinvoke v0.<javax.lang.model.type.TypeMirror: javax.lang.model.type.TypeKind getKind()>();
v4 = virtualinvoke v3.<javax.lang.model.type.TypeKind: int ordinal()>();
v5 = v2[v4];
tableswitch(v5)
{
case 1: goto label01;
case 2: goto label05;
case 3: goto label07;
case 4: goto label09;
case 5: goto label09;
case 6: goto label09;
case 7: goto label09;
case 8: goto label09;
case 9: goto label09;
case 10: goto label09;
case 11: goto label09;
case 12: goto label10;
default: goto label11;
};
label01:
v6 = interfaceinvoke v0.<javax.lang.model.type.DeclaredType: javax.lang.model.element.Element asElement()>();
v7 = interfaceinvoke v6.<javax.lang.model.element.TypeElement: javax.lang.model.element.Name getQualifiedName()>();
v8 = virtualinvoke v7.<java.lang.Object: java.lang.String toString()>();
virtualinvoke v1.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(v8);
v9 = interfaceinvoke v0.<javax.lang.model.type.DeclaredType: java.util.List getTypeArguments()>();
v10 = interfaceinvoke v9.<java.util.List: int size()>();
if v10 <= 0 goto label12;
virtualinvoke v1.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("<");
v11 = 0;
label02:
v12 = interfaceinvoke v9.<java.util.List: int size()>();
if v11 >= v12 goto label04;
if v11 <= 0 goto label03;
virtualinvoke v1.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(",");
label03:
v13 = interfaceinvoke v9.<java.util.List: java.lang.Object get(int)>(v11);
staticinvoke <io.vertx.codegen.Helper: void toString(javax.lang.model.type.TypeMirror,java.lang.StringBuilder)>(v13, v1);
v11 = v11 + 1;
goto label02;
label04:
virtualinvoke v1.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(">");
goto label12;
label05:
virtualinvoke v1.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("?");
v14 = interfaceinvoke v0.<javax.lang.model.type.WildcardType: javax.lang.model.type.TypeMirror getSuperBound()>();
if v14 == null goto label06;
virtualinvoke v1.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" super ");
v15 = interfaceinvoke v0.<javax.lang.model.type.WildcardType: javax.lang.model.type.TypeMirror getSuperBound()>();
staticinvoke <io.vertx.codegen.Helper: void toString(javax.lang.model.type.TypeMirror,java.lang.StringBuilder)>(v15, v1);
goto label12;
label06:
v16 = interfaceinvoke v0.<javax.lang.model.type.WildcardType: javax.lang.model.type.TypeMirror getExtendsBound()>();
if v16 == null goto label12;
virtualinvoke v1.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" extends ");
v17 = interfaceinvoke v0.<javax.lang.model.type.WildcardType: javax.lang.model.type.TypeMirror getExtendsBound()>();
staticinvoke <io.vertx.codegen.Helper: void toString(javax.lang.model.type.TypeMirror,java.lang.StringBuilder)>(v17, v1);
goto label12;
label07:
v18 = interfaceinvoke v0.<javax.lang.model.type.TypeVariable: javax.lang.model.element.Element asElement()>();
v19 = interfaceinvoke v18.<javax.lang.model.element.TypeParameterElement: javax.lang.model.element.Name getSimpleName()>();
v20 = virtualinvoke v19.<java.lang.Object: java.lang.String toString()>();
virtualinvoke v1.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(v20);
v21 = interfaceinvoke v0.<javax.lang.model.type.TypeVariable: javax.lang.model.type.TypeMirror getUpperBound()>();
if v21 == null goto label08;
v22 = interfaceinvoke v0.<javax.lang.model.type.TypeVariable: javax.lang.model.type.TypeMirror getUpperBound()>();
v23 = interfaceinvoke v22.<javax.lang.model.type.TypeMirror: java.lang.String toString()>();
v24 = virtualinvoke v23.<java.lang.String: boolean equals(java.lang.Object)>("java.lang.Object");
if v24 != 0 goto label08;
virtualinvoke v1.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" extends ");
v25 = interfaceinvoke v0.<javax.lang.model.type.TypeVariable: javax.lang.model.type.TypeMirror getUpperBound()>();
staticinvoke <io.vertx.codegen.Helper: void toString(javax.lang.model.type.TypeMirror,java.lang.StringBuilder)>(v25, v1);
goto label12;
label08:
v26 = interfaceinvoke v0.<javax.lang.model.type.TypeVariable: javax.lang.model.type.TypeMirror getLowerBound()>();
if v26 == null goto label12;
v27 = interfaceinvoke v0.<javax.lang.model.type.TypeVariable: javax.lang.model.type.TypeMirror getLowerBound()>();
v28 = interfaceinvoke v27.<javax.lang.model.type.TypeMirror: javax.lang.model.type.TypeKind getKind()>();
v29 = <javax.lang.model.type.TypeKind: javax.lang.model.type.TypeKind NULL>;
if v28 == v29 goto label12;
virtualinvoke v1.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" super ");
v30 = interfaceinvoke v0.<javax.lang.model.type.TypeVariable: javax.lang.model.type.TypeMirror getUpperBound()>();
staticinvoke <io.vertx.codegen.Helper: void toString(javax.lang.model.type.TypeMirror,java.lang.StringBuilder)>(v30, v1);
goto label12;
label09:
v31 = interfaceinvoke v0.<javax.lang.model.type.PrimitiveType: javax.lang.model.type.TypeKind getKind()>();
v32 = virtualinvoke v31.<javax.lang.model.type.TypeKind: java.lang.String name()>();
v33 = virtualinvoke v32.<java.lang.String: java.lang.String toLowerCase()>();
virtualinvoke v1.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(v33);
goto label12;
label10:
v34 = interfaceinvoke v0.<javax.lang.model.type.ArrayType: javax.lang.model.type.TypeMirror getComponentType()>();
staticinvoke <io.vertx.codegen.Helper: void toString(javax.lang.model.type.TypeMirror,java.lang.StringBuilder)>(v34, v1);
virtualinvoke v1.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("[]");
goto label12;
label11:
v35 = new java.lang.UnsupportedOperationException;
v36 = interfaceinvoke v0.<javax.lang.model.type.TypeMirror: javax.lang.model.type.TypeKind getKind()>();
v37 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (javax.lang.model.type.TypeMirror,javax.lang.model.type.TypeKind)>(v0, v36) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("todo \u0001 \u0001");
specialinvoke v35.<java.lang.UnsupportedOperationException: void <init>(java.lang.String)>(v37);
throw v35;
label12:
return;
}
public static java.lang.reflect.Method getReflectMethod(javax.'annotation'.processing.ProcessingEnvironment, javax.lang.model.element.ExecutableElement)
{
java.util.Map v2;
javax.lang.model.element.ExecutableElement v1;
javax.'annotation'.processing.ProcessingEnvironment v0;
java.lang.Object v3;
java.lang.reflect.Method v4;
v0 := @parameter0: javax.'annotation'.processing.ProcessingEnvironment;
v1 := @parameter1: javax.lang.model.element.ExecutableElement;
v2 = <io.vertx.codegen.CodeGen: java.util.Map loaderMap>;
v3 = interfaceinvoke v2.<java.util.Map: java.lang.Object get(java.lang.Object)>(v0);
if v3 == null goto label1;
v4 = staticinvoke <io.vertx.codegen.Helper: java.lang.reflect.Method getReflectMethod(java.lang.ClassLoader,javax.lang.model.element.ExecutableElement)>(v3, v1);
return v4;
label1:
return null;
}
public static java.lang.reflect.Method getReflectMethod(java.lang.ClassLoader, javax.lang.model.element.ExecutableElement)
{
java.lang.reflect.Method[] v15;
int v10, v11, v16, v17, v20, v21, v22;
java.lang.String v14, v19, v23, v24, v5;
java.lang.reflect.Method v18, v3;
boolean v25, v28;
javax.lang.model.element.Name v4, v8;
javax.lang.model.element.ExecutableElement v1;
javax.lang.model.element.Element v2;
java.util.List v9;
javax.lang.model.type.TypeMirror v13;
java.lang.Class v26, v27, v6;
java.lang.ClassNotFoundException v29;
java.lang.Object v12;
java.lang.StringBuilder v7;
java.lang.ClassLoader v0;
v0 := @parameter0: java.lang.ClassLoader;
v1 := @parameter1: javax.lang.model.element.ExecutableElement;
v2 = interfaceinvoke v1.<javax.lang.model.element.ExecutableElement: javax.lang.model.element.Element getEnclosingElement()>();
v3 = null;
label1:
v4 = interfaceinvoke v2.<javax.lang.model.element.TypeElement: javax.lang.model.element.Name getQualifiedName()>();
v5 = virtualinvoke v4.<java.lang.Object: java.lang.String toString()>();
v6 = virtualinvoke v0.<java.lang.ClassLoader: java.lang.Class loadClass(java.lang.String)>(v5);
v7 = new java.lang.StringBuilder;
v8 = interfaceinvoke v1.<javax.lang.model.element.ExecutableElement: javax.lang.model.element.Name getSimpleName()>();
specialinvoke v7.<java.lang.StringBuilder: void <init>(java.lang.CharSequence)>(v8);
virtualinvoke v7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("(");
v9 = interfaceinvoke v1.<javax.lang.model.element.ExecutableElement: java.util.List getParameters()>();
v10 = 0;
label2:
v11 = interfaceinvoke v9.<java.util.List: int size()>();
if v10 >= v11 goto label4;
if v10 <= 0 goto label3;
virtualinvoke v7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(",");
label3:
v12 = interfaceinvoke v9.<java.util.List: java.lang.Object get(int)>(v10);
v13 = interfaceinvoke v12.<javax.lang.model.element.VariableElement: javax.lang.model.type.TypeMirror asType()>();
staticinvoke <io.vertx.codegen.Helper: void toString(javax.lang.model.type.TypeMirror,java.lang.StringBuilder)>(v13, v7);
v10 = v10 + 1;
goto label2;
label4:
virtualinvoke v7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(")");
v14 = virtualinvoke v7.<java.lang.StringBuilder: java.lang.String toString()>();
v15 = virtualinvoke v6.<java.lang.Class: java.lang.reflect.Method[] getMethods()>();
v16 = lengthof v15;
v17 = 0;
label5:
if v17 >= v16 goto label9;
v18 = v15[v17];
v19 = virtualinvoke v18.<java.lang.reflect.Method: java.lang.String toGenericString()>();
v20 = virtualinvoke v19.<java.lang.String: int indexOf(int)>(40);
v21 = virtualinvoke v19.<java.lang.String: int lastIndexOf(int,int)>(46, v20);
v22 = v21 + 1;
v23 = virtualinvoke v19.<java.lang.String: java.lang.String substring(int)>(v22);
v24 = virtualinvoke v23.<java.lang.String: java.lang.String replace(java.lang.CharSequence,java.lang.CharSequence)>(", ", ",");
v25 = virtualinvoke v24.<java.lang.String: boolean equals(java.lang.Object)>(v14);
if v25 == 0 goto label7;
if v3 == null goto label6;
v26 = virtualinvoke v3.<java.lang.reflect.Method: java.lang.Class getReturnType()>();
v27 = virtualinvoke v18.<java.lang.reflect.Method: java.lang.Class getReturnType()>();
v28 = virtualinvoke v26.<java.lang.Class: boolean isAssignableFrom(java.lang.Class)>(v27);
if v28 == 0 goto label7;
v3 = v18;
goto label7;
label6:
v3 = v18;
label7:
v17 = v17 + 1;
goto label5;
label8:
v29 := @caughtexception;
label9:
return v3;
catch java.lang.ClassNotFoundException from label1 to label8 with label8;
}
public static io.vertx.codegen.type.ClassKind getAnnotatedDataObjectAnnotatedSerializationType(javax.lang.model.util.Elements, javax.lang.model.element.TypeElement)
{
java.util.function.Predicate v6;
javax.lang.model.element.TypeElement v1;
java.util.function.Function v4, v8;
javax.lang.model.util.Elements v0;
java.util.List v2;
java.util.stream.Stream v3, v5, v7, v9;
java.util.Optional v10;
java.lang.Object v11;
v0 := @parameter0: javax.lang.model.util.Elements;
v1 := @parameter1: javax.lang.model.element.TypeElement;
v2 = interfaceinvoke v0.<javax.lang.model.util.Elements: java.util.List getAllMembers(javax.lang.model.element.TypeElement)>(v1);
v3 = interfaceinvoke v2.<java.util.List: java.util.stream.Stream stream()>();
v4 = <io.vertx.codegen.Helper: java.util.function.Function FILTER_METHOD>;
v5 = interfaceinvoke v3.<java.util.stream.Stream: java.util.stream.Stream flatMap(java.util.function.Function)>(v4);
v6 = staticinvoke <io.vertx.codegen.Helper$lambda_getAnnotatedDataObjectAnnotatedSerializationType_15__2454: java.util.function.Predicate bootstrap$()>();
v7 = interfaceinvoke v5.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v6);
v8 = staticinvoke <io.vertx.codegen.Helper$lambda_getAnnotatedDataObjectAnnotatedSerializationType_16__2455: java.util.function.Function bootstrap$()>();
v9 = interfaceinvoke v7.<java.util.stream.Stream: java.util.stream.Stream flatMap(java.util.function.Function)>(v8);
v10 = interfaceinvoke v9.<java.util.stream.Stream: java.util.Optional findFirst()>();
v11 = virtualinvoke v10.<java.util.Optional: java.lang.Object orElse(java.lang.Object)>(null);
return v11;
}
public static boolean isConcreteClass(javax.lang.model.element.TypeElement)
{
javax.lang.model.element.ElementKind v1, v2;
javax.lang.model.element.Modifier v4;
java.util.Set v3;
javax.lang.model.element.TypeElement v0;
boolean v5, v6;
v0 := @parameter0: javax.lang.model.element.TypeElement;
v1 = interfaceinvoke v0.<javax.lang.model.element.TypeElement: javax.lang.model.element.ElementKind getKind()>();
v2 = <javax.lang.model.element.ElementKind: javax.lang.model.element.ElementKind CLASS>;
if v1 != v2 goto label1;
v3 = interfaceinvoke v0.<javax.lang.model.element.TypeElement: java.util.Set getModifiers()>();
v4 = <javax.lang.model.element.Modifier: javax.lang.model.element.Modifier ABSTRACT>;
v5 = interfaceinvoke v3.<java.util.Set: boolean contains(java.lang.Object)>(v4);
if v5 != 0 goto label1;
v6 = 1;
goto label2;
label1:
v6 = 0;
label2:
return v6;
}
public static boolean isAbstractClassOrInterface(javax.lang.model.element.TypeElement)
{
javax.lang.model.element.ElementKind v1, v3, v4;
javax.lang.model.element.Modifier v6;
java.util.Set v5;
javax.lang.model.element.TypeElement v0;
boolean v2, v7, v8;
v0 := @parameter0: javax.lang.model.element.TypeElement;
v1 = interfaceinvoke v0.<javax.lang.model.element.TypeElement: javax.lang.model.element.ElementKind getKind()>();
v2 = virtualinvoke v1.<javax.lang.model.element.ElementKind: boolean isInterface()>();
if v2 != 0 goto label1;
v3 = interfaceinvoke v0.<javax.lang.model.element.TypeElement: javax.lang.model.element.ElementKind getKind()>();
v4 = <javax.lang.model.element.ElementKind: javax.lang.model.element.ElementKind CLASS>;
if v3 != v4 goto label2;
v5 = interfaceinvoke v0.<javax.lang.model.element.TypeElement: java.util.Set getModifiers()>();
v6 = <javax.lang.model.element.Modifier: javax.lang.model.element.Modifier ABSTRACT>;
v7 = interfaceinvoke v5.<java.util.Set: boolean contains(java.lang.Object)>(v6);
if v7 == 0 goto label2;
label1:
v8 = 1;
goto label3;
label2:
v8 = 0;
label3:
return v8;
}
public static io.vertx.codegen.type.ClassKind getAnnotatedDataObjectDeserialisationType(javax.lang.model.util.Elements, javax.lang.model.util.Types, javax.lang.model.element.TypeElement)
{
javax.lang.model.element.TypeElement v2;
java.util.function.Function v12, v8;
javax.lang.model.util.Elements v0;
java.util.stream.Collector v14;
io.vertx.codegen.type.ClassKind v17, v19;
boolean v16, v18, v3;
java.util.function.Predicate v10, v6;
javax.lang.model.util.Types v1;
java.util.List v4;
java.util.stream.Stream v11, v13, v5, v7, v9;
java.lang.Object v15;
v0 := @parameter0: javax.lang.model.util.Elements;
v1 := @parameter1: javax.lang.model.util.Types;
v2 := @parameter2: javax.lang.model.element.TypeElement;
v3 = staticinvoke <io.vertx.codegen.Helper: boolean isConcreteClass(javax.lang.model.element.TypeElement)>(v2);
if v3 == 0 goto label2;
v4 = interfaceinvoke v0.<javax.lang.model.util.Elements: java.util.List getAllMembers(javax.lang.model.element.TypeElement)>(v2);
v5 = interfaceinvoke v4.<java.util.List: java.util.stream.Stream stream()>();
v6 = staticinvoke <io.vertx.codegen.Helper$lambda_getAnnotatedDataObjectDeserialisationType_17__2456: java.util.function.Predicate bootstrap$()>();
v7 = interfaceinvoke v5.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v6);
v8 = staticinvoke <io.vertx.codegen.Helper$lambda_getAnnotatedDataObjectDeserialisationType_18__2457: java.util.function.Function bootstrap$()>();
v9 = interfaceinvoke v7.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v8);
v10 = staticinvoke <io.vertx.codegen.Helper$lambda_getAnnotatedDataObjectDeserialisationType_19__2458: java.util.function.Predicate bootstrap$()>();
v11 = interfaceinvoke v9.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v10);
v12 = staticinvoke <io.vertx.codegen.Helper$lambda_getAnnotatedDataObjectDeserialisationType_20__2459: java.util.function.Function bootstrap$()>();
v13 = interfaceinvoke v11.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v12);
v14 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector toSet()>();
v15 = interfaceinvoke v13.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v14);
v16 = interfaceinvoke v15.<java.util.Set: boolean contains(java.lang.Object)>("io.vertx.core.json.JsonObject");
if v16 == 0 goto label1;
v17 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind JSON_OBJECT>;
return v17;
label1:
v18 = interfaceinvoke v15.<java.util.Set: boolean contains(java.lang.Object)>("java.lang.String");
if v18 == 0 goto label2;
v19 = <io.vertx.codegen.type.ClassKind: io.vertx.codegen.type.ClassKind STRING>;
return v19;
label2:
return null;
}
public static boolean isGenIgnore(javax.lang.model.element.Element)
{
java.lang.'annotation'.Annotation v1;
javax.lang.model.element.Element v0;
boolean v2;
v0 := @parameter0: javax.lang.model.element.Element;
v1 = interfaceinvoke v0.<javax.lang.model.element.Element: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(class "Lio/vertx/codegen/annotations/GenIgnore;");
if v1 == null goto label1;
v2 = 1;
goto label2;
label1:
v2 = 0;
label2:
return v2;
}
static void <clinit>()
{
java.lang.String[] v10;
java.util.function.Function v0, v1, v2;
java.util.HashSet v9;
java.util.List v11;
java.lang.String v5, v6;
java.util.regex.Pattern v3, v4, v7, v8;
v0 = staticinvoke <io.vertx.codegen.Helper$lambda_static_0__2462: java.util.function.Function bootstrap$()>();
<io.vertx.codegen.Helper: java.util.function.Function FILTER_METHOD> = v0;
v1 = staticinvoke <io.vertx.codegen.Helper$lambda_static_1__2463: java.util.function.Function bootstrap$()>();
<io.vertx.codegen.Helper: java.util.function.Function FILTER_FIELD> = v1;
v2 = staticinvoke <io.vertx.codegen.Helper$lambda_static_4__2464: java.util.function.Function bootstrap$()>();
<io.vertx.codegen.Helper: java.util.function.Function CAST> = v2;
v3 = staticinvoke <java.util.regex.Pattern: java.util.regex.Pattern compile(java.lang.String)>("#(\\p{javaJavaIdentifierStart}(?:\\p{javaJavaIdentifierPart})*)(?:\\((.*)\\))?$");
<io.vertx.codegen.Helper: java.util.regex.Pattern SIGNATURE_PATTERN> = v3;
v4 = <io.vertx.codegen.Helper: java.util.regex.Pattern SIGNATURE_PATTERN>;
v5 = virtualinvoke v4.<java.util.regex.Pattern: java.lang.String pattern()>();
v6 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String)>(v5) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("(?:(?:\\p{javaJavaIdentifierStart}\\p{javaJavaIdentifierPart}*\\.)*\\p{javaJavaIdentifierStart}\\p{javaJavaIdentifierPart}*)?(?:\u0001)?");
v7 = staticinvoke <java.util.regex.Pattern: java.util.regex.Pattern compile(java.lang.String)>(v6);
<io.vertx.codegen.Helper: java.util.regex.Pattern LINK_REFERENCE_PATTERN> = v7;
v8 = staticinvoke <java.util.regex.Pattern: java.util.regex.Pattern compile(java.lang.String)>("\\s+");
<io.vertx.codegen.Helper: java.util.regex.Pattern WHITESPACE_CLUSTER_PATTERN> = v8;
v9 = new java.util.HashSet;
v10 = newarray (java.lang.String)[2];
v10[0] = "io.vertx.core.json.JsonObject";
v10[1] = "java.lang.String";
v11 = staticinvoke <java.util.Arrays: java.util.List asList(java.lang.Object[])>(v10);
specialinvoke v9.<java.util.HashSet: void <init>(java.util.Collection)>(v11);
<io.vertx.codegen.Helper: java.util.Set dataObjectTypes> = v9;
return;
}
}