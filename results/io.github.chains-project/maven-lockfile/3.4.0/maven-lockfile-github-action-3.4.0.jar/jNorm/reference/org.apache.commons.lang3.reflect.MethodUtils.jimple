public class org.apache.commons.lang3.reflect.MethodUtils extends java.lang.Object
{
private static final java.util.Comparator METHOD_BY_SIGNATURE;
public void <init>()
{
org.apache.commons.lang3.reflect.MethodUtils v0;
v0 := @this: org.apache.commons.lang3.reflect.MethodUtils;
specialinvoke v0.<java.lang.Object: void <init>()>();
return;
}
public static java.lang.Object invokeMethod(java.lang.Object, java.lang.String) throws java.lang.NoSuchMethodException, java.lang.IllegalAccessException, java.lang.reflect.InvocationTargetException
{
java.lang.Object[] v2;
java.lang.Object v0, v3;
java.lang.String v1;
v0 := @parameter0: java.lang.Object;
v1 := @parameter1: java.lang.String;
v2 = <org.apache.commons.lang3.ArrayUtils: java.lang.Object[] EMPTY_OBJECT_ARRAY>;
v3 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.Object invokeMethod(java.lang.Object,java.lang.String,java.lang.Object[],java.lang.Class[])>(v0, v1, v2, null);
return v3;
}
public static java.lang.Object invokeMethod(java.lang.Object, boolean, java.lang.String) throws java.lang.NoSuchMethodException, java.lang.IllegalAccessException, java.lang.reflect.InvocationTargetException
{
java.lang.Object[] v3;
java.lang.Object v0, v4;
java.lang.String v2;
boolean v1;
v0 := @parameter0: java.lang.Object;
v1 := @parameter1: boolean;
v2 := @parameter2: java.lang.String;
v3 = <org.apache.commons.lang3.ArrayUtils: java.lang.Object[] EMPTY_OBJECT_ARRAY>;
v4 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.Object invokeMethod(java.lang.Object,boolean,java.lang.String,java.lang.Object[],java.lang.Class[])>(v0, v1, v2, v3, null);
return v4;
}
public static transient java.lang.Object invokeMethod(java.lang.Object, java.lang.String, java.lang.Object[]) throws java.lang.NoSuchMethodException, java.lang.IllegalAccessException, java.lang.reflect.InvocationTargetException
{
java.lang.Object[] v2, v3;
java.lang.Class[] v4;
java.lang.Object v0, v5;
java.lang.String v1;
v0 := @parameter0: java.lang.Object;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.lang.Object[];
v3 = staticinvoke <org.apache.commons.lang3.ArrayUtils: java.lang.Object[] nullToEmpty(java.lang.Object[])>(v2);
v4 = staticinvoke <org.apache.commons.lang3.ClassUtils: java.lang.Class[] toClass(java.lang.Object[])>(v3);
v5 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.Object invokeMethod(java.lang.Object,java.lang.String,java.lang.Object[],java.lang.Class[])>(v0, v1, v3, v4);
return v5;
}
public static transient java.lang.Object invokeMethod(java.lang.Object, boolean, java.lang.String, java.lang.Object[]) throws java.lang.NoSuchMethodException, java.lang.IllegalAccessException, java.lang.reflect.InvocationTargetException
{
java.lang.Object[] v3, v4;
java.lang.Class[] v5;
java.lang.Object v0, v6;
java.lang.String v2;
boolean v1;
v0 := @parameter0: java.lang.Object;
v1 := @parameter1: boolean;
v2 := @parameter2: java.lang.String;
v3 := @parameter3: java.lang.Object[];
v4 = staticinvoke <org.apache.commons.lang3.ArrayUtils: java.lang.Object[] nullToEmpty(java.lang.Object[])>(v3);
v5 = staticinvoke <org.apache.commons.lang3.ClassUtils: java.lang.Class[] toClass(java.lang.Object[])>(v4);
v6 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.Object invokeMethod(java.lang.Object,boolean,java.lang.String,java.lang.Object[],java.lang.Class[])>(v0, v1, v2, v4, v5);
return v6;
}
public static java.lang.Object invokeMethod(java.lang.Object, boolean, java.lang.String, java.lang.Object[], java.lang.Class[]) throws java.lang.NoSuchMethodException, java.lang.IllegalAccessException, java.lang.reflect.InvocationTargetException
{
java.lang.Object[] v16, v3, v6;
java.lang.NoSuchMethodException v12;
java.lang.String v14, v15, v2, v7;
java.lang.reflect.Method v9;
boolean v1, v10;
java.lang.Class[] v4, v5;
java.lang.Class v11, v13, v8;
java.lang.Object v0, v17;
v0 := @parameter0: java.lang.Object;
v1 := @parameter1: boolean;
v2 := @parameter2: java.lang.String;
v3 := @parameter3: java.lang.Object[];
v4 := @parameter4: java.lang.Class[];
v5 = staticinvoke <org.apache.commons.lang3.ArrayUtils: java.lang.Class[] nullToEmpty(java.lang.Class[])>(v4);
v6 = staticinvoke <org.apache.commons.lang3.ArrayUtils: java.lang.Object[] nullToEmpty(java.lang.Object[])>(v3);
if v1 == 0 goto label1;
v7 = "No such method: ";
v8 = virtualinvoke v0.<java.lang.Object: java.lang.Class getClass()>();
v9 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.reflect.Method getMatchingMethod(java.lang.Class,java.lang.String,java.lang.Class[])>(v8, v2, v5);
if v9 == null goto label2;
v10 = virtualinvoke v9.<java.lang.reflect.Method: boolean isAccessible()>();
if v10 != 0 goto label2;
virtualinvoke v9.<java.lang.reflect.Method: void setAccessible(boolean)>(1);
goto label2;
label1:
v7 = "No such accessible method: ";
v11 = virtualinvoke v0.<java.lang.Object: java.lang.Class getClass()>();
v9 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.reflect.Method getMatchingAccessibleMethod(java.lang.Class,java.lang.String,java.lang.Class[])>(v11, v2, v5);
label2:
if v9 != null goto label3;
v12 = new java.lang.NoSuchMethodException;
v13 = virtualinvoke v0.<java.lang.Object: java.lang.Class getClass()>();
v14 = virtualinvoke v13.<java.lang.Class: java.lang.String getName()>();
v15 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String,java.lang.String)>(v7, v2, v14) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001\u0001() on object: \u0001");
specialinvoke v12.<java.lang.NoSuchMethodException: void <init>(java.lang.String)>(v15);
throw v12;
label3:
v16 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.Object[] toVarArgs(java.lang.reflect.Method,java.lang.Object[])>(v9, v6);
v17 = virtualinvoke v9.<java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>(v0, v16);
return v17;
}
public static java.lang.Object invokeMethod(java.lang.Object, java.lang.String, java.lang.Object[], java.lang.Class[]) throws java.lang.NoSuchMethodException, java.lang.IllegalAccessException, java.lang.reflect.InvocationTargetException
{
java.lang.Object[] v2;
java.lang.Class[] v3;
java.lang.Object v0, v4;
java.lang.String v1;
v0 := @parameter0: java.lang.Object;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.lang.Object[];
v3 := @parameter3: java.lang.Class[];
v4 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.Object invokeMethod(java.lang.Object,boolean,java.lang.String,java.lang.Object[],java.lang.Class[])>(v0, 0, v1, v2, v3);
return v4;
}
public static java.lang.Object invokeExactMethod(java.lang.Object, java.lang.String) throws java.lang.NoSuchMethodException, java.lang.IllegalAccessException, java.lang.reflect.InvocationTargetException
{
java.lang.Object[] v2;
java.lang.Object v0, v3;
java.lang.String v1;
v0 := @parameter0: java.lang.Object;
v1 := @parameter1: java.lang.String;
v2 = <org.apache.commons.lang3.ArrayUtils: java.lang.Object[] EMPTY_OBJECT_ARRAY>;
v3 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.Object invokeExactMethod(java.lang.Object,java.lang.String,java.lang.Object[],java.lang.Class[])>(v0, v1, v2, null);
return v3;
}
public static transient java.lang.Object invokeExactMethod(java.lang.Object, java.lang.String, java.lang.Object[]) throws java.lang.NoSuchMethodException, java.lang.IllegalAccessException, java.lang.reflect.InvocationTargetException
{
java.lang.Object[] v2, v3;
java.lang.Class[] v4;
java.lang.Object v0, v5;
java.lang.String v1;
v0 := @parameter0: java.lang.Object;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.lang.Object[];
v3 = staticinvoke <org.apache.commons.lang3.ArrayUtils: java.lang.Object[] nullToEmpty(java.lang.Object[])>(v2);
v4 = staticinvoke <org.apache.commons.lang3.ClassUtils: java.lang.Class[] toClass(java.lang.Object[])>(v3);
v5 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.Object invokeExactMethod(java.lang.Object,java.lang.String,java.lang.Object[],java.lang.Class[])>(v0, v1, v3, v4);
return v5;
}
public static java.lang.Object invokeExactMethod(java.lang.Object, java.lang.String, java.lang.Object[], java.lang.Class[]) throws java.lang.NoSuchMethodException, java.lang.IllegalAccessException, java.lang.reflect.InvocationTargetException
{
java.lang.Object[] v2, v4;
java.lang.NoSuchMethodException v8;
java.lang.Class[] v3, v5;
java.lang.Class v6, v9;
java.lang.Object v0, v12;
java.lang.String v1, v10, v11;
java.lang.reflect.Method v7;
v0 := @parameter0: java.lang.Object;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.lang.Object[];
v3 := @parameter3: java.lang.Class[];
v4 = staticinvoke <org.apache.commons.lang3.ArrayUtils: java.lang.Object[] nullToEmpty(java.lang.Object[])>(v2);
v5 = staticinvoke <org.apache.commons.lang3.ArrayUtils: java.lang.Class[] nullToEmpty(java.lang.Class[])>(v3);
v6 = virtualinvoke v0.<java.lang.Object: java.lang.Class getClass()>();
v7 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.reflect.Method getAccessibleMethod(java.lang.Class,java.lang.String,java.lang.Class[])>(v6, v1, v5);
if v7 != null goto label1;
v8 = new java.lang.NoSuchMethodException;
v9 = virtualinvoke v0.<java.lang.Object: java.lang.Class getClass()>();
v10 = virtualinvoke v9.<java.lang.Class: java.lang.String getName()>();
v11 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v1, v10) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("No such accessible method: \u0001() on object: \u0001");
specialinvoke v8.<java.lang.NoSuchMethodException: void <init>(java.lang.String)>(v11);
throw v8;
label1:
v12 = virtualinvoke v7.<java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>(v0, v4);
return v12;
}
public static java.lang.Object invokeExactStaticMethod(java.lang.Class, java.lang.String, java.lang.Object[], java.lang.Class[]) throws java.lang.NoSuchMethodException, java.lang.IllegalAccessException, java.lang.reflect.InvocationTargetException
{
java.lang.Object[] v2, v4;
java.lang.NoSuchMethodException v7;
java.lang.Class[] v3, v5;
java.lang.Class v0;
java.lang.Object v10;
java.lang.String v1, v8, v9;
java.lang.reflect.Method v6;
v0 := @parameter0: java.lang.Class;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.lang.Object[];
v3 := @parameter3: java.lang.Class[];
v4 = staticinvoke <org.apache.commons.lang3.ArrayUtils: java.lang.Object[] nullToEmpty(java.lang.Object[])>(v2);
v5 = staticinvoke <org.apache.commons.lang3.ArrayUtils: java.lang.Class[] nullToEmpty(java.lang.Class[])>(v3);
v6 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.reflect.Method getAccessibleMethod(java.lang.Class,java.lang.String,java.lang.Class[])>(v0, v1, v5);
if v6 != null goto label1;
v7 = new java.lang.NoSuchMethodException;
v8 = virtualinvoke v0.<java.lang.Class: java.lang.String getName()>();
v9 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v1, v8) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("No such accessible method: \u0001() on class: \u0001");
specialinvoke v7.<java.lang.NoSuchMethodException: void <init>(java.lang.String)>(v9);
throw v7;
label1:
v10 = virtualinvoke v6.<java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>(null, v4);
return v10;
}
public static transient java.lang.Object invokeStaticMethod(java.lang.Class, java.lang.String, java.lang.Object[]) throws java.lang.NoSuchMethodException, java.lang.IllegalAccessException, java.lang.reflect.InvocationTargetException
{
java.lang.Object[] v2, v3;
java.lang.Class[] v4;
java.lang.Class v0;
java.lang.Object v5;
java.lang.String v1;
v0 := @parameter0: java.lang.Class;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.lang.Object[];
v3 = staticinvoke <org.apache.commons.lang3.ArrayUtils: java.lang.Object[] nullToEmpty(java.lang.Object[])>(v2);
v4 = staticinvoke <org.apache.commons.lang3.ClassUtils: java.lang.Class[] toClass(java.lang.Object[])>(v3);
v5 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.Object invokeStaticMethod(java.lang.Class,java.lang.String,java.lang.Object[],java.lang.Class[])>(v0, v1, v3, v4);
return v5;
}
public static java.lang.Object invokeStaticMethod(java.lang.Class, java.lang.String, java.lang.Object[], java.lang.Class[]) throws java.lang.NoSuchMethodException, java.lang.IllegalAccessException, java.lang.reflect.InvocationTargetException
{
java.lang.Object[] v10, v2, v4;
java.lang.NoSuchMethodException v7;
java.lang.Class[] v3, v5;
java.lang.Class v0;
java.lang.Object v11;
java.lang.String v1, v8, v9;
java.lang.reflect.Method v6;
v0 := @parameter0: java.lang.Class;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.lang.Object[];
v3 := @parameter3: java.lang.Class[];
v4 = staticinvoke <org.apache.commons.lang3.ArrayUtils: java.lang.Object[] nullToEmpty(java.lang.Object[])>(v2);
v5 = staticinvoke <org.apache.commons.lang3.ArrayUtils: java.lang.Class[] nullToEmpty(java.lang.Class[])>(v3);
v6 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.reflect.Method getMatchingAccessibleMethod(java.lang.Class,java.lang.String,java.lang.Class[])>(v0, v1, v5);
if v6 != null goto label1;
v7 = new java.lang.NoSuchMethodException;
v8 = virtualinvoke v0.<java.lang.Class: java.lang.String getName()>();
v9 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.String)>(v1, v8) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("No such accessible method: \u0001() on class: \u0001");
specialinvoke v7.<java.lang.NoSuchMethodException: void <init>(java.lang.String)>(v9);
throw v7;
label1:
v10 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.Object[] toVarArgs(java.lang.reflect.Method,java.lang.Object[])>(v6, v4);
v11 = virtualinvoke v6.<java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>(null, v10);
return v11;
}
private static java.lang.Object[] toVarArgs(java.lang.reflect.Method, java.lang.Object[])
{
java.lang.Object[] v1;
java.lang.Class[] v3;
java.lang.reflect.Method v0;
boolean v2;
v0 := @parameter0: java.lang.reflect.Method;
v1 := @parameter1: java.lang.Object[];
v2 = virtualinvoke v0.<java.lang.reflect.Method: boolean isVarArgs()>();
if v2 == 0 goto label1;
v3 = virtualinvoke v0.<java.lang.reflect.Method: java.lang.Class[] getParameterTypes()>();
v1 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.Object[] getVarArgs(java.lang.Object[],java.lang.Class[])>(v1, v3);
label1:
return v1;
}
static java.lang.Object[] getVarArgs(java.lang.Object[], java.lang.Class[])
{
boolean v14, v31;
java.lang.Object[] v0, v16;
int v11, v12, v15, v17, v18, v19, v2, v20, v23, v24, v25, v26, v29, v3, v30, v32, v33, v4, v5, v7, v8;
java.lang.Class[] v1;
java.lang.Class v10, v13, v21, v22, v27;
java.lang.Object v28, v6, v9;
v0 := @parameter0: java.lang.Object[];
v1 := @parameter1: java.lang.Class[];
v2 = lengthof v0;
v3 = lengthof v1;
if v2 != v3 goto label2;
v4 = lengthof v0;
v5 = v4 - 1;
v6 = v0[v5];
if v6 == null goto label1;
v7 = lengthof v0;
v8 = v7 - 1;
v9 = v0[v8];
v10 = virtualinvoke v9.<java.lang.Object: java.lang.Class getClass()>();
v11 = lengthof v1;
v12 = v11 - 1;
v13 = v1[v12];
v14 = virtualinvoke v10.<java.lang.Object: boolean equals(java.lang.Object)>(v13);
if v14 == 0 goto label2;
label1:
return v0;
label2:
v15 = lengthof v1;
v16 = newarray (java.lang.Object)[v15];
v17 = lengthof v1;
v18 = v17 - 1;
staticinvoke <java.lang.System: void arraycopy(java.lang.Object,int,java.lang.Object,int,int)>(v0, 0, v16, 0, v18);
v19 = lengthof v1;
v20 = v19 - 1;
v21 = v1[v20];
v22 = virtualinvoke v21.<java.lang.Class: java.lang.Class getComponentType()>();
v23 = lengthof v0;
v24 = lengthof v1;
v25 = v23 - v24;
v26 = v25 + 1;
v27 = staticinvoke <org.apache.commons.lang3.ClassUtils: java.lang.Class primitiveToWrapper(java.lang.Class)>(v22);
v28 = staticinvoke <java.lang.reflect.Array: java.lang.Object newInstance(java.lang.Class,int)>(v27, v26);
v29 = lengthof v1;
v30 = v29 - 1;
staticinvoke <java.lang.System: void arraycopy(java.lang.Object,int,java.lang.Object,int,int)>(v0, v30, v28, 0, v26);
v31 = virtualinvoke v22.<java.lang.Class: boolean isPrimitive()>();
if v31 == 0 goto label3;
v28 = staticinvoke <org.apache.commons.lang3.ArrayUtils: java.lang.Object toPrimitive(java.lang.Object)>(v28);
label3:
v32 = lengthof v1;
v33 = v32 - 1;
v16[v33] = v28;
return v16;
}
public static transient java.lang.Object invokeExactStaticMethod(java.lang.Class, java.lang.String, java.lang.Object[]) throws java.lang.NoSuchMethodException, java.lang.IllegalAccessException, java.lang.reflect.InvocationTargetException
{
java.lang.Object[] v2, v3;
java.lang.Class[] v4;
java.lang.Class v0;
java.lang.Object v5;
java.lang.String v1;
v0 := @parameter0: java.lang.Class;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.lang.Object[];
v3 = staticinvoke <org.apache.commons.lang3.ArrayUtils: java.lang.Object[] nullToEmpty(java.lang.Object[])>(v2);
v4 = staticinvoke <org.apache.commons.lang3.ClassUtils: java.lang.Class[] toClass(java.lang.Object[])>(v3);
v5 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.Object invokeExactStaticMethod(java.lang.Class,java.lang.String,java.lang.Object[],java.lang.Class[])>(v0, v1, v3, v4);
return v5;
}
public static transient java.lang.reflect.Method getAccessibleMethod(java.lang.Class, java.lang.String, java.lang.Class[])
{
java.lang.NoSuchMethodException v5;
java.lang.Class[] v2;
java.lang.Class v0;
java.lang.String v1;
java.lang.reflect.Method v3, v4;
v0 := @parameter0: java.lang.Class;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.lang.Class[];
label1:
v3 = virtualinvoke v0.<java.lang.Class: java.lang.reflect.Method getMethod(java.lang.String,java.lang.Class[])>(v1, v2);
v4 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.reflect.Method getAccessibleMethod(java.lang.reflect.Method)>(v3);
label2:
return v4;
label3:
v5 := @caughtexception;
return null;
catch java.lang.NoSuchMethodException from label1 to label2 with label3;
}
public static java.lang.reflect.Method getAccessibleMethod(java.lang.reflect.Method)
{
java.lang.Class[] v6;
int v3;
java.lang.Class v2;
java.lang.String v5;
java.lang.reflect.Method v0, v7;
boolean v1, v4;
v0 := @parameter0: java.lang.reflect.Method;
v1 = staticinvoke <org.apache.commons.lang3.reflect.MemberUtils: boolean isAccessible(java.lang.reflect.Member)>(v0);
if v1 != 0 goto label1;
return null;
label1:
v2 = virtualinvoke v0.<java.lang.reflect.Method: java.lang.Class getDeclaringClass()>();
v3 = virtualinvoke v2.<java.lang.Class: int getModifiers()>();
v4 = staticinvoke <java.lang.reflect.Modifier: boolean isPublic(int)>(v3);
if v4 == 0 goto label2;
return v0;
label2:
v5 = virtualinvoke v0.<java.lang.reflect.Method: java.lang.String getName()>();
v6 = virtualinvoke v0.<java.lang.reflect.Method: java.lang.Class[] getParameterTypes()>();
v7 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.reflect.Method getAccessibleMethodFromInterfaceNest(java.lang.Class,java.lang.String,java.lang.Class[])>(v2, v5, v6);
if v7 != null goto label3;
v7 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.reflect.Method getAccessibleMethodFromSuperclass(java.lang.Class,java.lang.String,java.lang.Class[])>(v2, v5, v6);
label3:
return v7;
}
private static transient java.lang.reflect.Method getAccessibleMethodFromSuperclass(java.lang.Class, java.lang.String, java.lang.Class[])
{
java.lang.NoSuchMethodException v7;
java.lang.Class[] v2;
int v4;
java.lang.Class v0, v3;
java.lang.String v1;
java.lang.reflect.Method v6;
boolean v5;
v0 := @parameter0: java.lang.Class;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.lang.Class[];
v3 = virtualinvoke v0.<java.lang.Class: java.lang.Class getSuperclass()>();
label1:
if v3 == null goto label6;
v4 = virtualinvoke v3.<java.lang.Class: int getModifiers()>();
v5 = staticinvoke <java.lang.reflect.Modifier: boolean isPublic(int)>(v4);
if v5 == 0 goto label5;
label2:
v6 = virtualinvoke v3.<java.lang.Class: java.lang.reflect.Method getMethod(java.lang.String,java.lang.Class[])>(v1, v2);
label3:
return v6;
label4:
v7 := @caughtexception;
return null;
label5:
v3 = virtualinvoke v3.<java.lang.Class: java.lang.Class getSuperclass()>();
goto label1;
label6:
return null;
catch java.lang.NoSuchMethodException from label2 to label3 with label4;
}
private static transient java.lang.reflect.Method getAccessibleMethodFromInterfaceNest(java.lang.Class, java.lang.String, java.lang.Class[])
{
java.lang.NoSuchMethodException v10;
java.lang.Class[] v2, v3;
int v4, v5, v7;
java.lang.Class v0, v6;
java.lang.String v1;
java.lang.reflect.Method v11, v9;
boolean v8;
v0 := @parameter0: java.lang.Class;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.lang.Class[];
label1:
if v0 == null goto label8;
v3 = virtualinvoke v0.<java.lang.Class: java.lang.Class[] getInterfaces()>();
v4 = lengthof v3;
v5 = 0;
label2:
if v5 >= v4 goto label7;
v6 = v3[v5];
v7 = virtualinvoke v6.<java.lang.Class: int getModifiers()>();
v8 = staticinvoke <java.lang.reflect.Modifier: boolean isPublic(int)>(v7);
if v8 == 0 goto label6;
label3:
v9 = virtualinvoke v6.<java.lang.Class: java.lang.reflect.Method getDeclaredMethod(java.lang.String,java.lang.Class[])>(v1, v2);
label4:
return v9;
label5:
v10 := @caughtexception;
v11 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.reflect.Method getAccessibleMethodFromInterfaceNest(java.lang.Class,java.lang.String,java.lang.Class[])>(v6, v1, v2);
if v11 == null goto label6;
return v11;
label6:
v5 = v5 + 1;
goto label2;
label7:
v0 = virtualinvoke v0.<java.lang.Class: java.lang.Class getSuperclass()>();
goto label1;
label8:
return null;
catch java.lang.NoSuchMethodException from label3 to label4 with label5;
}
public static transient java.lang.reflect.Method getMatchingAccessibleMethod(java.lang.Class, java.lang.String, java.lang.Class[])
{
java.lang.NoSuchMethodException v4;
java.lang.reflect.Method[] v5;
java.lang.reflect.Method v14, v18, v3, v9;
boolean v11, v12, v16, v20, v38, v39;
java.util.ArrayList v6;
int v19, v22, v23, v25, v26, v31, v32, v7, v8;
java.lang.String v1, v10, v30, v34, v35, v36;
java.util.Iterator v15;
java.lang.Class[] v2, v21, v24;
java.lang.Class v0, v27, v28, v29, v33, v37;
java.lang.Object v17;
java.util.Comparator v13;
v0 := @parameter0: java.lang.Class;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.lang.Class[];
label01:
v3 = virtualinvoke v0.<java.lang.Class: java.lang.reflect.Method getMethod(java.lang.String,java.lang.Class[])>(v1, v2);
staticinvoke <org.apache.commons.lang3.reflect.MemberUtils: boolean setAccessibleWorkaround(java.lang.reflect.AccessibleObject)>(v3);
label02:
return v3;
label03:
v4 := @caughtexception;
v5 = virtualinvoke v0.<java.lang.Class: java.lang.reflect.Method[] getMethods()>();
v6 = new java.util.ArrayList;
specialinvoke v6.<java.util.ArrayList: void <init>()>();
v7 = lengthof v5;
v8 = 0;
label04:
if v8 >= v7 goto label06;
v9 = v5[v8];
v10 = virtualinvoke v9.<java.lang.reflect.Method: java.lang.String getName()>();
v11 = virtualinvoke v10.<java.lang.String: boolean equals(java.lang.Object)>(v1);
if v11 == 0 goto label05;
v12 = staticinvoke <org.apache.commons.lang3.reflect.MemberUtils: boolean isMatchingMethod(java.lang.reflect.Method,java.lang.Class[])>(v9, v2);
if v12 == 0 goto label05;
interfaceinvoke v6.<java.util.List: boolean add(java.lang.Object)>(v9);
label05:
v8 = v8 + 1;
goto label04;
label06:
v13 = <org.apache.commons.lang3.reflect.MethodUtils: java.util.Comparator METHOD_BY_SIGNATURE>;
interfaceinvoke v6.<java.util.List: void sort(java.util.Comparator)>(v13);
v14 = null;
v15 = interfaceinvoke v6.<java.util.List: java.util.Iterator iterator()>();
label07:
v16 = interfaceinvoke v15.<java.util.Iterator: boolean hasNext()>();
if v16 == 0 goto label09;
v17 = interfaceinvoke v15.<java.util.Iterator: java.lang.Object next()>();
v18 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.reflect.Method getAccessibleMethod(java.lang.reflect.Method)>(v17);
if v18 == null goto label07;
if v14 == null goto label08;
v19 = staticinvoke <org.apache.commons.lang3.reflect.MemberUtils: int compareMethodFit(java.lang.reflect.Method,java.lang.reflect.Method,java.lang.Class[])>(v18, v14, v2);
if v19 >= 0 goto label07;
label08:
v14 = v18;
goto label07;
label09:
if v14 == null goto label14;
staticinvoke <org.apache.commons.lang3.reflect.MemberUtils: boolean setAccessibleWorkaround(java.lang.reflect.AccessibleObject)>(v14);
if v14 == null goto label14;
v20 = virtualinvoke v14.<java.lang.reflect.Method: boolean isVarArgs()>();
if v20 == 0 goto label14;
v21 = virtualinvoke v14.<java.lang.reflect.Method: java.lang.Class[] getParameterTypes()>();
v22 = lengthof v21;
if v22 <= 0 goto label14;
v23 = lengthof v2;
if v23 <= 0 goto label14;
v24 = virtualinvoke v14.<java.lang.reflect.Method: java.lang.Class[] getParameterTypes()>();
v25 = lengthof v24;
v26 = v25 - 1;
v27 = v24[v26];
v28 = virtualinvoke v27.<java.lang.Class: java.lang.Class getComponentType()>();
v29 = staticinvoke <org.apache.commons.lang3.ClassUtils: java.lang.Class primitiveToWrapper(java.lang.Class)>(v28);
v30 = virtualinvoke v29.<java.lang.Class: java.lang.String getName()>();
v31 = lengthof v2;
v32 = v31 - 1;
v33 = v2[v32];
if v33 != null goto label10;
v34 = null;
goto label11;
label10:
v34 = virtualinvoke v33.<java.lang.Class: java.lang.String getName()>();
label11:
v35 = v34;
if v33 != null goto label12;
v36 = null;
goto label13;
label12:
v37 = virtualinvoke v33.<java.lang.Class: java.lang.Class getSuperclass()>();
v36 = virtualinvoke v37.<java.lang.Class: java.lang.String getName()>();
label13:
if v35 == null goto label14;
if v36 == null goto label14;
v38 = virtualinvoke v30.<java.lang.String: boolean equals(java.lang.Object)>(v35);
if v38 != 0 goto label14;
v39 = virtualinvoke v30.<java.lang.String: boolean equals(java.lang.Object)>(v36);
if v39 != 0 goto label14;
return null;
label14:
return v14;
catch java.lang.NoSuchMethodException from label01 to label02 with label03;
}
public static transient java.lang.reflect.Method getMatchingMethod(java.lang.Class, java.lang.String, java.lang.Class[])
{
java.lang.IllegalStateException v36;
java.lang.reflect.Method[] v5;
java.util.stream.Collector v41, v48, v9;
boolean v21, v24, v30;
java.util.function.Predicate v17, v27, v7;
java.util.Collection v31;
java.util.List v11;
java.util.stream.Stream v12, v14, v16, v18, v26, v28, v38, v40, v45, v47, v6, v8;
java.lang.Object[] v3, v37, v4;
java.util.function.Function v13, v15, v39, v46;
int v34;
java.lang.String v1, v43, v44, v50;
java.util.Iterator v20, v32;
java.lang.Class[] v2, v23;
java.util.function.Consumer v19, v29;
java.util.TreeMap v25;
java.lang.Class v0;
java.lang.Object v10, v22, v33, v35, v42, v49;
v0 := @parameter0: java.lang.Class;
v1 := @parameter1: java.lang.String;
v2 := @parameter2: java.lang.Class[];
v3 = newarray (java.lang.Object)[0];
staticinvoke <org.apache.commons.lang3.Validate: java.lang.Object notNull(java.lang.Object,java.lang.String,java.lang.Object[])>(v0, "cls", v3);
v4 = newarray (java.lang.Object)[0];
staticinvoke <org.apache.commons.lang3.Validate: java.lang.CharSequence notEmpty(java.lang.CharSequence,java.lang.String,java.lang.Object[])>(v1, "methodName", v4);
v5 = virtualinvoke v0.<java.lang.Class: java.lang.reflect.Method[] getDeclaredMethods()>();
v6 = staticinvoke <java.util.Arrays: java.util.stream.Stream stream(java.lang.Object[])>(v5);
v7 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils$lambda_getMatchingMethod_0__134: java.util.function.Predicate bootstrap$(java.lang.String)>(v1);
v8 = interfaceinvoke v6.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v7);
v9 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector toList()>();
v10 = interfaceinvoke v8.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v9);
v11 = staticinvoke <org.apache.commons.lang3.ClassUtils: java.util.List getAllSuperclasses(java.lang.Class)>(v0);
v12 = interfaceinvoke v11.<java.util.List: java.util.stream.Stream stream()>();
v13 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils$getDeclaredMethods__135: java.util.function.Function bootstrap$()>();
v14 = interfaceinvoke v12.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v13);
v15 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils$stream__136: java.util.function.Function bootstrap$()>();
v16 = interfaceinvoke v14.<java.util.stream.Stream: java.util.stream.Stream flatMap(java.util.function.Function)>(v15);
v17 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils$lambda_getMatchingMethod_1__137: java.util.function.Predicate bootstrap$(java.lang.String)>(v1);
v18 = interfaceinvoke v16.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v17);
virtualinvoke v10.<java.lang.Object: java.lang.Class getClass()>();
v19 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils$add__138: java.util.function.Consumer bootstrap$(java.util.List)>(v10);
interfaceinvoke v18.<java.util.stream.Stream: void forEach(java.util.function.Consumer)>(v19);
v20 = interfaceinvoke v10.<java.util.List: java.util.Iterator iterator()>();
label1:
v21 = interfaceinvoke v20.<java.util.Iterator: boolean hasNext()>();
if v21 == 0 goto label2;
v22 = interfaceinvoke v20.<java.util.Iterator: java.lang.Object next()>();
v23 = virtualinvoke v22.<java.lang.reflect.Method: java.lang.Class[] getParameterTypes()>();
v24 = staticinvoke <java.util.Arrays: boolean deepEquals(java.lang.Object[],java.lang.Object[])>(v23, v2);
if v24 == 0 goto label1;
return v22;
label2:
v25 = new java.util.TreeMap;
specialinvoke v25.<java.util.TreeMap: void <init>()>();
v26 = interfaceinvoke v10.<java.util.List: java.util.stream.Stream stream()>();
v27 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils$lambda_getMatchingMethod_2__139: java.util.function.Predicate bootstrap$(java.lang.Class[])>(v2);
v28 = interfaceinvoke v26.<java.util.stream.Stream: java.util.stream.Stream filter(java.util.function.Predicate)>(v27);
v29 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils$lambda_getMatchingMethod_4__140: java.util.function.Consumer bootstrap$(java.lang.Class[],java.util.TreeMap)>(v2, v25);
interfaceinvoke v28.<java.util.stream.Stream: void forEach(java.util.function.Consumer)>(v29);
v30 = virtualinvoke v25.<java.util.TreeMap: boolean isEmpty()>();
if v30 == 0 goto label3;
return null;
label3:
v31 = virtualinvoke v25.<java.util.TreeMap: java.util.Collection values()>();
v32 = interfaceinvoke v31.<java.util.Collection: java.util.Iterator iterator()>();
v33 = interfaceinvoke v32.<java.util.Iterator: java.lang.Object next()>();
v34 = interfaceinvoke v33.<java.util.List: int size()>();
if v34 != 1 goto label4;
v35 = interfaceinvoke v33.<java.util.List: java.lang.Object get(int)>(0);
return v35;
label4:
v36 = new java.lang.IllegalStateException;
v37 = newarray (java.lang.Object)[3];
v38 = staticinvoke <java.util.Arrays: java.util.stream.Stream stream(java.lang.Object[])>(v2);
v39 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils$valueOf__141: java.util.function.Function bootstrap$()>();
v40 = interfaceinvoke v38.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v39);
v41 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)>(",", "(", ")");
v42 = interfaceinvoke v40.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v41);
v43 = dynamicinvoke "makeConcatWithConstants" <java.lang.String (java.lang.String,java.lang.Object)>(v1, v42) <java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>("\u0001\u0001");
v37[0] = v43;
v44 = virtualinvoke v0.<java.lang.Class: java.lang.String getName()>();
v37[1] = v44;
v45 = interfaceinvoke v33.<java.util.List: java.util.stream.Stream stream()>();
v46 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils$toString__142: java.util.function.Function bootstrap$()>();
v47 = interfaceinvoke v45.<java.util.stream.Stream: java.util.stream.Stream map(java.util.function.Function)>(v46);
v48 = staticinvoke <java.util.stream.Collectors: java.util.stream.Collector joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)>(",", "[", "]");
v49 = interfaceinvoke v47.<java.util.stream.Stream: java.lang.Object collect(java.util.stream.Collector)>(v48);
v37[2] = v49;
v50 = staticinvoke <java.lang.String: java.lang.String format(java.lang.String,java.lang.Object[])>("Found multiple candidates for method %s on class %s : %s", v37);
specialinvoke v36.<java.lang.IllegalStateException: void <init>(java.lang.String)>(v50);
throw v36;
}
private static int distance(java.lang.Class[], java.lang.Class[])
{
java.lang.Class[] v0, v1;
int v2, v4, v5, v6;
java.lang.Class v7, v8;
boolean v10, v11, v3, v9;
v0 := @parameter0: java.lang.Class[];
v1 := @parameter1: java.lang.Class[];
v2 = 0;
v3 = staticinvoke <org.apache.commons.lang3.ClassUtils: boolean isAssignable(java.lang.Class[],java.lang.Class[],boolean)>(v0, v1, 1);
if v3 != 0 goto label1;
v4 = (int) -1;
return v4;
label1:
v5 = 0;
label2:
v6 = lengthof v0;
if v5 >= v6 goto label5;
v7 = v0[v5];
v8 = v1[v5];
if v7 == null goto label4;
v9 = virtualinvoke v7.<java.lang.Object: boolean equals(java.lang.Object)>(v8);
if v9 != 0 goto label4;
v10 = staticinvoke <org.apache.commons.lang3.ClassUtils: boolean isAssignable(java.lang.Class,java.lang.Class,boolean)>(v7, v8, 1);
if v10 == 0 goto label3;
v11 = staticinvoke <org.apache.commons.lang3.ClassUtils: boolean isAssignable(java.lang.Class,java.lang.Class,boolean)>(v7, v8, 0);
if v11 != 0 goto label3;
v2 = v2 + 1;
goto label4;
label3:
v2 = v2 + 2;
label4:
v5 = v5 + 1;
goto label2;
label5:
return v2;
}
public static java.util.Set getOverrideHierarchy(java.lang.reflect.Method, org.apache.commons.lang3.ClassUtils$Interfaces)
{
org.apache.commons.lang3.ClassUtils$Interfaces v1;
java.lang.Iterable v5;
java.util.Map v14;
int v15, v16;
java.lang.String v9;
java.lang.reflect.Method v0, v10;
java.util.LinkedHashSet v2;
boolean v12, v23, v7;
java.util.Iterator v6;
java.lang.Class[] v11, v3;
java.lang.reflect.Type v18, v19, v21, v22;
java.lang.reflect.Type[] v17, v20;
java.lang.Class v13, v4;
java.lang.Object v8;
v0 := @parameter0: java.lang.reflect.Method;
v1 := @parameter1: org.apache.commons.lang3.ClassUtils$Interfaces;
staticinvoke <org.apache.commons.lang3.Validate: java.lang.Object notNull(java.lang.Object)>(v0);
v2 = new java.util.LinkedHashSet;
specialinvoke v2.<java.util.LinkedHashSet: void <init>()>();
interfaceinvoke v2.<java.util.Set: boolean add(java.lang.Object)>(v0);
v3 = virtualinvoke v0.<java.lang.reflect.Method: java.lang.Class[] getParameterTypes()>();
v4 = virtualinvoke v0.<java.lang.reflect.Method: java.lang.Class getDeclaringClass()>();
v5 = staticinvoke <org.apache.commons.lang3.ClassUtils: java.lang.Iterable hierarchy(java.lang.Class,org.apache.commons.lang3.ClassUtils$Interfaces)>(v4, v1);
v6 = interfaceinvoke v5.<java.lang.Iterable: java.util.Iterator iterator()>();
interfaceinvoke v6.<java.util.Iterator: java.lang.Object next()>();
label1:
v7 = interfaceinvoke v6.<java.util.Iterator: boolean hasNext()>();
if v7 == 0 goto label5;
v8 = interfaceinvoke v6.<java.util.Iterator: java.lang.Object next()>();
v9 = virtualinvoke v0.<java.lang.reflect.Method: java.lang.String getName()>();
v10 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.reflect.Method getMatchingAccessibleMethod(java.lang.Class,java.lang.String,java.lang.Class[])>(v8, v9, v3);
if v10 == null goto label1;
v11 = virtualinvoke v10.<java.lang.reflect.Method: java.lang.Class[] getParameterTypes()>();
v12 = staticinvoke <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>(v11, v3);
if v12 == 0 goto label2;
interfaceinvoke v2.<java.util.Set: boolean add(java.lang.Object)>(v10);
goto label1;
label2:
v13 = virtualinvoke v10.<java.lang.reflect.Method: java.lang.Class getDeclaringClass()>();
v14 = staticinvoke <org.apache.commons.lang3.reflect.TypeUtils: java.util.Map getTypeArguments(java.lang.reflect.Type,java.lang.Class)>(v4, v13);
v15 = 0;
label3:
v16 = lengthof v3;
if v15 >= v16 goto label4;
v17 = virtualinvoke v0.<java.lang.reflect.Method: java.lang.reflect.Type[] getGenericParameterTypes()>();
v18 = v17[v15];
v19 = staticinvoke <org.apache.commons.lang3.reflect.TypeUtils: java.lang.reflect.Type unrollVariables(java.util.Map,java.lang.reflect.Type)>(v14, v18);
v20 = virtualinvoke v10.<java.lang.reflect.Method: java.lang.reflect.Type[] getGenericParameterTypes()>();
v21 = v20[v15];
v22 = staticinvoke <org.apache.commons.lang3.reflect.TypeUtils: java.lang.reflect.Type unrollVariables(java.util.Map,java.lang.reflect.Type)>(v14, v21);
v23 = staticinvoke <org.apache.commons.lang3.reflect.TypeUtils: boolean equals(java.lang.reflect.Type,java.lang.reflect.Type)>(v19, v22);
if v23 == 0 goto label1;
v15 = v15 + 1;
goto label3;
label4:
interfaceinvoke v2.<java.util.Set: boolean add(java.lang.Object)>(v10);
goto label1;
label5:
return v2;
}
public static java.lang.reflect.Method[] getMethodsWithAnnotation(java.lang.Class, java.lang.Class)
{
java.lang.Class v0, v1;
java.lang.reflect.Method[] v2;
v0 := @parameter0: java.lang.Class;
v1 := @parameter1: java.lang.Class;
v2 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.reflect.Method[] getMethodsWithAnnotation(java.lang.Class,java.lang.Class,boolean,boolean)>(v0, v1, 0, 0);
return v2;
}
public static java.util.List getMethodsListWithAnnotation(java.lang.Class, java.lang.Class)
{
java.lang.Class v0, v1;
java.util.List v2;
v0 := @parameter0: java.lang.Class;
v1 := @parameter1: java.lang.Class;
v2 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.util.List getMethodsListWithAnnotation(java.lang.Class,java.lang.Class,boolean,boolean)>(v0, v1, 0, 0);
return v2;
}
public static java.lang.reflect.Method[] getMethodsWithAnnotation(java.lang.Class, java.lang.Class, boolean, boolean)
{
java.util.List v4;
java.lang.Object[] v6;
java.lang.Class v0, v1;
java.lang.reflect.Method[] v5;
boolean v2, v3;
v0 := @parameter0: java.lang.Class;
v1 := @parameter1: java.lang.Class;
v2 := @parameter2: boolean;
v3 := @parameter3: boolean;
v4 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.util.List getMethodsListWithAnnotation(java.lang.Class,java.lang.Class,boolean,boolean)>(v0, v1, v2, v3);
v5 = <org.apache.commons.lang3.ArrayUtils: java.lang.reflect.Method[] EMPTY_METHOD_ARRAY>;
v6 = interfaceinvoke v4.<java.util.List: java.lang.Object[] toArray(java.lang.Object[])>(v5);
return v6;
}
public static java.util.List getMethodsListWithAnnotation(java.lang.Class, java.lang.Class, boolean, boolean)
{
java.lang.Object[] v4, v5;
java.lang.reflect.Method[] v12, v13;
java.util.ArrayList v7, v8;
int v14, v15;
java.lang.reflect.Method v16;
boolean v10, v2, v3;
java.util.Iterator v9;
java.util.List v6;
java.lang.'annotation'.Annotation v17;
java.lang.Class v0, v1;
java.lang.Object v11;
v0 := @parameter0: java.lang.Class;
v1 := @parameter1: java.lang.Class;
v2 := @parameter2: boolean;
v3 := @parameter3: boolean;
v4 = newarray (java.lang.Object)[0];
staticinvoke <org.apache.commons.lang3.Validate: java.lang.Object notNull(java.lang.Object,java.lang.String,java.lang.Object[])>(v0, "cls", v4);
v5 = newarray (java.lang.Object)[0];
staticinvoke <org.apache.commons.lang3.Validate: java.lang.Object notNull(java.lang.Object,java.lang.String,java.lang.Object[])>(v1, "annotationCls", v5);
if v2 == 0 goto label1;
v6 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.util.List getAllSuperclassesAndInterfaces(java.lang.Class)>(v0);
goto label2;
label1:
v7 = new java.util.ArrayList;
v6 = v7;
specialinvoke v7.<java.util.ArrayList: void <init>()>();
label2:
interfaceinvoke v6.<java.util.List: void add(int,java.lang.Object)>(0, v0);
v8 = new java.util.ArrayList;
specialinvoke v8.<java.util.ArrayList: void <init>()>();
v9 = interfaceinvoke v6.<java.util.List: java.util.Iterator iterator()>();
label3:
v10 = interfaceinvoke v9.<java.util.Iterator: boolean hasNext()>();
if v10 == 0 goto label8;
v11 = interfaceinvoke v9.<java.util.Iterator: java.lang.Object next()>();
if v3 == 0 goto label4;
v12 = virtualinvoke v11.<java.lang.Class: java.lang.reflect.Method[] getDeclaredMethods()>();
goto label5;
label4:
v12 = virtualinvoke v11.<java.lang.Class: java.lang.reflect.Method[] getMethods()>();
label5:
v13 = v12;
v14 = lengthof v12;
v15 = 0;
label6:
if v15 >= v14 goto label3;
v16 = v13[v15];
v17 = virtualinvoke v16.<java.lang.reflect.Method: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(v1);
if v17 == null goto label7;
interfaceinvoke v8.<java.util.List: boolean add(java.lang.Object)>(v16);
label7:
v15 = v15 + 1;
goto label6;
label8:
return v8;
}
public static java.lang.'annotation'.Annotation getAnnotation(java.lang.reflect.Method, java.lang.Class, boolean, boolean)
{
java.lang.Object[] v4, v5;
java.lang.String v13, v16;
java.lang.reflect.Method v0, v15;
boolean v11, v2, v3, v6;
java.util.Iterator v10;
java.lang.Class[] v14, v17;
java.util.List v9;
java.lang.'annotation'.Annotation v7;
java.lang.Class v1, v8;
java.lang.Object v12;
v0 := @parameter0: java.lang.reflect.Method;
v1 := @parameter1: java.lang.Class;
v2 := @parameter2: boolean;
v3 := @parameter3: boolean;
v4 = newarray (java.lang.Object)[0];
staticinvoke <org.apache.commons.lang3.Validate: java.lang.Object notNull(java.lang.Object,java.lang.String,java.lang.Object[])>(v0, "method", v4);
v5 = newarray (java.lang.Object)[0];
staticinvoke <org.apache.commons.lang3.Validate: java.lang.Object notNull(java.lang.Object,java.lang.String,java.lang.Object[])>(v1, "annotationCls", v5);
if v3 != 0 goto label1;
v6 = staticinvoke <org.apache.commons.lang3.reflect.MemberUtils: boolean isAccessible(java.lang.reflect.Member)>(v0);
if v6 != 0 goto label1;
return null;
label1:
v7 = virtualinvoke v0.<java.lang.reflect.Method: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(v1);
if v7 != null goto label5;
if v2 == 0 goto label5;
v8 = virtualinvoke v0.<java.lang.reflect.Method: java.lang.Class getDeclaringClass()>();
v9 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.util.List getAllSuperclassesAndInterfaces(java.lang.Class)>(v8);
v10 = interfaceinvoke v9.<java.util.List: java.util.Iterator iterator()>();
label2:
v11 = interfaceinvoke v10.<java.util.Iterator: boolean hasNext()>();
if v11 == 0 goto label5;
v12 = interfaceinvoke v10.<java.util.Iterator: java.lang.Object next()>();
if v3 == 0 goto label3;
v13 = virtualinvoke v0.<java.lang.reflect.Method: java.lang.String getName()>();
v14 = virtualinvoke v0.<java.lang.reflect.Method: java.lang.Class[] getParameterTypes()>();
v15 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.reflect.Method getMatchingMethod(java.lang.Class,java.lang.String,java.lang.Class[])>(v12, v13, v14);
goto label4;
label3:
v16 = virtualinvoke v0.<java.lang.reflect.Method: java.lang.String getName()>();
v17 = virtualinvoke v0.<java.lang.reflect.Method: java.lang.Class[] getParameterTypes()>();
v15 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils: java.lang.reflect.Method getMatchingAccessibleMethod(java.lang.Class,java.lang.String,java.lang.Class[])>(v12, v16, v17);
label4:
if v15 == null goto label2;
v7 = virtualinvoke v15.<java.lang.reflect.Method: java.lang.'annotation'.Annotation getAnnotation(java.lang.Class)>(v1);
if v7 == null goto label2;
label5:
return v7;
}
private static java.util.List getAllSuperclassesAndInterfaces(java.lang.Class)
{
java.util.ArrayList v1;
java.util.List v2, v4;
int v11, v12, v13, v3, v5, v6, v7, v8, v9;
java.lang.Class v0;
java.lang.Object v10;
v0 := @parameter0: java.lang.Class;
if v0 != null goto label1;
return null;
label1:
v1 = new java.util.ArrayList;
specialinvoke v1.<java.util.ArrayList: void <init>()>();
v2 = staticinvoke <org.apache.commons.lang3.ClassUtils: java.util.List getAllSuperclasses(java.lang.Class)>(v0);
v3 = 0;
v4 = staticinvoke <org.apache.commons.lang3.ClassUtils: java.util.List getAllInterfaces(java.lang.Class)>(v0);
v5 = 0;
label2:
v6 = interfaceinvoke v4.<java.util.List: int size()>();
if v5 < v6 goto label3;
v7 = interfaceinvoke v2.<java.util.List: int size()>();
if v3 >= v7 goto label8;
label3:
v8 = interfaceinvoke v4.<java.util.List: int size()>();
if v5 < v8 goto label4;
v9 = v3;
v3 = v3 + 1;
v10 = interfaceinvoke v2.<java.util.List: java.lang.Object get(int)>(v9);
goto label7;
label4:
v11 = interfaceinvoke v2.<java.util.List: int size()>();
if v3 >= v11 goto label5;
if v5 < v3 goto label5;
if v3 < v5 goto label6;
label5:
v12 = v5;
v5 = v5 + 1;
interfaceinvoke v4.<java.util.List: java.lang.Object get(int)>(v12);
goto label7;
label6:
v13 = v3;
v3 = v3 + 1;
interfaceinvoke v2.<java.util.List: java.lang.Object get(int)>(v13);
label7:
interfaceinvoke v1.<java.util.List: boolean add(java.lang.Object)>(v10);
goto label2;
label8:
return v1;
}
static void <clinit>()
{
java.util.Comparator v1;
java.util.function.Function v0;
v0 = staticinvoke <org.apache.commons.lang3.reflect.MethodUtils$toString__144: java.util.function.Function bootstrap$()>();
v1 = staticinvoke <java.util.Comparator: java.util.Comparator comparing(java.util.function.Function)>(v0);
<org.apache.commons.lang3.reflect.MethodUtils: java.util.Comparator METHOD_BY_SIGNATURE> = v1;
return;
}
}